{"config":{"lang":["en","fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Tock - open conversational platform","text":"<p>Tock (The Open Conversation Kit) is a complete and open platform to build conversational agents - also known as bots. </p> <p>Tock does not depend on 3rd-party APIs, although it is possible to integrate with them. Users choose which components to embed and decide to keep (or share) ownership of conversational data and models.</p> <p>Tock has been used in production since 2016 by OUI.sncf (Web/mobile, messaging platforms, smart speakers) and more and more organisations (energy, banking, healthcare...).</p> <p>The platform source code is available on GitHub  under the Apache License, version 2.0.</p>"},{"location":"#overview","title":"Overview","text":"<p>The Tock.ai site is a good starting point to learn about the solution and its growing community. Tutorials, presentations and a live demo  (20 minutes, in English, \u2139\ufe0f abstract)  are also available:</p> <p> </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Bots standalone or integrated with Web sites, mobile apps, social networks, smart speakers.</li> <li>Full-featured NLU <sup>(Natural Language Understanding)</sup> platform:<ul> <li>Leveraging open technologies, such as  OpenNLP, Stanford CoreNLP,  Duckling, Rasa  (later Spacy, BERT, ...)</li> <li>Can be deployed alone (for use cases like Internet Of Things)(img/tock-nlp-admin.png \"NLU interface example - qualifying a sentence\")tps://nodejs.org/), Python DSLs  and any-language REST API (see Bot API)</li> </ul> </li> <li>Numerous text/voice integrations available with Messenger, WhatsApp,  Google Assistant, Alexa, Twitter,  Apple Business Chat, Teams,  Slack... (see connectors)</li> <li>Cloud or on-premise setups, with or without Docker,  \"embedded\" bots without Internet </li> </ul>"},{"location":"#technologies","title":"Technologies","text":"<p>Tock components can run as containers (provided implementation for Docker). </p> <p>The application runs on JVM platforms.  The reference language is Kotlin, but other programming languages can be leveraged through the available APIs.</p> <p>On the server side, Tock relies on Vert.x and MongoDB <sup>(alt. DocumentDB)</sup>.  Various NLU libraries and algorithms can be used, but Tock does not depend on them directly.</p> <p>Tock Studio graphical user interfaces are built with Angular in Typescript.</p> <p>React and Flutter toolkits are provided for Web and Mobile integrations.</p>"},{"location":"#getting-started","title":"Getting started...","text":"<ul> <li>Contents</li> <li>Read Tutorial and start using the demo/sandbox platform</li> <li>User manual for developers</li> </ul> <p>*[NLU]: Natural Language Understanding</p>"},{"location":"about/awards/","title":"Awards","text":"<p>From its creation in for OUI.sncf in 2016 to the French  AlloCovid service in 2020, both the technical solution  and bots designed with Tock have been awarded.</p>"},{"location":"about/awards/#best-open-source-strategy-2019-sncf","title":"Best Open Source Strategy 2019 (SNCF)","text":"<p>In 2019, the Acteurs du Libre award for the  Best Open Source Strategy was given to SNCF (\"French National Railway Company\") for creating and sharing open platforms, such as  Tock (e.Voyageurs subsidiary)  and Navitia (Kisio Digital subsidiary).</p> <p></p> <p>Simon Clavier and Fran\u00e7ois Nollen  received the award on December 10<sup>th</sup> in the Grand Auditorium of Paris Open Source Summit. Several photos and a  video recording (in French) are available.</p> <p>To find out more, see Les Acteurs Du Libre (French).</p>"},{"location":"about/awards/#best-robot-experience-2019-ouisncf","title":"Best Robot Experience 2019 (OUI.sncf)","text":"<p>In 2019, OUIbot was awarded the  Best Robot Experience  for the 2<sup>nd</sup> time in a row.</p> <p>Received by Caroline Chupin and   Evelyne Papon for OUI.sncf,  the award was the result of ranking 31 robots, chatbots and voicebots. </p> <p>An interview is available (in French). More on the Cultures Services blog (in French too).</p>"},{"location":"about/awards/#best-robot-experience-2018-ouisncf","title":"Best Robot Experience 2018 (OUI.sncf)","text":"<p>In 2018, OUIbot (the OUI.sncf assistant, with 10.000 users a day)  received the Best Robot Experience  award from the Acad\u00e9mie du Service / Sens du client.</p> <p>Given to Caroline Chupin for OUI.sncf, the award assessed mutliple criteria to rank 24 virtual agents from prestigious organizations (companies, GAFAM, public sector). </p> <p></p> <p>To find out more, visit the Sens du client blog.</p>"},{"location":"about/community/","title":"Community","text":"<p>Tock has been designed to remain an open platform shared with the community. To know more, see why Tock.</p> <p>The Tock community is open to contribution: every feedback, issue, feature request and obviously   pull request is more than welcome!</p>"},{"location":"about/community/#join-the-community-gitter","title":"Join the community (Gitter)","text":"<p>Many Tock users and contributors meet on Gitter chatrooms.  Join them to see how much the community is active and open.</p> <ul> <li>Tock community on Gitter</li> <li>Tock releases thread</li> </ul> <p> </p>"},{"location":"about/community/#follow-tock-news","title":"Follow Tock news","text":"<p>To find Tock news, new projects, conferences, releases and more please visit the homepage:</p> <ul> <li>Tock.ai</li> </ul> <p>Specific news can be found on these topics:</p> <ul> <li>Known users &amp; projects</li> <li>Presentations &amp; conferences</li> <li>Awards</li> </ul> <p>For releases &amp; features:</p> <ul> <li>Releases &amp; features thread</li> <li>Release Notes</li> <li>Roadmap</li> </ul>"},{"location":"about/community/#code-contribution-github","title":"Code &amp; Contribution (GitHub)","text":"<p>The Tock platform and tools are available on  GitHub under the Apache 2 license.</p> <ul> <li>Sources &amp; projects</li> <li>License</li> <li>Issues</li> <li>Contributors</li> </ul> <p>To know more about repository structure, coding conventions, etc. refer to the contribute to Tock section. For other types of contribution, don't hesitate to use GitHub issues  and join the community directly on Gitter.</p> <p> </p>"},{"location":"about/community/#tosit-association","title":"TOSIT association","text":"<p>The Tock solution is currently being assessed by the TOSIT (The Open Source I Trust),  an association dedicated to support Open Source and Free Software, as part of the Chatbots Work Group.</p> <p>Founded by Carrefour, EDF, Enedis, Orange, P\u00f4le Emploi and SNCF, TOSIT now gathers other important members, such as the (French) Minist\u00e8re des Arm\u00e9es, Soci\u00e9t\u00e9 G\u00e9n\u00e9rale or MAIF.</p> <p>Several TOSIT members, including SNCF, already use or experiment Tock.</p> <p>To know more about TOSIT, please visit http://tosit.fr/</p> <p></p>"},{"location":"about/community/#public-demo-hosting","title":"Public Demo hosting","text":"<p>The public Live Demo helps newcomers try and experiment with the solution. A dedicated user guide is available  to make one's first steps with Tock and bots. Thanks to e.Voyageurs SNCF for hosting and maintaining the  public Live Demo platform.</p> <ul> <li>Live Demo </li> <li>Guide Create your 1st bot with Tock</li> </ul>"},{"location":"about/community/#help","title":"Help","text":"<p>Feel free to contact us.</p>"},{"location":"about/contact/","title":"Contact us","text":"<p>Developers, users and curious people are more than welcome to share about Tock with both its creators and the community.</p> <ul> <li>Don't hesitate to join us on Gitter (the instant messaging service for GitHub): https://gitter.im/tockchat/Lobby</li> </ul> <p> </p> <ul> <li>GitHub issues can be used to keep track of bugs, enhancements or feature requests: https://github.com/theopenconversationkit/tock/issues</li> </ul> <p> </p>"},{"location":"about/contribute/","title":"Contribute to Tock","text":"<p>The Tock project is open to contribution and any feedback is welcome!</p> <p>This page details the source structure and coding conventions for the platform.</p>"},{"location":"about/contribute/#tldr","title":"TL;DR","text":"<p>See <code>CONTRIBUTING.md</code>.</p>"},{"location":"about/contribute/#main-technologies","title":"Main technologies","text":"<p>Tock components can run as containers (provided implementation for Docker).</p> <p>The application runs on JVM platforms. The reference language is Kotlin, but other programming languages can be leveraged through the available APIs.</p> <p>On the server side, Tock relies on Vert.x and MongoDB <sup>(alt. DocumentDB)</sup>. Various NLU libraries and algorithms can be used, but Tock does not depend on them directly.</p> <p>Tock Studio graphical user interfaces are built with Angular in Typescript.</p> <p>React and Flutter toolkits are provided for Web and Mobile integrations.</p>"},{"location":"about/contribute/#source-structure","title":"Source structure","text":""},{"location":"about/contribute/#repositories","title":"Repositories","text":"<ul> <li> <p><code>tock</code>: main source repository, including the framework   and platform components under the Apache 2 license.</p> </li> <li> <p><code>tock-corenlp</code>: optional module, leveraging a dependency to   Stanford CoreNLP (instead of Apache OpenNLP),   under GPL license.</p> </li> <li> <p><code>tock-docker</code>: Docker   and Docker Compose images/descriptors, for platform hands-on and fast deployment   of various configurations.</p> </li> <li> <p><code>tock-bot-samples</code>: code samples, in particular the WebHook and WebSocket modes examples from   Tock programming guides.</p> </li> <li> <p><code>tock-bot-open-data</code>: a bot example, based on   the SNCF Open Data API, also implementing basic internationalization (i18n)   mecanisms with two distinct languages.</p> </li> </ul>"},{"location":"about/contribute/#the-tock-repository","title":"The <code>tock</code> repository","text":"<p>TODO : detail modules and repo structure</p>"},{"location":"about/contribute/#le-tock-docker-repository","title":"Le <code>tock-docker</code> repository","text":"<p>TODO : detail modules and repo structure, how Maven and Docker builds work, etc.</p>"},{"location":"about/contribute/#build-run","title":"Build &amp; run","text":""},{"location":"about/contribute/#build-tock-from-sources","title":"Build Tock from sources","text":""},{"location":"about/contribute/#tock-core","title":"Tock (core)","text":"<p>Tock is built with Maven, including the Web modules leveraging NPM et Angular:</p> <p><code>$ mvn package</code></p> <p>Continuous integration build jobs are available on Travis.</p>"},{"location":"about/contribute/#docker-images","title":"Docker images","text":"<p>Tock Docker images can be rebuilt from sources, included in repository <code>tock-docker</code>. One can use Maven to trigger the Docker build:</p> <p><code>$ mvn package docker:build</code></p> <p>Docker containers can then be instantiated from images, or Docker Compose stacks from the various descriptors at the root of the repository.</p>"},{"location":"about/contribute/#run-tock-in-ide","title":"Run Tock in IDE","text":"<p>To run Tock using Docker Compose outside the IDE, rather see Deploy Tock with Docker.</p> <p>Tock components (NLU, Studio, bot...) can run in an IDE, such as IntelliJ, Eclipse or Visual Studio Code for instance.</p> <p>Beside the Docker images, IntelliJ configurations are provided with Tock sources:</p> <ul> <li>The Tock Studio interfaces/server: BotAdmin</li> <li>The alternative standalone NLU interfaces/server: Admin</li> <li>The NLU service: NlpService</li> <li>The Duckling entity-recognition service: Duckling</li> <li>The NLU model-builder service: BuildWorker</li> <li>The script compilation service: KotlinCompilerServer</li> </ul> <p>The OpenDataBot example also has a run configuration available:</p> <ul> <li>OpenDataBot</li> </ul> <p>To start the Tock Studio interfaces, please refer to the commands described in the following page:</p> <ul> <li>Full Tock Studio server commands</li> </ul>"},{"location":"about/contribute/#code","title":"Code","text":""},{"location":"about/contribute/#commits-merge-requests","title":"Commits &amp; merge requests","text":"<p>To submit a feature or bugfix:</p> <ol> <li>Create an issue:</li> <li>Reccommended format for the title: - <code>[Component] Title</code> where component might be      Studio, Core, Doc, etc. and title usually is like Do or fix something</li> <li>Create a pull request and link it to the issue(s):</li> <li>All commits should be signed</li> <li>Please rebase and squash unnecessary commits (tips: PR can be tagged as Draft) before submitting</li> <li>Recommended format for the branch name :<ul> <li><code>ISSUEID_short_title</code></li> </ul> </li> <li>Recommended format for the commit(s) message(s):<ul> <li><code>resolves #ISSUEID Component: title</code> for features</li> <li><code>fixes #ISSUEID Component: title</code> for fixes</li> </ul> </li> <li>To be merged, a pull request must pass the tests and be reviewed by at least two of these developers:</li> <li>@vsct-jburet,      @francoisno,      @NainJaune,      @elebescond,      @SarukaUsagi,      @MaximeLeFrancois,      @bakic,      @broxmik,      @mrboizo</li> </ol>"},{"location":"about/contribute/#code-conventions","title":"Code conventions","text":"<p>Kotlin Code Conventions are used.</p>"},{"location":"about/contribute/#unit-tests","title":"Unit tests","text":"<p>Every new feature or fix should embed its unit test(s).</p>"},{"location":"about/contribute/#contact-us","title":"Contact us","text":"<p>To contribute to the project or to known more about the implementation, feel free to contact us. Ideas and feedback is more than welcome.</p>"},{"location":"about/jobs/","title":"Tock jobs","text":"<p>Interested in working with Tock and contribute to the platform?</p> <p>This page lists companies and organizations, proposing job offers in the field of conversational AI with Tock:</p> e.Voyageurs SNCF (Tock creators) recruit various profiles to build conversational assistants with Tock. To known more, check offers on Gitter or https://jobs.oui.sncf/. <p>Do you leverage Tock and offer conversational jobs?</p> <p>Don't hesitate to tell us and expand the list.</p>"},{"location":"about/ressources/","title":"Tock Resources","text":"<p>The various supports and presentations below give an overview of the Tock solution, in addition to the guides to test the platform yourself.</p>"},{"location":"about/ressources/#conferences-video","title":"Conferences / Video","text":"<ul> <li>Gen AI with TOCK @ WAX 2024 (RAG and LLM Open Source? Towards more responsible Generative AI.) \u2139\ufe0f info \ud83d\udcfd\ufe0f 45 min</li> </ul> <ul> <li>20 minutes from zero to live chatbot with Tock  @ Open Source Experience 2021 (demonstration, in English)  \u2139\ufe0f info /  \ud83d\udcfd\ufe0f 20 min</li> </ul> <ul> <li>AlloCovid @ Voice Tech Paris 2020 (REX INSERM, Allo-Media &amp; SNCF)  \u2139\ufe0f info</li> </ul> <ul> <li>Tock &amp; M\u00e9lusine @ AI Paris 2020 (REX SNCF &amp; MAIF) \u2139\ufe0f info / \ud83d\udd33 slides</li> </ul> <ul> <li>Conversational &amp; Open Source @ Paris Open Source Summit 2019 (REX SNCF &amp; guests EDF, Enedis, Orange, SogetiLabs, TOSIT) \ud83d\udcfd\ufe0f 30 min / \ud83d\udd33 slides</li> </ul> <ul> <li>Develop a bot on Messenger and Google Assistant in 30 minutes @ Devoxx France 2018 (live coding \"tools in action\") \ud83d\udcfd\ufe0f 30 min</li> </ul>"},{"location":"about/ressources/#meetup-support","title":"Meetup / Support","text":"<ul> <li>Presentation of Tock (with SNCF &amp; Enedis)  @ Innovation Makers Alliance (2021) \u2139\ufe0f info</li> </ul> <ul> <li>Tock - The Open Conversation Kit  @ Meetup Open Transport (2019) \ud83d\udd33 slides</li> </ul> <p>Feel free to share other media and links around Tock.</p>"},{"location":"about/ressources/#press-kit","title":"Press kit","text":"<p>Like the rest of the Tock sources, the logos are available under Apache 2 license.</p> <p>Tock logo - default colors / transparent (download) :</p> <p></p> <p>Tock logo - blue / transparent (download):</p> <p></p> <p>Tock logo - black / transparent (download):</p> <p></p> <p>Tock logo - white / transparent (download):</p> <p></p>"},{"location":"about/showcase/","title":"User showcase","text":"<p>From its creation for OUI.sncf in 2016 to the French  AlloCovid service in 2020, Tock has been used by  more and more teams and organizations to build conversational bots and services for various use cases :</p> <ul> <li>healthcare, transport, energy, e-commerce examples</li> <li>business to customer as well as business to business </li> <li>FAQ and \"0 code\" decision trees</li> <li>assistance, selfcare and live chat compatible</li> <li>text &amp; voice channels: Web &amp; mobile, messaging, smart devices, telephone services</li> </ul> <p>This page presents various assistants and products built and powered by Tock, some of them awarded by the community.</p>"},{"location":"about/showcase/#healthcare","title":"Healthcare","text":""},{"location":"about/showcase/#allocovid","title":"AlloCovid","text":"<p>The AlloCovid conversational service informs and guides French population  about the Covid-19.</p> <p>It results from the collaboration of numerous French experts, tech partners and volunteers. To find out more about the project, the team and partners, how the bot works, etc. visit  www.allocovid.com.</p> <p>Available by phone, on the Web and WhatsApp, AlloCovid builds around a Tock bot and integrates with additional  technologies such as Allo-Media and Voxygen voice solutions. </p> <p>The AlloCovid bot is powered by open source technologies (Tock) and open source itself: its sources are available on  repository <code>allocovid</code>.</p> <p>The source repository also includes the Allo-Media connector,  technical details about the bot and its functional specification.</p> <p></p> <ul> <li>Name: AlloCovid</li> <li>Date of birth: in production since spring 2020</li> <li>Field: health information and guidance</li> <li>Channels: text &amp; voice, by phone, on WhatsApp and Website</li> </ul>"},{"location":"about/showcase/#transport-e-commerce","title":"Transport &amp; e-commerce","text":""},{"location":"about/showcase/#ouibot-the-ouisncf-bot","title":"OUIbot, the OUI.sncf bot","text":"<p>OUIbot is the conversational assistant from OUI.sncf. Available since 2016  on Facebook Messenger, OUIbot was built along with the first versions of Tock.</p> <p>With OUIbot, booking a train ticket has never been easier! It assists you in the preparation of your trips, allows you to make a complete reservation quickly and easily, from research to purchase (payment included), and accompanies you during your trip.</p> <p>Thanks to the numerous connectors, OUIbot is now available on multiple conversational channels, such as the company  Website www.oui.sncf, social networks, voice assistants, smart display and even   SmartBrics with JCDecaux  devices.</p> <p>In 2019, OUIbot answers approximately 10.000 users a day. It has been awarded Best Robot Experience  for the second year in a row.</p> <p></p> <ul> <li>Name: OUIbot</li> <li>Date of birth: in production since 2016</li> <li>Field: e-commerce/travel, transactions (booking, payment), alerts &amp; push notifications, push messages to an agent</li> <li>Channels: text &amp; voice, on the company Website, Messenger, WhatsApp, Business Chat (Messages), Google Assistant,  Google Home, Alexa, JCDecaux SmartBrics</li> </ul>"},{"location":"about/showcase/#lassistant-sncf","title":"L'Assistant SNCF","text":"<p>L' Assistant SNCF is the mobile application for SNCF passengers on Android and iOS, covering both trains and other modes of transport.</p> <p>With L' Assistant (the SNCF Assistant), you can plan your itinerary, stay informed in real time, buy your transport tickets directly or book a taxi ride. More features are yet to come.</p> <p>Accessible via the \"microphone\" in the mobile application, le SNCF Assistant's conversational bot is built with Tock plus the speech-to-text Android and iOS functions.</p> <p></p> <ul> <li>Name: L' Assistant SNCF</li> <li>Date of birth: in production, featuring Tock voice function since 2019</li> <li>Field: travel &amp; transport (multi-modal route research, etc.)</li> <li>Channels: voice, on the SNCF mobile application for Android and iOS</li> </ul>"},{"location":"about/showcase/#tilien-the-transilien-chatbot","title":"Tilien, the Transilien chatbot","text":"<p>Tilien is the Transilien chatbot on Messenger.</p> <p>Designed as a personal and friendly travel companion, it informs you about upcoming departures, the service status, current and future works, itineraries and much more (route plans, timetables, etc.) on the entire Ile-De-France rail network: Metro, RER, Transilien, Tram.</p> <p>Powered by Tock, the chatbot is waiting for you on Facebook Messenger.</p> <p></p> <ul> <li>Name: Tilien</li> <li>Date of birth: in production, since 2018 with Tock</li> <li>Field: transport &amp; assistance (route research, route plans, traffic conditions, etc.)</li> <li>Channels: text, on Messenger (botsncftransilien)</li> </ul>"},{"location":"about/showcase/#mon-assistant-tgv-inoui","title":"Mon Assistant TGV INOUI","text":"<p>Mon Assistant advises customers and travellers of the TGV INOUI brand before, during and after their journey.</p> <p>The chatbot can tell you all about the service status, train departure platforms, customer seats, onboard services (bar, electrical outlets, etc.). It also allows you to talk with a SNCF agents while remaining in the same conversation.</p> <p>Located on the TGV INOUI Facebook page and the WiFi Portal aboard the train, the assistant is based on Tock and the <code>tock-react-kit</code>.</p> <p></p> <ul> <li>Name: Mon Assistant TGV INOUI</li> <li>Date of birth: in production since 2019</li> <li>Field: assistance &amp; passenger information (dock information, current travel information, on-board services),   relay to an agent</li> <li>Channels: text, on Messenger (TGV INOUI) and the   WiFi Portal aboard the train</li> </ul>"},{"location":"about/showcase/#l-agent-virtuel-sncf","title":"L' Agent virtuel SNCF","text":"<p>L' Agent virtuel SNCF (SNCF Virtual Assistant) presents passenger information and any disruptions on all trains (TGV, Intercites, TER, Eurostar, etc.) in a conversational manner.</p> <p>Query the bot by train number, passenger file, next departures, etc. to get the latest information and traffic status.</p> <p>Accessible via the SNCF Facebook page, Twitter and sncf.com, the Agent virtuel leverages Tock and the <code>tock-react-kit</code>.</p> <p></p> <ul> <li>Name: Agent virtuel SNCF</li> <li>Date of birth: in production since 2019</li> <li>Field: travel &amp; transport (traffic situation, works, next departures), relay to an agent</li> <li>Channels: text, on sncf.com   (direct link), Messenger (SNCFOFFICIEL)   and Twitter (@sncf)</li> </ul>"},{"location":"about/showcase/#energy","title":"Energy","text":""},{"location":"about/showcase/#edf-callbot","title":"EDF Callbot","text":"<p>As a POC (Proof Of Concept) to test a use case, a callbot has been created by the Direction des Syst\u00e8mes d'Informations et du Num\u00e9rique (DSIN) of EDF (Electricit\u00e9 de France) Commerce.</p> <p>The callbot is designed to integrate with the contact center solution (Genesys) in order to route customer calls toward the right skill, either human or automated. It also forwards the conversation context between the customer and the callbot to the advisor.</p> <p>The callbot is powered by Tock using the Allo-Media connector. The Speech-To-Text (STT) solution is Allo-Media, and the Text-To-Speech (TTS) is Voxygen.</p> <p></p> <ul> <li>Name: EDF Callbot</li> <li>Date of birth: January 2021</li> <li>Field: Customer Service / Contact Center</li> <li>Channels: voice, by phone</li> </ul>"},{"location":"about/showcase/#enedis-chatbots","title":"Enedis Chatbots","text":"<p>Several Enedis chatbots are built with Tock.</p> <p>The Enedis Client Chatbot gives the 35 millions clients an easy way to get answers about energy,  without the need to contact a customer advisor.</p> <p>The conversational agent provides level-1 client support by answering simple and non-personalized questions  on different subjects such as online account, Linky (the communicating meter), electric connection,  troubleshooting, etc. Also, clients have the possibility to be redirected to a Live Chat and talk with an advisor  in case of misunderstanding from the chatbot.</p> <p>Co-developped with Enedis experts on TOCK solution, this chatbot is available  on the company Website Enedis.fr.</p> <p></p> <ul> <li>Name: Enedis Client Chatbot</li> <li>Date of birth: in production from february 2021</li> <li>Field: all subjects about energy distribution</li> <li>Channels: text, on the company Website Enedis.fr</li> </ul> <p>Also in production since 2020, the Enedis internal Chatbot  for internal logistics services is also built with Tock.</p>"},{"location":"about/showcase/#bank","title":"Bank","text":""},{"location":"about/showcase/#maxbot-bank-bot-for-aumax-pour-moi","title":"MaxBot, bank bot for Aumax pour moi","text":"<p>Aumax pour moi is an application that allows you to gather your cards in one and only place. Your every day is eased by using only one application and an unique card. To support you every day, Aumax allow you to :</p> <ul> <li>earn cashback ;</li> <li>send and receive money ;</li> <li>use a concierge service ;</li> <li>ask for financial advice, plan for life's projects, etc.</li> <li>and so much more !</li> </ul> <p></p> <p>Through the app, the Aumax pour moi's bot, based on Tock, assists you through every question you may have on the app, your accounts or on your card.</p> <p>The bot is available on the Aumax pour moi's app. Aumax pour moi takes care and answers up to 5 000 requests a day.</p> <ul> <li>Name: Aumax pour moi</li> <li>Date of birth: in production since 2019</li> <li>Field: banking, services, personal assistant</li> <li>Channels: text, on the mobile app</li> </ul>"},{"location":"about/showcase/#personal-assistants","title":"Personal Assistants","text":""},{"location":"about/showcase/#linto-by-linagora","title":"LinTO by Linagora","text":"<p>The LinTO platform is an Open Source toolbox designed to address professional and industry needs by enabling the development and integration of voice operated processes.</p> <p>LinTO is a smart Open Source assistant designed by LINAGORA: based only on Open Source technologies, LinTO is cloud enabled but GAFAM-free (Google-Amazon-Facebook-Apple-Microsoft), and respects your privacy as it doesn\u2019t share your data for commercial use.</p> <p>LinTO is designed to reduce time-consuming &amp; stressful tasks, using a smart AI program to understand your voice and help you all along the office day even during meetings: agenda management, reminders, notetaking, e-mails, weather forecast, traffic, words definition, newspaper headlines, etc.</p> <p>The research project, which is funded by the French government's PIA (for \u201cFuture Investment Program\u201d) as part of the Grands D\u00e9fis du Num\u00e9rique, is a collaboration between French companies, LINAGORA and ZELROS, and French research laboratories, IRIT, LaaS and LIX.</p> <p>The LinTO NLU (Natural Language Understanding) system is based on Tock to support the use of several AI models dedicated to specific use cases. It automatically learns according to one's usage when adding or removing skills from the platform.</p> <p></p> <ul> <li>Name: LinTO</li> <li>Date of birth: in production, leveraging Tock since 2019</li> <li>Field: Smart Business Assistant (agenda, e-mails, notetaking, etc.)</li> <li>Channels: voice (portability: Raspberry Pi, ARM, Android, Web...)</li> </ul>"},{"location":"about/showcase/#internal-bots","title":"Internal Bots","text":""},{"location":"about/showcase/#enedis-internal-chatbot","title":"Enedis internal Chatbot","text":"<p>The Enedis internal Chatbot gives the 39 000 employees a simplified means to  access the company logistics services.</p> <p>The conversational agent provides level-1 support by answering frequent employee questions,  as well as guiding them to Business service-desk tools.  It also aims at better understanding employee needs through the analysis of most frequent demands.</p> <p>Built with Tock, the chatbot is available on an internal company Website.</p> <p></p> <ul> <li>Name: Chatbot interne Enedis</li> <li>Date of birth: in production since 2020</li> <li>Field: internal logistics services</li> <li>Channels: text, on an internal Website</li> </ul>"},{"location":"about/showcase/#eve-a-versatile-internal-assistant-sncf","title":"Eve, a versatile internal assistant (SNCF)","text":"<p>Eve is the internal assistant of e.Voyageurs SNCF employees.</p> <p>The chatbot answers common questions, refers to the right interlocutors and collaborative tools of the company,  automates common requests to IT Support, General Services, Legal Department, etc. DevOps teams can also ask it for  production status, next planned operations, or even to manage certain operations directly for greater simplicity  and reactivity.</p> <p>Eve is always listening to the employees, both within the offices and on-the-go using Teams applications with Tock.</p> <ul> <li>Name: Eve</li> <li>Date of birth: in production since 2019</li> <li>Field: internal &amp; B2B support (FAQ, IT Support, HR, Legal), DevOps automation (monitoring,  deployments, production management, etc.)</li> <li>Channels: text &amp; voice, internally within the offices and on-the-go via Teams</li> </ul>"},{"location":"about/showcase/#rocbot-an-ops-assistant-sncf","title":"RocBOT, an Ops assistant (SNCF)","text":"<p>RocBOT is dedicated to Ops teams at SNCF DEA, available at the office and on-the-go through Teams applications.</p> <p>The chabot helps collaborators quickly find information about the applications. RocBOT can check, weither alerts were raised by supervision, find on-call duty agenda or people, etc.</p> <p>RocBOT is available in production since 2020, on Teams desktop and mobile applications through the  Tock Teams connector.</p> <p> </p> <ul> <li>Name: RocBOT</li> <li>Date of birth: in production since 2020</li> <li>Field: internal ops management &amp; support (FAQ, Ops Support, ITSM, etc.)</li> <li>Channels: text &amp; voice, internally within the offices and on-the-go via Teams</li> </ul>"},{"location":"about/showcase/#other","title":"Other","text":""},{"location":"about/showcase/#toki-the-bot-to-discover-tock","title":"Toki, the bot to discover Tock","text":"<p>Toki helps everyone willing to discover and use Tock. It answers frequently asked questions and keeps learning, in particular from the Tock community on Gitter.</p> <p>How to create a first bot? How to install Tock? Where to find the sources or licence?... Do not hesitate to ask Toki. When it doesn't know (yet), try again a few days later ;). Currently Toki speaks only French, but English is coming!</p> <p>The chatbot has been built with \"0 code\", leveraging Tock Studio. As much a demo bot as a tool for the  community, Toki lives on the public demo platform, leverages the Tock-provided Web connector and  React kit to integrate with the Website (with several  lines of HTML/JS/CSS).</p> <p></p> <ul> <li>Name: Toki</li> <li>Date of birth: in production since 2021</li> <li>Field: community support &amp; FAQ</li> <li>Channels: text, on the solution Website</li> </ul>"},{"location":"about/showcase/#what-about-you","title":"What about you?","text":"<p>Various organizations already leverage Tock to build conversational agents, which are not mentionned here  (among them, several of the TOSIT companies).  Sometimes these applications are not dedicated to public usage and their organization will not communicate about them. We will mention them here when it is possible ;)</p> <p>Do not hesitate to look at the Gitter  community chat to see professionals, students, large and smaller companies  currently using or experimenting with Tock for their conversational or NLU projects.</p> <p>As a generic platform, Tock enables numerous use cases and integration of internal as well as external channels. Please feel free to contact us in case of doubts or questions about Tock features or possibilities for a new project  of your own.</p> <p>And don't hesitate to share your achievements with the community! \ud83d\ude42</p>"},{"location":"about/why/","title":"Why Tock?","text":"<p>Created in 2016 by the OUI.sncf Innovation team to implement voice-command on its  mobile applications, the framework has then been used to create the  Messenger chatbot, before being extended to support numerous channels and other bots with more use cases.</p> <p>At first the platform showed results, similar to other available solutions on the market, while keeping the code in  control (relying on opensource libraries and academic solutions) and preventing \"black box\" effects (eg.  debugging conversational models) for more reactive agility.</p> <p>Since then, the team behind OUIbot as well as other teams, dedicated to various conversational assistants at SNCF (see the showcase) use Tock every day in production  and add new features and connectors to the platform on a regular basis.</p> <p>We are convinced there is a need for open AI and conversational platforms, enabling various technical and  business cases while keeping the code in control and the ownership of models and data.</p> <p>More and more partners and third-parties, small and big companies in France and worldwide, share this vision and  requirement for their own projects.</p> <p>The complete Tock solution is shared with the community in order to federate and mutualize efforts from assistant builders. </p> <p>Starting 2019, Tock is a recommended solution at Group SNCF.  Several other companies leverage Tock in production (see showcase).</p> <p>Eventually, we believe that Tock should join an Open Source organization, such as the TOSIT (The Open Source I Trust) association  or an Open Source foundation or consortium.</p>"},{"location":"admin/architecture/","title":"Architecture","text":""},{"location":"admin/architecture/#tock-architecture","title":"Tock Architecture","text":"<p>This chapter presents the general architecture of a Tock platform: components and dependencies, flows, proxy configuration, etc.</p>"},{"location":"admin/architecture/#functional-architecture","title":"Functional Architecture","text":"<p>Two major components are available:</p> <ul> <li>the NLU engine: Natural Language Understanding (see Tock Studio)</li> <li>the conversational framework integrated into NLU services and various connectors such as Messenger, Google Assistant or Slack (see developer manual and connectors).</li> </ul> <p></p> <p>The NLU platform is independent of the conversational part. It is possible to use the NLU without having to master the complexity induced by conversation management. In some important use cases, such as the Internet of Things, using an NLU model alone is relevant.</p>"},{"location":"admin/architecture/#technical-architecture","title":"Technical architecture","text":"<p>Tock is composed of several application components (containers when using Docker) and a MongoDB database.</p> <p>The Docker and Docker Compose descriptors provided (ie. the <code>Dockerfile</code> and <code>docker-compose.yml</code>) describe the architecture of Tock.</p> <p>A complete example can be found in the file <code>docker-compose-bot-open-data.yml</code> available in the repository <code>tock-docker</code>.</p>"},{"location":"admin/architecture/#mongodb-database","title":"MongoDB database","text":"<p>The Mongo database must be configured in replica set, i.e. with at least 3 instances deployed. This is mandatory because Tock uses the Change Streams functionality which has as a prerequisite the installation in replica set.</p> <p>This is also a good practice to ensure high availability of the database.</p>"},{"location":"admin/architecture/#application-components","title":"Application components","text":"<p>Here is a quick description of the different application components (and Docker images provided with Tock):</p> <ul> <li>Tock Studio interfaces and tools:</li> <li> <p><code>tock/bot_admin</code>: Tock Studio</p> </li> <li> <p>NLU part:</p> </li> <li><code>tock/build_worker</code>: rebuilds models automatically whenever needed</li> <li><code>tock/duckling</code>: parses dates and primitive types using Duckling</li> <li> <p><code>tock/nlp_api</code> : parses sentences based on models built in Tock Studio</p> </li> <li> <p>Conversational part:</p> </li> <li><code>tock/bot_api</code>: API to develop bots (Tock Bot API mode)</li> <li><code>tock/kotlin_compiler</code> (optional): script compiler to enter them directly in the Stories and Answers interface of Tock Studio</li> </ul> <p>A final component, the bot itself, must be added and made accessible to partners and external channels with which we wish to integrate.</p> <p>Of course the implementation of the bot is not provided with Tock (everyone implements their own functionalities for their needs) but an example is available in <code>docker-compose-bot-open-data.yml</code>.</p>"},{"location":"admin/architecture/#deployment-modes","title":"Deployment modes","text":"<ul> <li>The NLU platform mode alone (without conversational part):</li> </ul> <ul> <li>The Tock Bot API mode (recommended for most cases), allowing to develop in Kotlin or another language through the Tock conversational API:</li> </ul> <ul> <li>The Tock Bot integrated mode (historical) allowing to develop in Kotlin only using all the possibilities of Tock but accessing the MongoDB database directly from the bot:</li> </ul>"},{"location":"admin/architecture/#see-also","title":"See also...","text":"<ul> <li>Installation</li> <li>Security</li> <li>Supervision</li> <li>Cloud</li> <li>High availability</li> </ul>"},{"location":"admin/availability/","title":"High Availability","text":""},{"location":"admin/availability/#high-availability","title":"High Availability","text":"<p>This page is intended to provide advice and feedback on the high availability (or HA - High Availability) configurations of Tock bots and platforms.</p> <p>Coming soon: more details on how to achieve high availability on the different Tock components, and feedback on our use in production for several years (see showcase / users).</p>"},{"location":"admin/availability/#redundancy-and-resilience","title":"Redundancy and resilience","text":"<p>A single instance of <code>tock/build_worker</code> must exist.</p> <p>It is recommended to use a single instance of <code>tock/bot_admin</code> and <code>tock/kotlin_compiler</code>.</p> <p>For other components, especially the bot component (not provided) but also <code>tock/nlp_api</code> and <code>tock/duckling</code>, it is recommended to deploy multiple instances to ensure better availability or even better performance.</p>"},{"location":"admin/availability/#performance","title":"Performance","text":"<p>As indicated in the installation section, the first parameter to monitor is available memory.</p> <p>At high load - we have experienced more than 80 req/s on our own bots - the limiting factor becomes the MongoDB database, which must then be resized accordingly when the need arises.</p>"},{"location":"admin/cloud/","title":"Cloud","text":""},{"location":"admin/cloud/#cloud","title":"Cloud","text":"<p>This page presents the aspects related to the use of Cloud services (private or public) to deploy and host Tock platforms and bots.</p> <p>Indeed, we have experience of using Tock in production on classic on-premise and bare metal hosting, but also on private Clouds like OpenStack or public Clouds like AWS.</p> <p>Coming soon: details, examples and feedback on the use of Tock on Cloud type hosting. We even hope to be able to share with the code community: infra as code, dashboards, etc.</p>"},{"location":"admin/installation/","title":"Installation","text":""},{"location":"admin/installation/#tock-installation","title":"Tock Installation","text":"<p>The architecture page presents the Tock functional and technical architecture, the role of the different components as well as the different deployment modes.</p> <p>This chapter presents the different Tock installation options. In particular, it is about discussing the case of a production installation as well as sharing some feedback on performance, resilience, Tock's ability to scale, Cloud type deployments, monitoring, etc.</p> <p>If you are only looking to test Tock with non-sensitive data, you may prefer to use the Tock demo platform.</p>"},{"location":"admin/installation/#installation-with-docker","title":"Installation with Docker","text":"<p>The <code>tock-docker</code> repository provides a complete implementation of Tock for the Docker and Docker Compose technologies.</p> <p>Tock is composed by default of several Docker containers/images and a MongoDB database.</p> <p>For more information on installing Tock with Docker, see the instructions in the <code>tock-docker</code> repository.</p> <p>The deploy Tock with Docker guide in the Discover Tock section gives an example of deploying a complete platform in a few minutes with a minimal footprint using Docker and Docker Compose. However, this method is not feasible for a long-term deployment such as a production platform.</p> <p>If you want to use Docker Compose in production, please read this article and review the configuration, which is only given in the <code>tock-docker</code> project as an example. In particular, the configuration of MongoDB instances should be reviewed carefully.</p>"},{"location":"admin/installation/#installation-without-docker","title":"Installation without Docker","text":"<p>It is entirely possible to install Tock without using Docker. By analyzing the descriptors provided in <code>tock-docker</code> (ie. the <code>pom.xml</code> files, the <code>Dockerfile</code> and <code>docker-compose.yml</code>) one can easily design an installation without Docker.</p> <p>Except for the MongoDB database, all other components can be started like classic Java/JVM applications, for example:</p> <ul> <li>directly from the command line</li> <li>within a Java application server</li> <li>from an integrated development tool (IDE)</li> <li>etc.</li> </ul> <p>To learn more about the launch parameters of the different Tock components, you can take inspiration from the commands present in the <code>tock-docker</code> descriptors or from the configurations provided for IntelliJ (see below).</p>"},{"location":"admin/installation/#command-line","title":"Command line","text":"<p>One technique is to gather the different dependencies and JAR archives in a folder and then start the component or application with a classic Java command.</p> <p>For example, the component descriptor <code>tock-docker-nlp-api</code> (see <code>pom.xml</code>) with the following command:</p> <pre><code>java $JAVA_ARGS -Dfile.encoding=UTF-8 -cp '/maven/*' ai.tock.nlp.api.StartNlpServiceKt\n</code></pre>"},{"location":"admin/installation/#executable-jar","title":"Executable JAR","text":"<p>This is not the technique we recommend, but it is possible to run a single JAR containing all dependencies (sometimes called \"fat JAR\"). Here is how to create such a JAR, using the example of the Tock NLP-API component.</p> <p>In the component POM (<code>nlp/api/service/pom.xml</code>), add the following declaration:</p> <pre><code>    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;phase&gt;package&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;single&lt;/goal&gt;\n                        &lt;/goals&gt;\n                        &lt;configuration&gt;\n                            &lt;archive&gt;\n                                &lt;manifest&gt;\n                                    &lt;mainClass&gt;ai.tock.nlp.api.StartNlpServiceKt&lt;/mainClass&gt;\n                                &lt;/manifest&gt;\n                            &lt;/archive&gt;\n                            &lt;descriptors&gt;\n                                &lt;descriptor&gt;src/main/assembly/jar-with-dependencies.xml&lt;/descriptor&gt;\n                            &lt;/descriptors&gt;\n                        &lt;/configuration&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n</code></pre> <p>Also create an archive descriptor <code>nlp/api/service/src/main/assembly/jar-with-dependencies.xml</code> with the following content:</p> <pre><code>&lt;assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.0.0\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\"&gt;\n    &lt;id&gt;jar-with-dependencies&lt;/id&gt;\n    &lt;formats&gt;\n        &lt;format&gt;jar&lt;/format&gt;\n    &lt;/formats&gt;\n    &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;\n    &lt;dependencySets&gt;\n        &lt;dependencySet&gt;\n            &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;\n            &lt;useProjectArtifact&gt;true&lt;/useProjectArtifact&gt;\n            &lt;unpack&gt;true&lt;/unpack&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;/dependencySet&gt;\n    &lt;/dependencySets&gt;\n    &lt;containerDescriptorHandlers&gt;\n        &lt;containerDescriptorHandler&gt;\n            &lt;!-- Merge service implementations from dependencies --&gt;\n            &lt;handlerName&gt;metaInf-services&lt;/handlerName&gt;\n        &lt;/containerDescriptorHandler&gt;\n    &lt;/containerDescriptorHandlers&gt;\n&lt;/assembly&gt;\n</code></pre> <p>Finally, build the \"jar-with-dependencies\" archive with <code>mvn package</code>.</p>"},{"location":"admin/installation/#in-an-ide","title":"In an IDE","text":"<p>For development, it is possible to run the different Tock components (NLU, Studio, bot...) from an IDE like IntelliJ, Eclipse or Visual Studio Code for example.</p> <p>In addition to the Docker images, configurations for IntelliJ are provided with the Tock sources:</p> <ul> <li>Configuration Full Tock Studio services (Bot + NLP) / <code>BotAdmin</code></li> <li>Configuration Tock Studio services (NLP only) / <code>Admin</code></li> <li>Configuration NLP service / <code>NlpService</code></li> <li>Configuration Entity Service / <code>Duckling</code></li> <li>Configuration NLP model construction service / <code>BuildWorker</code></li> <li>Configuration Script compilation service / <code>KotlinCompilerServer</code></li> </ul> <p>Finally, to launch the user interfaces (Tock Studio), the commands are described in the following link:</p> <ul> <li>Instructions Full Tock Studio interface (Bot + NLP)</li> </ul>"},{"location":"admin/installation/#mongodb-database","title":"MongoDB database","text":""},{"location":"admin/installation/#replica-set-architecture","title":"replica set architecture","text":"<p>The MongoDB database must be configured in replica set, because Tock takes advantage of change streams.</p> <p>This implies that at least 3 nodes must be deployed, which improves resilience.</p> <p>Different scenarios are possible for the database:</p> <ul> <li>Install MongoDB nodes on one or more servers (classic method)</li> <li>Instantiate MongoDB nodes with Docker (for testing or local development)</li> <li>Use a MongoDB cloud service in SaaS (Software-as-a-Service), for example MongoDB Atlas available on AWS, Azure and GCP</li> </ul> <p>A replica set installation tutorial is available on the MongoDB website.</p>"},{"location":"admin/installation/#data-retention","title":"Data retention","text":"<p>Tock stores different types of data in its database and applies TTL (Time To Live), so that some expire and are purged automatically after a certain time.</p> <p>In practice, environment variables and the application of TTL occur when the DAO (Data Access Object) components are initialized, when Tock starts.</p> <p>Tock's TTL have a default value and are configurable using environment variables. Some concern a specific Tock component, others must be defined on several components.</p> <p>Since Tock can be used as a complete conversational platform or only the NLU/NLP part, we indicate the variables specific to conversational (denoted Bot) or usable on all types of platforms (denoted *).</p> Platform(s) Environment variable Default value Description Affected component(s) * <code>tock_nlp_classified_sentences_index_ttl_days</code> <code>-1</code> (no expiration) Unvalidated sentences (Inbox). <code>nlp_api</code>, <code>nlp_admin</code>/<code>bot_admin</code>, <code>worker</code> * <code>tock_nlp_classified_sentences_index_ttl_intent_names</code> Empty (all intents) Unvalidated sentences (Inbox) &gt;&gt; restriction to certain intents, separated by commas.(Example below). <code>nlp_api</code> * <code>tock_nlp_log_index_ttl_days</code> <code>7</code> NLP logs: sentence, intents, scores, entity details, etc. <code>nlp_api</code> * <code>tock_nlp_log_stats_index_ttl_days</code> <code>365</code> NLP statistics: number of occurrences of a sentence, scores, etc. <code>nlp_api</code> * <code>tock_user_log_index_ttl_days</code> <code>365</code> Log of actions in Tock Studio: Stories changes, etc. <code>nlp_admin</code>/<code>bot_admin</code> Bot <code>tock_bot_alternative_index_ttl_hours</code> <code>1</code> Index on label alternatives (Answers). <code>bot</code>/<code>bot_api</code> Bot <code>tock_bot_dialog_index_ttl_days</code> <code>7</code> Conversations (Analytics &gt; Users/Search). <code>bot</code>/<code>bot_api</code>, <code>nlp_admin</code>/<code>bot_admin</code> Bot <code>tock_bot_dialog_max_validity_in_seconds</code> <code>60 * 60 * 24</code> (24h) Conversation contexts (current intention, entities on the bus, etc.). <code>bot</code>/<code>bot_api</code>, <code>nlp_admin</code>/<code>bot_admin</code> Bot <code>tock_bot_flow_stats_index_ttl_days</code> <code>365</code> Browsing statistics (Analytics &gt; Activity/Behavior). <code>bot</code>/<code>bot_api</code>, <code>nlp_admin</code>/<code>bot_admin</code> Bot <code>tock_bot_timeline_index_ttl_days</code> <code>365</code> User profiles/history: preferences, locale, last login, etc. (excluding conversation details) <code>bot</code>/<code>bot_api</code>, <code>nlp_admin</code>/<code>bot_admin</code> <p>Depending on the deployment mode used, these environment variables can be added either directly on the command line, or in a descriptor such as <code>docker-compose.yml</code>, <code>dockerrun.aws.json</code> or other (example below).</p> <p>It is possible to automatically remove unvalidated sentences (Inbox) for certain intents only, thanks to <code>tock_nlp_classified_sentences_index_ttl_intent_names</code> :</p> <ul> <li>{: data-hl-lines=\"6 7\"} docker-compose.yml</li> </ul> <pre><code>version: \"3\"\nservices:\n  admin_web:\n    image: tock/bot_admin:$TAG\n    environment:\n      - tock_nlp_classified_sentences_index_ttl_days=10\n      - tock_nlp_classified_sentences_index_ttl_intent_names=greetings,unknown\n</code></pre> <ul> <li>{: data-hl-lines=\"8 9\"} dockerrun.aws.json</li> </ul> <pre><code>{\n  \"AWSEBDockerrunVersion\": 2,\n  \"containerDefinitions\": [\n    {\n      \"name\": \"admin_web\",\n      \"image\": \"tock/bot_admin:${TAG}\",\n      \"environment\": [\n        {\n          \"name\": \"tock_nlp_classified_sentences_index_ttl_days\",\n          \"value\": \"10\"\n        },\n        {\n          \"name\": \"tock_nlp_classified_sentences_index_ttl_intent_names\",\n          \"value\": \"greetings,unknown\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <p>{: .tabbed-code}</p> <p>In this example, only sentences detected as <code>greetings</code> or <code>unknown</code> intents (but not validated) will be deleted after <code>10</code> days; other sentences will not be deleted.</p> <p>Only sentences validated by a user in Tock Studio, integrating the bot's NLP model, never expire by default (even if it is still possible to delete them from the model via the Search &gt; Status: Included in model view): it is therefore important not to validate sentences containing personal data for example.</p> <p>Data retention, encryption and anonymization are essential to protect data, especially if it is personal. For more information, see the Security &gt; Data section.</p>"},{"location":"admin/installation/#application-components","title":"Application Components","text":"<p>Depending on Tock's application components, whether mandatory or optional, some must be single-instance and others can be deployed in multiple instances (see the high availability section for more information).</p> <p>For convenience, the components below are named after the Docker images provided with Tock, although using Docker is not required to install Tock.</p>"},{"location":"admin/installation/#network-exposure","title":"Network Exposure","text":"<p>By default, the components or containers of the Tock platform must not be exposed outside the VPN or VPC. Only the bot itself must be accessible to the partners and external channels with which we want to integrate, for the functioning of the WebHooks.</p> Component / Image Network exposure Description <code>tock/bot_admin</code> VPN / VPC only Interfaces and tools Tock Studio <code>tock/build_worker</code> VPN / VPC only Automatically rebuilds models whenever needed <code>tock/duckling</code> VPN / VPC only Parses dates and primitive types using Duckling <code>tock/nlp_api</code> VPN / VPC only Parses sentences from models built in Tock Studio <code>tock/bot_api</code> VPN / VPC only API for developing bots (Tock Bot API mode) <code>tock/kotlin_compiler</code> VPN / VPC only (Optional) Script compiler to enter them directly in the Build interface of Tock Studio bot (not provided) Internet / partners The bot itself, implementing the programmatic journeys, accessible to external partners/channels via WebHooks <p>Of course, the implementation of the bot itself is not provided with Tock (everyone implements their own features for their needs).</p>"},{"location":"admin/installation/#http-proxies","title":"HTTP Proxies","text":"<p>The Java System Properties <code>https.proxyHost</code>, <code>http.proxyHost</code>, and <code>http.nonProxyHosts</code> are the recommended way to configure a proxy.</p>"},{"location":"admin/installation/#bot-packaging","title":"Bot Packaging","text":"<p>A sample bot in Tock Bot Embedded mode is available in <code>docker-compose-bot-open-data.yml</code>.</p> <p>Examples and guidelines for packaging bots in Tock Bot API mode (WebHooks, WebSockets) will be available soon.</p>"},{"location":"admin/installation/#minimum-configurations","title":"Minimum configurations","text":"<p>Tock architecture is composed of several components that can be deployed together on the same server, or distributed across multiple machines/instances.</p> <p>The main parameter to monitor is the available RAM.</p>"},{"location":"admin/installation/#model-building","title":"Model building","text":"<p>The larger your models, the more memory is needed to rebuild the models (<code>tock/build_worker</code> component).</p> <p>To give an order of magnitude, a model of 50,000 sentences with several intents, comprising about twenty entities, will require provisioning about 8 GB of RAM for the <code>tock/build_worker</code> component.</p> <p>However, large models with few entities can easily run with only 1 GB of RAM.</p>"},{"location":"admin/installation/#jvm-docker-memory","title":"JVM &amp; Docker Memory","text":"<p>To ensure that Docker containers/instances do not exceed the available memory, it is recommended to limit the memory of JVMs by following the following example:</p> <pre><code>JAVA_ARGS=-Xmx1g -XX:MaxMetaspaceSize=256m\n</code></pre>"},{"location":"admin/installation/#machine-optimization","title":"Machine optimization","text":"<p>It is possible to optimize deployments and infrastructures by taking into account different elements such as:</p> <ul> <li>the needs of the respective components in machine resources: CPU, memory, disk</li> <li>the interest of having one or more instances of each component according to its role</li> <li>the constraints/objectives of resilience and high availability</li> <li>the cost models, particularly among public cloud providers</li> </ul>"},{"location":"admin/installation/#examples","title":"Examples","text":"<p>For information, here are some examples of configurations currently in production. These are the \"application\" components of the Tock architecture without the MongoDB database.</p> <p>EC2 instance types are for reference only. Tock has no dependencies on AWS. For more information, see the AWS documentation.</p>"},{"location":"admin/installation/#limited-size-models","title":"Limited Size Models","text":"Tock Components Number of Instances Number of CPUs or vCPUs RAM Example EC2 Instance Type <code>admin-web</code> + <code>build-worker</code> + <code>kotlin-compiler</code> + <code>duckling</code> 1 2 4 GB <code>t3a.medium</code> (general purpose) <code>bot</code> + <code>nlp-api</code> + <code>duckling</code> 3 2 4 GB <code>t3a.medium</code> (general purpose)"},{"location":"admin/installation/#large-models","title":"Large Models","text":"Tock Components Number of Instances Number of CPUs or vCPUs RAM Example EC2 Instance Type <code>admin-web</code> + <code>build-worker</code> + <code>kotlin-compiler</code> + <code>duckling</code> 1 2 16 GB <code>r5a.large</code> (memory optimized) <code>bot</code> + <code>nlp-api</code> + <code>duckling</code> 3 2 4 GB <code>t3a.medium</code> (general purpose)"},{"location":"admin/installation/#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"admin/installation/#making-the-administration-interface-available-in-a-subdirectory","title":"Making the administration interface available in a subdirectory","text":"<p>By default, the administration interface is served at the root (Example: <code>https://[domain host]</code>) If you want to make it available on a relative path (<code>https://[domain host]/tock</code>), use in the configuration of the docker image <code>tock/bot_admin</code> the environment variable <code>botadminverticle_base_href</code>.</p> <p>For example: <code>botadminverticle_base_href=tock</code></p> <p>For <code>tock/nlp_admin</code>, you must use the property <code>adminverticle_base_href</code>.</p>"},{"location":"admin/installation/#see-also","title":"See also...","text":"<p>For a production use of Tock, we recommend you to also browse the following pages:</p> <ul> <li>Security</li> <li>Monitoring</li> <li>Cloud</li> <li>High availability</li> </ul>"},{"location":"admin/security/","title":"Security","text":""},{"location":"admin/security/#security","title":"Security","text":""},{"location":"admin/security/#users-tock-studio","title":"Users Tock Studio","text":""},{"location":"admin/security/#authentication","title":"Authentication","text":"<p>Tock supports several authentication systems for the administration interface. It uses the corresponding vert.x libraries.</p> <p>Here are the systems available by default (all implementations of <code>TockAuthProvider</code>):</p> <ul> <li> <p>One model per \"properties\", used by default. The code is available in the <code>PropertyBasedAuthProvider</code> class</p> </li> <li> <p>A generic OAuth2 model.</p> </li> <li> <p>A OAuth2 model adapted to <code>Keycloak</code>.</p> </li> <li> <p>A OAuth2 model specific to Github, an example of which is given by <code>GithubOAuthProvider</code></p> </li> </ul> <p>It is also possible to integrate CAS authentication (SSO), in the case of an enterprise-type installation. This model requires inheriting from a base model, but allows you to match a user profile according to your own constraints and specificities.</p> <p>Details and configuration examples are given further down this page.</p> <p>If these models do not fit your needs, it is relatively easy to develop others based on the examples above. Feel free to contribute to the project and contact us for any questions!</p>"},{"location":"admin/security/#roles","title":"Roles","text":"<p>Tock allows you to assign several roles or authorization levels to users in the Tock Studio interfaces.</p> <p>Depending on the authentication system used (by properties, 0Auth, etc.) each user is assigned one or more of these roles, giving them different accesses in the application.</p> <p>The available roles are defined in the <code>TockUserRole</code> enum:</p> Role Description <code>nlpUser</code> NLP platform user, allowed to qualify and search sentences. ~~<code>faqNlpUser</code>~~ ~~FAQ NLP platform user, allowed to qualify and search sentences.~~ (Deprecated: Use the 'nlpUser' role instead) ~~<code>faqBotUser</code>~~ ~~A faq bot user is allowed to manage the FAQ content, and train the FAQ~~ (Deprecated: Use the 'botUser' role instead) <code>botUser</code> Bot platform user, allowed to create and modify stories, rules and answers. <code>admin</code> Allowed to update applications and configurations/connectors, import/export intents, sentences, stories, etc. <code>technicalAdmin</code> Allowed to access encrypted data, import/export application dumps, etc. <p>How to configure which Tock Studio user has which role depends on the authentication mode, in other words the implementation of <code>TockAuthProvider</code> used.</p>"},{"location":"admin/security/#implementation-by-properties","title":"Implementation by properties","text":"<p>The configuration by \"properties\" is used by default. It does not depend on any third-party system to work.</p> <p>This mode consists of configuring users and roles by properties or environment variables.</p> <p>Depending on the deployment mode used, these variables can be defined either directly on the command line, or in a descriptor such as <code>docker-compose.yml</code>, <code>dockerrun.aws.json</code> or other.</p> <p>If no variable is defined (for example in the descriptors provided in the repository <code>tock-docker</code>), default values \u200b\u200bare used.</p> <p>Here are the properties and their default values:</p> Environment Variable Default Value Description <code>tock_users</code> <code>admin@app.com</code> Identifiers (comma-separated). <code>tock_passwords</code> <code>password</code> Passwords (comma-separated). <code>tock_organizations</code> <code>app</code> Organizations (comma-separated). <code>tock_roles</code> Empty (i.e., all roles) Roles separated by <code>|</code> (then by commas). <p>To define the identity and roles of several users, separate the values \u200b\u200bby commas.</p> <p>Warning: each of these properties must have the same number of values \u200b\u200b(and in the same order) to allow correlation of these values \u200b\u200b(index by index, for each user)</p> <p>Below is an example in Docker-Compose format:</p> <pre><code>{ \"name\" : \"tock_users\", \"value\" : \"alice@tock.ai,bob@tock.ai\" },\n{ \"name\" : \"tock_passwords\", \"value\" : \"secret1,secret2\" },\n{ \"name\" : \"tock_organizations\", \"value\" : \"tock,tock\" },\n{ \"name\" : \"tock_roles\", \"value\" : \"botUser,nlpUser|botUser|admin|technicalAdmin\" },\n</code></pre> <p>In this example, Alice has the <code>botUser</code> role, while Bob has all the roles.</p> <p>For more information on how this implementation works, see the class <code>PropertyBasedAuthProvider</code>.</p>"},{"location":"admin/security/#generic-0auth2-implementation","title":"Generic 0Auth2 Implementation","text":"<p>This generic implementation is to be used whenever you want to set up an OAuth2 configuration.</p> <p>Here are the properties and their default values:</p> Environment Variable Example Value Description Example <code>tock_oauth2_enabled</code> <code>true</code> Enable OAuth2 authentication <code>tock_oauth2_client_id</code> <code>CLIENT_ID</code> Client ID to query the GitHub API <code>tock_oauth2_secret_key</code> <code>SECRET_KEY</code> Password to query the GitHub API <code>tock_oauth2_site_url</code> <code>https://provider</code> OAuth2 provider URL <code>tock_oauth2_access_token_path</code> <code>/oauth2/token</code> Relative path to retrieve the access token <code>tock_oauth2_authorize_path</code> <code>/oauth2/authorize</code> Relative path to retrieve the authorization <code>tock_oauth2_userinfo_path</code> <code>/oauth2/userInfo</code> Relative path to retrieve user information <code>tock_oauth2_proxy_host</code> Proxy host (leave blank if no proxy is used) <code>tock_oauth2_proxy_port</code> Optional proxy port <code>tock_oauth2_user_role_attribute</code> <code>custom:roles</code> Attribute read from the token for role mapping <code>tock_custom_roles_mapping</code> Link between OAuth profiles and Tock roles <code>tock_custom_namespace_mapping</code> Link between OAuth profiles and Tock namespaces <code>id1=sncf|id2=sncf</code> <code>tock_bot_admin_rest_default_base_url</code> <code>http://localhost:8080</code> Redirect to Tock Studio URL if necessary <p>It is necessary to indicate in callback url <code>https://[host admin]/rest/callback</code>.</p>"},{"location":"admin/security/#0auth2-implementation-for-keycloak","title":"0Auth2 implementation for Keycloak","text":"<p>This OAuth2 Keycloak implementation is to be used as soon as you want to configure an OAuth2 configuration with Keycloak.</p> <p>Here are the properties and their proposed values:</p> <p>Warning, by default, no adapter is activated, it is imperative to set the tock_keycloak_enabled key corresponding to our adapter to true.</p> Environment variable Example value Description <code>tock_keycloak_enabled</code> <code>true</code> Enabling 0Auth2 authentication <code>tock_keycloak_client_id</code> <code>CLIENT_ID</code> Client id created on Keycloak <code>tock_keycloak_secret_key</code> <code>SECRET_KEY</code> Secret key generated by Keycloak <code>tock_keycloak_site_url</code> <code>https://keycloak/realms/myrealm</code> Keycloak Realm Url <code>tock_keycloak_access_token_path</code> <code>/protocol/openid-connect/token</code> Relative path to retrieve the access token <code>tock_keycloak_authorize_path</code> <code>/protocol/openid-connect/auth</code> Relative path for the authorize <code>tock_keycloak_userinfo_path</code> <code>/protocol/openid-connect/userinfo</code> Relative path for the userinfo <code>tock_keycloak_proxy_host</code> proxy host (do not specify if no proxy) <code>tock_keycloak_proxy_port</code> optional proxy port <code>tock_custom_namespace_mapping</code> <code>tock_namespace</code> Attribute read in the token for the namespace <code>tock_keycloak_user_role_attribute</code> <code>tock_roles</code> Attribute read in the token for the roles <p>It is necessary to indicate in callback url <code>https://[host admin]/rest/callback</code>.</p> <p>A basic configuration requires to define tock_keycloak_client_id and tock_keycloak_secret_key with the corresponding values \u200b\u200bon Keycloak.</p> <p>It is also necessary to pass the address of the keycloak Realm via tock_keycloak_site_url.</p> <p>It is however not necessary to define tock_keycloak_access_token_path, tock_keycloak_authorize_path and tock_keycloak_userinfo_path since the default values \u200b\u200bare suitable for Keycloak if the realm address is specified correctly.</p> <p>If tock_custom_namespace_mapping is not set or the attribute is not found, the default \"app\" namespace is used.</p>"},{"location":"admin/security/#0authgithub-implementation","title":"0Auth/GitHub Implementation","text":"<p>This rather simplistic implementation is used as an example, as well as for the public demo platform https://demo.tock.ai.</p> <p>It consists of querying the GitHub API to verify the identity of a user from their token (<code>access_token</code>).</p> <p>Note: no other data in the GitHub profile is accessed by Tock, apart from the identifier.</p> <p>In this mode, enabled by the <code>tock_github_oauth_enabled</code> property, each user automatically receives all Tock Studio roles and an organization (ie. namespace) with the same name as their identifier.</p> <p>Here are the properties and their default values:</p> Environment Variable Default Value Description <code>tock_github_oauth_enabled</code> <code>false</code> Enable OAuth/GitHub authentication. <code>tock_github_oauth_client_id</code> <code>CLIENT_ID</code> Identifier to query the GitHub API. <code>tock_github_oauth_secret_key</code> <code>SECRET_KEY</code> Password to query the GitHub API. <code>tock_github_api_request_timeout_ms</code> <code>5000</code> Identity verification timeout (GitHub API). <p>For more information on how this implementation works, see the class <code>GithubOAuthProvider</code>.</p>"},{"location":"admin/security/#ssocas-implementation","title":"SSO/CAS Implementation","text":"<p>This implementation is intended to serve as a bridge between an enterprise environment and Tock. It is therefore partly specific to each enterprise, insofar as it is necessary to map a user profile to Tock groups and roles.</p> <p>It is composed of:</p> <ul> <li>An implementation of the CAS authentication mechanism integrated into Tock ( based on 'PAC4J' )</li> <li>Your externalized module which will inherit this implementation, with a (re)definition of roles/groups according to the user profile</li> </ul> <p>CAS authentication is enterprise specific and requires the development of a dedicated external module for tock</p> <p>CAS module example: 'samples/tock-sample-cas-auth-provider'</p> <p>Here are the properties and their default values:</p> Environment variable Default value Description <code>tock_cas_auth_enabled</code> <code>false</code> Enable PAC4J/CAS authentication. <code>tock_cas_auth_proxy_host</code> <code>127.0.0.1</code> Proxy host (do not specify if no proxy) <code>tock_cas_auth_proxy_port</code> <code>3128</code> Optional proxy port <code>tock_cas_join_same_namespace_per_user</code> <code>true</code> When creating the user, if the namespace already exists and other users are already present, the new user joins the same existing namespace <p>For more information on how this implementation works, see the class <code>CASAuthProvider</code>.</p> <p>Additional note:</p> <p>When authentication is of type SSO the Logout button is not available</p>"},{"location":"admin/security/#data","title":"Data","text":"<p>Since users can transmit personal data to bots through their conversations, it is important to think about the nature of the data handled in Tock Studio or stored by Tock, and to implement appropriate protection mechanisms (anonymization, encryption, retention period, role-based access restrictions, etc.).</p> <p>See in particular the GDPR regulation.</p>"},{"location":"admin/security/#data-encryption","title":"Data encryption","text":""},{"location":"admin/security/#database-encryption","title":"Database encryption","text":"<p>It is recommended to deploy your MongoDB databases in encrypted_ mode.</p>"},{"location":"admin/security/#application-encryption","title":"Application encryption","text":"<p>Tock can perform an application encryption (optional) of some fields in the database, independently of the encryption of the database itself.</p> <p>This is the role of the environment variable <code>tock_encrypt_pass</code>, which allows to indicate a password to encrypt and decrypt these fields. By default in the <code>prod</code> environment, Tock encrypts all user data deemed sensitive provided that <code>tock_encrypt_pass</code> is defined.</p> <p>For more details, you can refer to the source code.</p> <p>Note: defining <code>tock_encrypt_pass</code> is required to use the NLP entity anonymization functions in the Tock Studio interfaces.</p>"},{"location":"admin/security/#anonymization","title":"Anonymization","text":"<p>It is often desirable that certain sentences be anonymized whether in the logs (logging) or in the interface (Tock Studio). For example, contact details, loyalty card numbers, etc. should not be read by Tock Studio users or by platform administrators.</p>"},{"location":"admin/security/#by-the-framework","title":"By the framework","text":"<p>To anonymize this data, Tock provides in its framework a solution based on regular expressions (RegExp) whose basic interface is <code>StringObfuscator</code>.</p>"},{"location":"admin/security/#by-the-nlp-model","title":"By the NLP model","text":"<p>Tock also allows to anonymize in Tock Studio (Inbox view in particular.) the values \u200b\u200bof the entities recognized by the NLP model.</p> <p>This anonymization by entity type is configured in the Language Understanding &gt; Entities view. Only users with an <code>admin</code> or <code>technicalAdmin</code> role in Tock Studio can enable/disable this feature.</p> <p>For more information, see Roles.</p> <p>In views where sentences are displayed anonymized (Inbox, Search for example), an <code>admin</code> or <code>technicalAdmin</code> can decide to still display (for himself only) a non-anonymized sentence using the Reveal the sentence (eye open) action.</p> <p>Note: Setting <code>tock_encrypt_pass</code> is required to use NLP entity anonymization functions in Tock Studio interfaces.</p>"},{"location":"admin/security/#anonymization_1","title":"Anonymization","text":"<p>It is often desirable that certain sentences be anonymized whether in the logs (logging) or in the interface (Tock Studio). For example, contact details, loyalty card numbers, etc. should not be read by either Tock Studio users or platform administrators.</p>"},{"location":"admin/security/#by-the-framework_1","title":"By the framework","text":"<p>To anonymize this data, Tock provides in its framework a solution based on regular expressions (RegExp) whose basic interface is <code>StringObfuscator</code>.</p>"},{"location":"admin/security/#by-the-nlp-model_1","title":"By the NLP model","text":"<p>Tock also allows to anonymize in Tock Studio (Inbox view in particular.) the values \u200b\u200bof the entities recognized by the NLP model.</p> <p>This anonymization by entity types is configured in the Language Understanding &gt; Entities view. Only users with an <code>admin</code> or <code>technicalAdmin</code> role in Tock Studio can enable/disable this feature.</p> <p>For more information, see Roles.</p> <p>In the views where the sentences are displayed anonymized (Inbox, Search for example), an <code>admin</code> or <code>technicalAdmin</code> can decide to still display (for himself only) a non-anonymized sentence thanks to the Reveal the sentence action (open eye).</p> <p>Note: Setting <code>tock_encrypt_pass</code> is required to use NLP entity anonymization features in Tock Studio interfaces.</p>"},{"location":"admin/security/#storage-retention","title":"Storage &amp; Retention","text":"<p>Tock automatically stores different types of data, ranging from non-sensitive information (Stories configuration and bot responses, intent structure, browsing statistics for all users, etc.) to more personal data (conversation details, user preferences, etc.).</p> <p>Depending on their nature and use in Tock (NLP, monitoring, debugging, etc.),</p> <p>these data have specific, configurable retention periods. Each Tock user decides and configures how long the stored data is retained, based on their needs.</p> <p>The Installation &gt; Data Retention section describes the different types of data retained and how to modify their retention period.</p>"},{"location":"admin/supervision/","title":"Supervision","text":""},{"location":"admin/supervision/#supervision","title":"Supervision","text":"<p>This chapter presents some supervision and monitoring aspects of the functioning of the platform and Tock bots.</p> <p>Coming soon: more details on how to monitor bots, even examples of dashboards for some classic monitoring technologies. Feel free to share yours.</p>"},{"location":"admin/supervision/#healthchecks","title":"Healthchecks","text":"<p>The APIs of the different Tock components include different probes or lifelines (healthchecks) to check if everything is working properly.</p> <p>These lifelines can be used by automated monitoring systems.</p>"},{"location":"admin/supervision/#probes-paths","title":"Probes &amp; paths","text":"<p>Each <code>WebVerticle</code> exposes 3 probes returning the <code>HTTP 200</code> code if everything is working.</p> Default path Description Property to modify the path <code>/healthcheck</code> The component is working properly. (Detailed mode: see below) <code>tock_vertx_healthcheck_path</code> <code>/health/readiness</code> The component is ready to process requests. <code>tock_vertx_readinesscheck_path</code> <code>/health/liveness</code> The component is started. <code>tock_vertx_livenesscheck_path</code> <p>For some components and images, the lifeline cannot be exposed directly at the root, the path is modified. In particular:</p> <ul> <li>For <code>tock/admin</code>, the lifeline is located by default in <code>/rest/admin/healthcheck</code></li> <li>For <code>tock/nlp_api</code>, the lifeline is <code>/rest/nlp/healthcheck</code></li> </ul> <p>Each default path can be modified with a dedicated property (see table above).</p>"},{"location":"admin/supervision/#detailed-mode","title":"Detailed mode","text":"<p>The main lifeline <code>/healthcheck</code> can perform a more detailed inspection (ie. usually check the connection to other components) if the <code>tock_detailed_healthcheck_enabled</code> property is enabled.</p> <p>The lifeline response then specifies the components checked.</p> <p>Here is an example of activation in the <code>bot_admin</code> Docker image:</p> <ul> <li> <p>{: data-hl-lines=\"6\"} docker-compose.yml <pre><code>    version: '3'\n    services:\n      admin_web:\n        image: tock/bot_admin:$TAG\n        environment:\n        - tock_detailed_healthcheck_enabled=true\n</code></pre></p> </li> <li> <p>{: data-hl-lines=\"8\"} dockerrun.aws.json <pre><code>  {\n    \"AWSEBDockerrunVersion\": 2,\n    \"containerDefinitions\": [\n      {\n        \"name\": \"admin_web\",\n        \"image\": \"tock/bot_admin:${TAG}\",\n        \"environment\": [\n          { \"name\": \"tock_detailed_healthcheck_enabled\", \"value\": \"true\" }\n        ]\n      }\n    ]\n  }\n</code></pre> {: .tabbed-code}</p> </li> </ul> <p>Example of a lifeline response in detailed mode:</p> <pre><code>  {\n    \"results\": [\n      {\n        \"id\": \"duckling_service\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_front_database\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_model_database\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_bot_database\",\n        \"status\": \"OK\"\n      }\n    ]\n  }\n</code></pre> <p>See below for a summary of the lifelines component by component.</p>"},{"location":"admin/supervision/#details-by-component","title":"Details by component","text":"<p>The table below details the path and checks performed by the main lifeline component by component, in normal and detailed mode:</p> Component / Image Default Path Default Check Detailed Check (<code>tock_detailed_healthcheck_enabled=true</code>) NLP <code>/rest/nlp/healthcheck</code> Duckling / entity providers OK. <code>front</code> and <code>model</code> databases OK. Duckling / RestEntityProvider <code>/healthcheck</code> Duckling bridge initialized. Idem Build Worker <code>/healthcheck</code> Worker ready to analyze the model. <code>front</code> and <code>model</code> databases OK. Bot / Bot Api <code>/healthcheck</code> Bot installed, connected to the database, NLP OK. Idem WebHook (Bot Api) <code>/healthcheck</code> OK Idem Kotlin Compile <code>/healthcheck</code> OK Idem NLP / Bot Admin <code>/rest/admin/healthcheck</code> OK Duckling / entity providers OK, <code>front</code> <code>model</code> and <code>bot</code> databases OK. <p>Below are examples of responses from different components in verbose mode:</p> <ul> <li> <p>NLP <pre><code>  {\n    \"results\": [\n      {\n        \"id\": \"duckling_service\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_front_database\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_model_database\",\n        \"status\": \"OK\"\n      }\n    ]\n  }\n</code></pre></p> </li> <li> <p>Duckling <pre><code>  {\n    \"results\": [\n      {\n        \"id\": \"duckling_bridge\",\n        \"status\": \"OK\"\n      }\n    ]\n  }\n</code></pre></p> </li> <li> <p>Build Worker <pre><code>  {\n    \"results\": [\n      {\n        \"id\": \"tock_front_database\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_model_database\",\n        \"status\": \"OK\"\n      }\n    ]\n  }\n</code></pre></p> </li> <li> <p>Bot Api <pre><code>  {\n    \"results\": [\n      {\n        \"id\": \"nlp_client\",\n        \"status\": \"OK\"\n      }\n    ]\n  }\n</code></pre></p> </li> <li> <p>Kotlin Compiler <pre><code> {\n  \"results\": []\n }\n</code></pre></p> </li> <li> <p>Bot Admin <pre><code>  {\n    \"results\": [\n      {\n        \"id\": \"duckling_service\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_front_database\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_model_database\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_bot_database\",\n        \"status\": \"OK\"\n      }\n    ]\n  }\n</code></pre> {:.tabbed-code}</p> </li> </ul>"},{"location":"admin/supervision/#lifeline-monitoring","title":"Lifeline Monitoring","text":"<p>The different probes and lifelines can be used to configure monitoring systems and other container orchestrators, for example, to measure service availability, trigger alerts or dynamically remediate problems.</p> <p>Depending on the tools and technologies used, lifeline configuration can be done in different ways. Here are some examples for reference:</p> <ul> <li>At the level of the Cloud or on-premise load balancers (load balancers), for example:</li> <li>in the Health checks section at the ELB level in AWS</li> <li>with the <code>health_check</code> directive in NGINX</li> <li>with the <code>httpchk option</code> in HAProxy</li> <li>In Docker (<code>Dockerfile</code> descriptors):</li> <li>with the <code>health_check</code> instruction <code>HEALTHCHECK</code> to check the component status</li> <li>with <code>ENTRYPOINT</code> or <code>CMD</code> to wait for the component to be ready at startup</li> <li>In Docker Compose (<code>docker-compose.yml</code> descriptors):</li> <li>with <code>healthcheck</code></li> <li>In Kubernetes:</li> <li>with <code>livenessProbe</code> and <code>readinessProbe</code></li> <li>Etc.</li> </ul>"},{"location":"admin/supervision/#logging","title":"Logging","text":""},{"location":"admin/supervision/#application-logs","title":"Application logs","text":"<p>Tock uses SLF4J and Logback to generate its server-side application logs.</p> <p>By default, Tock automatically configures its logs and a few properties allow you to modify the configuration.</p> <p>It is possible to finely configure the logs according to your needs, in particular with Logback configuration files or with Docker Compose.</p>"},{"location":"admin/supervision/#auto-configuration","title":"Auto-configuration","text":"<p>By default, in the absence of specific configuration, Tock configures its logs automatically using the class <code>LogbackConfigurator</code>. This configures Logback programmatically, with the following behavior:</p> <ul> <li>General log level <code>DEBUG</code> if <code>tock_env=dev</code> (default), or <code>INFO</code> for other environments and production</li> <li>Exception for <code>org.mongodb.driver</code> logs always at <code>INFO</code></li> <li>Exception for <code>io.netty</code> logs always at <code>INFO</code></li> <li>Exception for <code>okhttp3</code> logs always at <code>INFO</code></li> <li>Exception for <code>io.mockk</code> logs always at <code>INFO</code></li> <li>Logs directed to the console (standard output) by default, but possibility to write to files</li> <li>In file log mode, writing to <code>log/logFile.log</code>, archiving a file every day (<code>log/logFile.%d{yyyy-MM-dd}.log</code>), maximum <code>30</code> days or <code>3GB</code> of logs kept</li> </ul> <p>To learn more about automatic configuration of Tock logs, refer to the implementation <code>LogbackConfigurator</code>.</p> <p>Environment variables allow to configure these different logging modes. They can be defined independently on each component producing logs.</p> Environment variable Default value Description <code>tock_env</code> <code>dev</code> Environment (warning: controls other mechanisms than logs). <code>tock_logback_enabled</code> <code>true</code> Enable logs. <code>tock_default_log_level</code> <code>DEBUG</code> if <code>tock_env=dev</code> (otherwise <code>INFO</code>) General log level (except exceptions, see above). <code>tock_retrofit_log_level</code> <code>BASIC</code> if <code>tock_env=dev</code> (otherwise <code>NONE</code>) Log level (requests and responses) for application client services using Retrofit (TockNlpClient, BotApiClient, and many connectors...) <code>tock_logback_file_appender</code> <code>false</code> Logs files (see details above) instead of console logs (standard output). <p>Depending on the deployment mode used, these environment variables can be added either directly on the command line, or in a descriptor like <code>docker-compose.yml</code>, <code>dockerrun.aws.json</code> or other.</p> <p>Here is an example configuring Tock Studio logs (<code>admin_web</code>) in Docker:</p> <ul> <li> <p>{: data-hl-lines=\"6 7\"} docker-compose.yml <pre><code>  version: '3'\n  services:\n    admin_web:\n      image: tock/bot_admin:$TAG\n      environment:\n      - tock_default_log_level=WARN\n      - tock_logback_file_appender=true\n</code></pre></p> </li> <li> <p>{: data-hl-lines=\"8\"} dockerrun.aws.json <pre><code>  {\n    \"AWSEBDockerrunVersion\": 2,\n    \"containerDefinitions\": [\n      {\n        \"name\": \"admin_web\",\n        \"image\": \"tock/bot_admin:${TAG}\",\n        \"environment\": [\n          { \"name\": \"tock_default_log_level\", \"value\": \"WARN\" },\n          { \"name\": \"tock_logback_file_appender\", \"value\": \"true\" }\n        ]\n      }\n    ]\n  }\n</code></pre> {: .tabbed-code}</p> </li> </ul>"},{"location":"admin/supervision/#logback-files","title":"Logback Files","text":"<p>It is possible to finely configure the Tock logs by directly configuring Logback. For this, different possibilities exist, in particular configuration files in XML or Groovy format. Below is an example configuration:</p> <ul> <li>logback.xml <pre><code>    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n    &lt;configuration debug=\"false\"&gt;\n\n        &lt;logger name=\"ai.tock\" level=\"DEBUG\" /&gt;\n\n        &lt;logger name=\"org.mongodb\" level=\"WARN\" /&gt;\n\n        &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n            &lt;encoder&gt;\n                &lt;pattern&gt;\n                    %d %-5level [%thread] %logger{1}: %msg%n\n                &lt;/pattern&gt;\n            &lt;/encoder&gt;\n        &lt;/appender&gt;\n\n        &lt;root level=\"INFO\"&gt;\n            &lt;appender-ref ref=\"console\" /&gt;\n        &lt;/root&gt;\n\n    &lt;/configuration&gt;\n</code></pre></li> <li>logback.groovy <pre><code>    import ch.qos.logback.classic.encoder.PatternLayoutEncoder\n    import ch.qos.logback.core.ConsoleAppender\n\n    import static ch.qos.logback.classic.Level.DEBUG\n    import static ch.qos.logback.classic.Level.INFO\n    import static ch.qos.logback.classic.Level.WARN\n\n    appender(\"console\", ConsoleAppender) {\n      encoder(PatternLayoutEncoder) {\n        pattern = \"%d %-5level [%thread] %logger{1}: %msg%n\"\n      }\n    }\n    logger(\"ai.tock\", DEBUG)\n    logger(\"org.mongodb\", WARN)\n    root(INFO, [\"console\"])\n</code></pre> {:.tabbed-code}</li> </ul> <p>In this example:</p> <ul> <li>The general log level is <code>INFO</code>, with exceptions:</li> <li>Exception for <code>ai.tock</code> logs always at <code>DEBUG</code></li> <li>Exception for <code>org.mongodb</code> logs always at <code>WARN</code></li> <li>Logs are directed to the console (standard output)</li> </ul> <p>Many possibilities are offered to configure the logs thanks to these configuration files: log levels adjusted according to the embedded packages/frameworks, modification of the default pattern, logging of log files and automatic archiving with a <code>RollingFileAppender</code>, redirection of logs to a database or email server, etc. For more information, refer to the Logback documentation.</p> <p>Once the Logback configuration file has been created, you must ensure that it is in the classpath of the Tock component and that Logback identifies it as the configuration to follow (for this, you generally use the <code>-Dlogback.configurationFile</code> property when starting the Java component).</p> <p>Below is a complete example in Docker Compose with:</p> <ul> <li>A <code>logback.xml</code> file embedded by Maven (<code>pom.xml</code>) in the Docker image</li> <li>Some environment variables defined to be able to quickly adjust the main log levels directly in Docker-Compose (without having to modify the XML file or the Docker image)'</li> </ul> <p>^ - logback.xml <pre><code>    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n    &lt;configuration debug=\"false\"&gt;\n\n        &lt;!-- Leverage env variables with defaults, for more flexibility --&gt;\n        &lt;variable name=\"tock_default_log_level\" value=\"${tock_default_log_level:-WARN}\" /&gt;\n        &lt;variable name=\"tock_service_log_level\" value=\"${tock_service_log_level:-INFO}\" /&gt;\n        &lt;variable name=\"tock_database_log_level\" value=\"${tock_database_log_level:-WARN}\" /&gt;\n\n        &lt;logger name=\"ai.tock\" level=\"${tock_service_log_level}\" /&gt;\n        &lt;logger name=\"org.mongodb\" level=\"${tock_database_log_level}\" /&gt;\n\n        &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n            &lt;encoder&gt;\n                &lt;pattern&gt;\n                    %d %-5level [%thread] %logger{1}: %msg%n\n                &lt;/pattern&gt;\n            &lt;/encoder&gt;\n        &lt;/appender&gt;\n\n        &lt;root level=\"${tock_default_log_level}\"&gt;\n            &lt;appender-ref ref=\"console\" /&gt;\n        &lt;/root&gt;\n\n    &lt;/configuration&gt;\n</code></pre> - {: data-hl-lines=\"21 22 23 24 29\"} pom.xml</p> <p><pre><code>    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n    &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n        &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n        &lt;artifactId&gt;tock-docker-bot-admin&lt;/artifactId&gt;\n        &lt;build&gt;\n            &lt;plugins&gt;\n                &lt;plugin&gt;\n                    &lt;groupId&gt;io.fabric8&lt;/groupId&gt;\n                    &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;\n                    &lt;configuration&gt;\n                        &lt;images&gt;\n                            &lt;image&gt;\n                                &lt;name&gt;tock/bot_admin:${project.version}&lt;/name&gt;\n                                &lt;build&gt;\n                                    &lt;assembly&gt;\n                                        &lt;inline&gt;\n                                            &lt;dependencySets&gt;\n                                                ...\n                                            &lt;/dependencySets&gt;\n                                            &lt;files&gt;\n                                                &lt;file&gt;\n                                                    &lt;source&gt;logback.xml&lt;/source&gt;\n                                                    &lt;outputDirectory&gt;.&lt;/outputDirectory&gt;\n                                                &lt;/file&gt;\n                                            &lt;/files&gt;\n                                        &lt;/inline&gt;\n                                    &lt;/assembly&gt;\n                                    &lt;cmd&gt;\n                                        &lt;shell&gt;java $JAVA_ARGS -Dlogback.configurationFile='file:///maven/logback.xml' -Dfile.encoding=UTF-8 -Dtock_nlp_model_refresh_rate=10 -cp '/maven/*' ai.tock.bot.admin.StartBotAdminServerKt&lt;/shell&gt;\n                                    &lt;/cmd&gt;\n                                    ...\n</code></pre> - {: data-hl-lines=\"6 7 8\"} docker-compose.yml <pre><code>    version: '3'\n    services:\n      admin_web:\n        image: tock/bot_admin:$TAG\n        environment:\n        - tock_default_log_level=WARN # Default, see logback.xml\n        - tock_service_log_level=INFO # Default, see logback.xml\n        - tock_database_log_level=WARN # Default, see logback.xml\n</code></pre> {: .tabbed-code}</p> <p>The full code for this example applied to all Tock modules is available in the <code>tock-docker</code> repository on the <code>logbackxml</code> branch.</p>"},{"location":"admin/supervision/#docker-compose","title":"Docker Compose","text":"<p>For Docker Compose users, a mechanism allows to configure logs directly in YAML descriptors. See the <code>tock-docker</code> repository for an example of Tock implementation in Docker Compose.</p> <p>Each application component can have its own configuration:</p> <ul> <li>docker-compose.yml <pre><code>logging:\n  driver: \"json-file\"\n  options:\n    max-size: \"10m\"\n    max-file: \"5\"\n</code></pre> {: .tabbed-code}</li> </ul> <p>The example above configures an automatic rotation of log files, so as to have a maximum of <code>5</code> log files of maximum <code>10 MB</code> each (the oldest being deleted to create a new one if necessary).</p> <p>For more information, see the Docker Compose documentation for this mechanism.</p>"},{"location":"admin/supervision/#encryption-and-anonymization","title":"Encryption and anonymization","text":"<p>See the security page for log encryption and anonymization options.</p>"},{"location":"admin/synchronization/","title":"Documentation of the Multilingual Synchronization Feature","text":"<p>This documentation provides detailed information about our multilingual synchronization feature now accessible via the settings of your application. It is presented as follows:</p> <p></p> <p>This feature requires the user to specify a source and a target, each associated with a namespace and an application, to synchronize data between different bots. It facilitates the development, testing, and maintenance of your chatbots, whether in monolingual or multilingual mode.</p>"},{"location":"admin/synchronization/#activation","title":"Activation","text":"<p>Please ask your administrator to switch the <code>tock_namespace_open_access</code>property to <code>true</code> in tock studio to enable the feature.</p>"},{"location":"admin/synchronization/#key-features","title":"Key Features:","text":"<p>The synchronization function offers several essential features:</p> <ul> <li>Copying of Stories and Intentions: You can synchronize \"stories\" and their intentions between a Source bot and a Target bot, whether in a development or production environment. This facilitates testing and improvements without directly affecting the production version.</li> </ul> <p>WARNING: It is important to note that during synchronization, the \"stories\" of the target bot that are not found in the source bot will be deleted, and the rest will be overwritten by the \"stories\" from the source bot.</p> <ul> <li>Overwriting of Training: The training of the Source bot overwrites that of the Target bot.</li> </ul> <p>INFO: Only pre-existing information in the Source bot is affected, thus preserving the specific information of the Target bot that is not derived from the Source bot.</p> <ul> <li>Copying of Untrained Sentences (Copy Inbox Messages): when this feature is activated, untrained sentences are also retrieved. The typical use case for this feature is to copy a production bot with untrained sentences to a pre-prod bot to train these sentences on newly created intentions.</li> </ul>"},{"location":"admin/synchronization/#benefits-of-the-feature-with-usage-examples","title":"Benefits of the Feature with Usage Examples:","text":"<p>Synchronization offers significant advantages:</p> <ul> <li>Efficient Improvement: Synchronization allows for improving a production chatbot without disrupting the current version. For example, if you have a customer service chatbot in production (Target bot) and you want to add new features developed in the development environment (Source bot).</li> </ul> <p>Usage Example: You can integrate new \"stories,\" intentions, and training data from the original bot into the destination bot without disrupting current customer service. This allows expanding the capabilities of the production chatbot while maintaining service continuity.</p> <ul> <li>Enrichment of Training: Copying the training from the original bot into the destination bot allows for enriching the capabilities of the destination bot.</li> </ul> <p>Usage Example: If the destination bot had learned that \"hello\" is linked to the \"greetings\" intention, but the original bot was trained with \"hello\" associated with the \"test\" intention, synchronization will update the destination bot to include this new understanding, while preserving the previous training. This improves the accuracy and understanding of the destination bot without losing pre-existing knowledge.</p>"},{"location":"admin/synchronization/#conclusion","title":"Conclusion:","text":"<p>The multilingual synchronization function improves the management of chatbots by allowing efficient synchronization between different bots, whether in development or in production. It facilitates improvement, adding new \"stories\" and intentions, and enriching the training of the destination bot, while preserving its previous entity. Although limitations remain, the team continues to work to improve this feature and offer a versatile solution for chatbot management.</p>"},{"location":"dev/api/","title":"Tock APIs","text":"<p>This section of the Tock documentation provides a brief overview of the different APIs offered by Tock.</p>"},{"location":"dev/api/#tock-web-connector-api","title":"Tock Web Connector API","text":"<p>The Tock Web Connector allows interaction with a bot through a REST API.</p> <p>The documentation for this API is available at /api/web-connector.</p>"},{"location":"dev/api/#tock-nlu-api","title":"Tock NLU API","text":"<p>The Tock NLU/NLP API (Natural Language Understanding/Processing) allows programmatic querying of the conversational model and sentence analysis.</p> <p>The Tock NLU API documentation is available at /api.</p> <p>You can find this documentation on the Tock demo platform at https://demo.tock.ai/doc/.</p> <p>If you have deployed a Tock platform locally using the provided Docker images, this documentation is available at http://localhost/doc/index.html.</p>"},{"location":"dev/api/#tock-studio-admin-api","title":"Tock Studio / Admin API","text":"<p>Similarly, the Tock Studio API documentation is available at /api/admin.</p> <p>You can find this documentation on the Tock demo platform at https://demo.tock.ai/doc/admin.html.</p> <p>If you have deployed a Tock platform locally using the provided Docker images, this documentation is available at http://localhost/doc/admin.html.</p>"},{"location":"dev/api/#tock-bot-definition-api","title":"Tock Bot Definition API","text":"<p>This API allows the creation of bots and journeys (stories) using any programming language. A Tock bot can include journeys configured in Tock Studio, supplemented by journeys developed in a programming language to implement complex rules, interact with other APIs, and more.</p> <p>This API is used by Kotlin, JavaScript/Node.js, and Python clients available in both WebHook and WebSocket modes.</p> <p>Note: The API is still under development (beta), and its documentation will be available soon.</p> <p>For development in Bot API mode, see this page.</p>"},{"location":"dev/bot-api/","title":"Developing in Tock Bot API mode","text":"<p>Tock's Bot API mode allows you to develop bots by connecting to a Tock Studio platform using Tock's conversational REST API.</p> <p>It is therefore the recommended Tock development mode to get started, as well as in scenarios where shared access to the database would be an issue.</p> <p>Only Bot API mode is available on the public Tock demo platform platform.</p> <p>This page presents Tock bot development in Bot API mode in Kotlin. Clients are also available for Javascript/Node and Python. It is possible to develop Tock courses in any language via the Bot API.  </p> <p> </p> <p>Another section presents the Bot Framework mode available for Kotlin only, more integrated but also more coupled with the Tock platform.</p>"},{"location":"dev/bot-api/#connect-to-the-demo-platform","title":"Connect to the demo platform","text":"<p>Rather than deploying your own Tock platform, it is possible to test the WebSocket or Webhook modes directly on the Tock demo platform.</p>"},{"location":"dev/bot-api/#develop-in-kotlin","title":"Develop in Kotlin","text":""},{"location":"dev/bot-api/#enable-websocket-mode","title":"Enable WebSocket mode","text":"<p>This is the mode to use at startup because it is the easiest to implement.</p> <p>To use the websocket client, you must add the <code>tock-bot-api-websocket</code> dependency to your Kotlin application/project.</p> <p>For example in a Maven project:</p> <p><code>`xml         &lt;dependency&gt;             &lt;groupId&gt;ai.tock&lt;/groupId&gt;             &lt;artifactId&gt;tock-bot-api-websocket&lt;/artifactId&gt;             &lt;version&gt;24.9.4&lt;/version&gt;         &lt;/dependency&gt;</code></p> <p>Or in a Gradle project:</p> <p><code>groovy compile 'ai.tock:tock-bot-api-websocket:24.9.4'</code></p>"},{"location":"dev/bot-api/#enable-webhook-mode","title":"Enable WebHook mode","text":"<p>Alternatively, you can choose to use the WebHook client, you need to add the dependency <code>tock-bot-api-webhook</code> to your Kotlin application/project.</p> <p>For example in a Maven project:</p> <p><code>xml         &lt;dependency&gt;             &lt;groupId&gt;ai.tock&lt;/groupId&gt;             &lt;artifactId&gt;tock-bot-api-webhook&lt;/artifactId&gt;             &lt;version&gt;24.9.4&lt;/version&gt;         &lt;/dependency&gt;</code></p> <p>Or in a Gradle project:</p> <p><code>groovy compile 'ai.tock:tock-bot-api-webhook:24.9.4'</code></p> <p>In this case, unlike in WebSocket mode, the application/bot started must be reachable by the Tock platform via a public URL (you can use for example ngrok).</p> <p>This URL must be specified in the webhook url field in the Configuration &gt; Bot Configurations view of the Tock Studio interface.</p>"},{"location":"dev/bot-api/#set-the-api-key","title":"Set the API key","text":"<p>In Tock Studio, after configuring a bot, go to Configuration &gt; Bot Configurations and copy the API key of the bot you want to connect to.</p> <p>You will be able to enter/paste this key into the Kotlin code (see below).</p>"},{"location":"dev/bot-api/#creer-des-parcours-en-kotlin","title":"Cr\u00e9er des parcours en Kotlin","text":"<p>Pour le moment, les composants suivants sont support\u00e9s pour les r\u00e9ponses :</p> <ul> <li>Texte avec Boutons (Quick Reply)</li> <li>Format \"carte\"</li> <li>Format \"carousel\"</li> <li>Formats sp\u00e9cifiques aux diff\u00e9rents canaux int\u00e9gr\u00e9s</li> </ul> <p>Voici un exemple de bot simple avec quelques parcours d\u00e9clar\u00e9s : </p> <p><code>kotlin fun main() {     startWithDemo(         newBot(             \"PUT-YOUR-TOCK-APP-API-KEY-HERE\", // Retrieve the API key from the \"Bot Configurations\" tab in Tock Studio             newStory(\"greetings\") { // Intention 'greetings'                 end(\"Hello!\") // Simple text response             },             newStory(\"location\") { // Intention 'location'                 end(                     // Response with a card - including text, an attachment (e.g., an image), and suggested user actions                     newCard(                         \"Card Title\",                         \"A subtitle\",                         newAttachment(\"https://url-image.png\"),                         newAction(\"Action 1\"),                         newAction(\"Action 2\", \"http://redirection\")                      )                 )             },             newStory(\"goodbye\") { // Intention 'goodbye'                 end {                     // Messenger-specific response                     buttonsTemplate(\"Are you sure you want to leave?\", nlpQuickReply(\"I'll stay\"))                 }              },             // Bot response in case of misunderstanding             unknownStory {                 end(\"I didn't understand. But I'm learning every day :)\")             }         )     ) }</code></p> <p>The full source code of the example is available.</p>"},{"location":"dev/bot-api/#developing-in-javascript","title":"Developing in Javascript","text":"<p>A client is provided to develop Javascript courses with Nodejs. For more information, see the documentation on the <code>tock-node</code> repository.</p>"},{"location":"dev/bot-api/#developing-in-python","title":"Developing in Python","text":"<p>A client is provided for developing courses in Python. For more information, see the documentation on the <code>tock-py</code> repository.</p>"},{"location":"dev/bot-api/#develop-via-api","title":"Develop via API","text":"<p>It is possible to develop Tock courses in any language, by interfacing directly with the API.</p>"},{"location":"dev/bot-api/#install-bot-api-on-the-server-side","title":"Install Bot API on the server side","text":"<p>To use Tock's Bot API mode, a specific module must be deployed with the platform. Generally called <code>bot-api</code> in Docker Compose descriptors for example, this service has the role of:</p> <ul> <li>Exposing the Bot API to potential clients regardless of their programming language</li> <li>Accepting WebSocket connections and/or connecting to the configured webhook</li> </ul> <p>The guide Deploying Tock with Docker or the chapter Installation show how to deploy this module if necessary.</p> <p>The only modification required compared to the example code for the demonstration platform is to replace the <code>startWithDemo</code> method with <code>start</code>, specifying if necessary the address of the <code>bot-api</code> server.</p>"},{"location":"dev/bot-integre/","title":"D\u00e9velopper en mode Tock Bot int\u00e9gr\u00e9","text":"<p>Le mode Bot int\u00e9gr\u00e9 Tock permet de d\u00e9velopper un bot en utilisant un  Domain Specifique Language (DSL)   en Kotlin.</p> <p>Contrairement au mode Bot API encore en d\u00e9veloppement, le Bot Framework Kotlin permet d'exploiter toutes les  possibilit\u00e9s de la plateforme Tock, notamment :</p> <ul> <li>Gestion des contextes utilisateurs</li> <li>Historique de conversation</li> <li>Notions avanc\u00e9es comme la fusion d'entit\u00e9s</li> <li>Etc.</li> </ul> <p>Exemple de fusion d'entit\u00e9s : lorsque un utilisateur demande \"demain\" dans une phrase  (appelons cette entit\u00e9 date) puis \"plut\u00f4t le soir\" dans une phrase suivante, la fusion permet de mettre \u00e0 jour  automatiquement l'entit\u00e9 (date) avec les deux informations compl\u00e9mentaires : jour et cr\u00e9neau horaire dans cet exemple.</p> <p>Attention : dans ce mode de d\u00e9veloppement, contrairement au mode Bot API, il est n\u00e9cessaire que le module bot   dispose d'une connexion \u00e0 la base de donn\u00e9e (MongoDB) de la plateforme Tock utilis\u00e9e.</p> <p>Pour appr\u00e9hender compl\u00e8tement ce qui va suivre, il est recommand\u00e9 de ma\u00eetriser les bases du  langage de programmation Kotlin.</p>"},{"location":"dev/bot-integre/#demarrer-avec-le-framework","title":"D\u00e9marrer avec le framework","text":""},{"location":"dev/bot-integre/#documentation-kdoc","title":"Documentation KDoc","text":"<p>La documentation du framework au format KDoc est disponible ici.</p>"},{"location":"dev/bot-integre/#dependance-bot-toolkit","title":"D\u00e9pendance <code>bot-toolkit</code>","text":"<p>Pour utiliser le framework conversationnel, il faut ajouter la d\u00e9pendance <code>bot-tookit</code> \u00e0 l'application / au projet Kotlin.</p> <p>Par exemple dans un projet Maven :</p> <pre><code>        &lt;dependency&gt;\n            &lt;groupId&gt;ai.tock&lt;/groupId&gt;\n            &lt;artifactId&gt;bot-toolkit&lt;/artifactId&gt;\n            &lt;version&gt;24.9.4&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre> <p>Ou dans un projet Gradle :</p> <pre><code>      compile 'ai.tock:bot-toolkit:24.9.4'\n</code></pre>"},{"location":"dev/bot-integre/#un-bot-est-un-ensemble-de-parcours-stories","title":"Un bot est un ensemble de parcours (stories)","text":"<p>Voici par exemple comment le Bot Open Data est d\u00e9fini :</p> <pre><code>val openBot = bot(\n        \"bot_open_data\",\n        stories =\n        listOf(\n                greetings,\n                departures,\n                arrivals,\n                search\n        ),\n        hello = greetings\n)\n</code></pre> <p>Ce bot comporte un identifiant (obligatoire - \"bot_open_data\") et une liste de parcours ou stories.</p> <p>Une Story est un regroupement fonctionnel qui correspond \u00e0 une intention principale et, de mani\u00e8re optionelle, \u00e0 une ou plusieurs intentions dites \"secondaires\" (voir Concepts).</p> <p>Ici le bot d\u00e9finit 4 parcours : <code>greetings</code>, <code>departures</code>, <code>arrivals</code> et <code>search</code>. </p> <p>Le parcours <code>greetings</code> est d\u00e9clar\u00e9 comme parcours principal, il sera pr\u00e9sent\u00e9 par d\u00e9faut au d\u00e9but d'une conversation : <code>hello = greetings</code>.</p>"},{"location":"dev/bot-integre/#une-story-simple","title":"Une Story simple","text":"<p>Comment d\u00e9finit-on une Story?</p> <p>Voici une premi\u00e8re version simplifi\u00e9e du parcours <code>greetings</code> :</p> <pre><code>val greetings = story(\"greetings\") {\n    send(\"Bienvenue chez le Bot Open Data Sncf! :)\")\n    end(\"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\")\n}\n</code></pre> <p>Notez que dans le corps de la fonction, <code>this</code> est de type <code>BotBus</code>, \u00e0 partir duquel vous pouvez interagir avec l'utilisateur, et qui permet \u00e9galement d'acc\u00e8der \u00e0 tous les \u00e9lements contextuels disponibles.</p> <p>Concr\u00e8tement sela signifie que quand l'intention <code>greetings</code> sera d\u00e9tect\u00e9e par le mod\u00e8le NLP, la fonction ci-dessus sera appel\u00e9e par le framework Tock.</p> <p>Le bot envoie donc successivement une premi\u00e8re phrase de r\u00e9ponse (<code>bus.send()</code>), puis un deuxi\u00e8me en indiquant que c'est  la derni\u00e8re phrase de sa r\u00e9ponse \u00e0 l'aide d'un <code>bus.end()</code>.</p> <p>Voici maintenant la version compl\u00e8te de <code>greetings</code> :</p> <pre><code>val greetings = story(\"greetings\") {\n    //cleanup state\n    resetDialogState()\n\n    send(\"Bienvenue chez le Bot Open Data Sncf! :)\")\n    send(\"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\")\n\n    withMessenger {\n        buttonsTemplate(\n              \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :) \",\n              postbackButton(\"Itin\u00e9raires\", search),\n              postbackButton(\"D\u00e9parts\", Departures),\n              postbackButton(\"Arriv\u00e9es\", Arrivals)\n        )\n    }\n    withGoogleAssistant {\n       gaMessage(\n              \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :) \",\n              \"Itin\u00e9raires\",\n              \"D\u00e9parts\",\n              \"Arriv\u00e9es\")\n       }\n\n    end()\n}\n</code></pre> <p>Deux notions ont \u00e9t\u00e9 ajout\u00e9es :</p> <ul> <li> <p><code>resetDialogState()</code> qui permet de repartir d'un contexte utilisateur vide (en oubliant les \u00e9ventuels \u00e9changes pr\u00e9c\u00e9dents)</p> </li> <li> <p>les m\u00e9thodes <code>withMessenger{}</code> et <code>withGoogleAssistant{}</code> qui permettent de d\u00e9finir des r\u00e9ponses sp\u00e9cifiques pour chaque connecteur. Ici un texte avec des boutons pour Messenger, et un texte avec des suggestions pour Google Assistant.</p> </li> </ul>"},{"location":"dev/bot-integre/#demarrer-et-connecter-le-bot","title":"D\u00e9marrer et connecter le bot","text":"<p>Pour d\u00e9marrer le bot, il suffit de rajouter dans votre <code>main</code> principal l'appel suivant :</p> <pre><code>registerAndInstallBot(openBot)\n</code></pre> <p>La variable <code>openBot</code> dans l'exemple est le bot que vous avez d\u00e9fini plus haut.</p> <p>Une fois le bot d\u00e9marr\u00e9, il est \u00e9galement n\u00e9cessaire de sp\u00e9cifier quels connecteurs sont utilis\u00e9s dans l'interface d'administration du bot, du menu Configuration &gt; Bot Configurations &gt; Create a new configuration.</p> <p>Pour en savoir plus sur les diff\u00e9rents canaux et connecteurs, voir cette page.</p>"},{"location":"dev/bot-integre/#importer-la-configuration-dumps","title":"Importer la configuration (dumps)","text":"<p>Il est possible d'exporter diff\u00e9rentes configurations depuis Tock Studio, puis les importer automatiquement au d\u00e9marrage du bot.</p> <p>Une fois export\u00e9s les fichiers dumps de Tock Studio dans le classpath du bot,  on peut appeler une ou plusieurs des fonctions suivantes depuis le <code>main</code> :</p> <ul> <li><code>importApplicationDump</code> : importe une application \u00e0 partir d'un    dump d'application.   Remarque : l'import est ignor\u00e9 si l'application cible existe d\u00e9j\u00e0.</li> <li><code>importNlpDump</code> : importe un mod\u00e8le NLP (intentions, phrases, entit\u00e9s) \u00e0 partir d'un   dump NLP.</li> <li><code>importI18nDump</code> : importe des labels (aka i18n) \u00e0 partir d'un   dump de labels.</li> </ul> <p>Exemple :</p> <pre><code>fun main(args: Array&lt;String&gt;) {\n\n  registerAndInstallBot(bot)\n\n  // Import application\n  importApplicationDump(\"/bot_app_dump.json\")\n\n  // Import NLP model (intents, sentences, entities...)\n  importNlpDump(\"/bot_nlp_dump.json\")\n\n  // Import story labels (aka i18n)\n  importI18nDump(\"/bot_labels_dump.json\")\n}\n</code></pre>"},{"location":"dev/bot-integre/#aller-plus-loin","title":"Aller plus loin","text":"<p>Bien s\u00fbr, le <code>StoryHandler</code> de <code>greetings</code> ne d\u00e9pend pas du contexte : la r\u00e9ponse est toujours la m\u00eame.</p> <p>Pour le d\u00e9veloppement de stories complexes, nous avons besoin d'une abstraction suppl\u00e9mentaire.</p>"},{"location":"dev/bot-integre/#intentions-secondaires","title":"Intentions secondaires","text":"<p>Voici le d\u00e9but de la d\u00e9finition de la story <code>search</code> :</p> <pre><code>val search = storyDef&lt;SearchDef&gt;(\n        \"search\",\n        otherStarterIntents = setOf(indicate_origin),\n        secondaryIntents = setOf(indicate_location)) {\n\n}\n</code></pre> <p>Le parcours <code>search</code> d\u00e9finit une intention secondaire \"de d\u00e9marrage\" (<code>indicate_origin</code>)  et une intention secondaire simple (<code>indicate_location</code>).</p> <p>Une intention secondaire \"de d\u00e9marrage\" est semblable en tout point \u00e0 une intention principale :  d\u00e8s que cette intention est d\u00e9tect\u00e9e, le parcours <code>search</code> va \u00eatre ex\u00e9cut\u00e9,  si la story courante ne poss\u00e8de pas cette intention en tant qu'intention secondaire.</p> <p>Pour une intention secondaire simple, par contre, la story ne sera ex\u00e9cut\u00e9e que si la story courante du contexte  est \"d\u00e9j\u00e0\" la story search. Plusieurs story diff\u00e9rentes peuvent donc partager les m\u00eames intentions secondaires.</p>"},{"location":"dev/bot-integre/#manipuler-les-entites","title":"Manipuler les entit\u00e9s","text":"<p>Pour r\u00e9cup\u00e9rer les valeurs des entit\u00e9s, une bonne pratique est de d\u00e9finir des extensions.  Par exemple voici le code utilis\u00e9 pour r\u00e9cup\u00e9rer l'entit\u00e9 <code>destination</code> :</p> <pre><code>val destinationEntity = openBot.entity(\"location\", \"destination\") \n\nvar BotBus.destination: Place?\n    get() = place(destinationEntity)\n    set(value) = setPlace(destinationEntity, value)\n\nprivate fun BotBus.place(entity: Entity): Place? = entityValue(entity, ::placeValue)?.place\n\nprivate fun BotBus.setPlace(entity: Entity, place: Place?) = changeEntityValue(entity, place?.let { PlaceValue(place) })\n</code></pre> <p>Une entit\u00e9 de type <code>location</code> et de role <code>destination</code> est cr\u00e9\u00e9e.  Il s'agit de l'entit\u00e9 correspondante dans le mod\u00e8le NLP.</p> <p>Une variable <code>destination</code> est d\u00e9finie, qui va simplifier la manipulation de cette entit\u00e9 dans le code m\u00e9tier. Cette variable contient la valeur actuelle de la destination dans le contexte utilisateur.</p> <p>Voici une version compl\u00e9t\u00e9e de la story <code>search</code> qui utilise <code>destination</code> :</p> <pre><code>val search = storyDef&lt;SearchDef&gt;(\n        \"search\",\n        setOf(indicate_origin),\n        setOf(indicate_location)) {\n\n        //check mandatory entities\n        when {\n            destination == null -&gt; end(\"Pour quelle destination?\")\n            origin == null -&gt; end(\"Pour quelle origine?\")\n            departureDate == null -&gt; end(\"Quand souhaitez-vous partir?\")\n        } \n}\n</code></pre> <p>Si il n'y a pas de valeur dans le contexte courant pour la destination, le bot demande de sp\u00e9cifier la destination et en reste l\u00e0. Idem pour l'origine ou la date de d\u00e9part.</p> <p>Si les 3 valeurs obligatoires sont sp\u00e9cifi\u00e9es, il passe \u00e0 la r\u00e9ponse proprement dite d\u00e9velopp\u00e9e dans la classe (<code>SearchDef</code>).</p> <p>La version compl\u00e8te de cette premi\u00e8re partie du code est la suivante :</p> <pre><code>val search = storyDef&lt;SearchDef&gt;(\n        \"search\",\n        setOf(indicate_origin),\n        setOf(indicate_location)) {\n\n        //handle generic location intent\n        if (isIntent(indicate_location) &amp;&amp; location != null) {\n            if (destination == null || origin != null) {\n                destination = returnsAndRemoveLocation()\n            } else {\n                origin = returnsAndRemoveLocation()\n            }\n        }    \n\n        //check mandatory entities\n        when {\n            destination == null -&gt; end(\"Pour quelle destination?\")\n            origin == null -&gt; end(\"Pour quelle origine?\")\n            departureDate == null -&gt; end(\"Quand souhaitez-vous partir?\")\n        }\n}\n</code></pre> <p>Dans le cas o\u00f9 l'intention d\u00e9tect\u00e9e est <code>indicate_location</code>, nous ne savons pas si la localit\u00e9 indiqu\u00e9e repr\u00e9sente l'origine ou la destination. Il est donc cod\u00e9 une r\u00e8gle simple :  Si il existe d\u00e9j\u00e0 dans le contexte une origine et pas de destination, la nouvelle localit\u00e9 est en fait la destination. Sinon, il s'agit de l'origine. </p>"},{"location":"dev/bot-integre/#utiliser-handlerdef","title":"Utiliser <code>HandlerDef</code>","text":"<p>Dans la d\u00e9finition de la story <code>search</code> ci-dessus, vous avez pu noter le typage g\u00e9n\u00e9rique <code>SearchDef</code>.  Voici le code de cette classe :</p> <pre><code>@GAHandler(GASearchConnector::class)\n@MessengerHandler(MessengerSearchConnector::class)\nclass SearchDef(bus: BotBus) : HandlerDef&lt;SearchConnector&gt;(bus) {\n\n    private val d: Place = bus.destination!!\n    private val o: Place = bus.origin!!\n    private val date: LocalDateTime = bus.departureDate!!\n\n    override fun answer() {\n        send(\"De {0} \u00e0 {1}\", o, d)\n        send(\"D\u00e9part le {0}\", date by datetimeFormat)\n        val journeys = SncfOpenDataClient.journey(o, d, date)\n        if (journeys.isEmpty()) {\n            end(\"D\u00e9sol\u00e9, aucun itin\u00e9raire trouv\u00e9 :(\")\n        } else {\n            send(\"Voici la premi\u00e8re proposition :\")\n            connector?.sendFirstJourney(journeys.first())\n            end()\n        }\n    }\n}\n</code></pre> <p><code>SearchDef</code> \u00e9tend <code>HandlerDef</code> qui est un alias d'une classe du framework Tock.</p> <p>C'est en g\u00e9n\u00e9ral ici que l'on va d\u00e9finir le code m\u00e9tier des parcours complexes. </p> <p>Le code est relativement parlant, mais il contient une abstraction suppl\u00e9mentaire : <code>SearchConnector</code>.</p> <p><code>SearchConnector</code> est la classe qui d\u00e9finit le comportement sp\u00e9cifique \u00e0 chaque connecteur, et les annotations  <code>@GAHandler(GASearchConnector::class)</code> et <code>@MessengerHandler(MessengerSearchConnector::class)</code>   indiquent les impl\u00e9mentations correspondantes pour les diff\u00e9rents connecteurs support\u00e9s (respectivement Google Assistant et Messenger).</p> <p>Que se passerait-il s'il n'y avait pas de connecteur pour Google Assistant par exemple ?   La m\u00e9thode <code>connector?.sendFirstJourney(journeys.first())</code> n'enverrait pas la r\u00e9ponse finale, puisque <code>connector</code> serait <code>null</code>.</p>"},{"location":"dev/bot-integre/#utiliser-connectordef","title":"Utiliser <code>ConnectorDef</code>","text":"<p>Voici maintenant une version simplifi\u00e9e de <code>SearchConnector</code> :</p> <pre><code>sealed class SearchConnector(context: SearchDef) : ConnectorDef&lt;SearchDef&gt;(context) {\n\n    fun Section.title(): CharSequence = i18n(\"{0} - {1}\", from, to)\n\n    fun sendFirstJourney(journey: Journey) = withMessage(sendFirstJourney(journey.publicTransportSections()))\n\n    abstract fun sendFirstJourney(sections: List&lt;Section&gt;): ConnectorMessage\n\n}\n</code></pre> <p>Et voici son impl\u00e9mentation pour Messenger :</p> <pre><code>class MessengerSearchConnector(context: SearchDef) : SearchConnector(context) {\n\n    override fun sendFirstJourney(sections: List&lt;Section&gt;): ConnectorMessage =\n          flexibleListTemplate(\n                sections.map { section -&gt;\n                      with(section) {\n                          listElement(\n                                title(),\n                                content(),\n                                trainImage\n                          )\n                      }\n                },\n                compact\n          )\n}\n</code></pre> <p>Le code sp\u00e9cifique \u00e0 chaque connecteur est ainsi correctement d\u00e9coupl\u00e9. Le code commun \u00e0 chaque connecteur est pr\u00e9sent dans <code>SearchConnector</code> et le comportement sp\u00e9cifique \u00e0 chaque connecteur se trouve dans les classes d\u00e9di\u00e9es.</p>"},{"location":"dev/bot-integre/#utiliser-storystep","title":"Utiliser <code>StoryStep</code>","text":"<p>Parfois il est n\u00e9cessaire de se souvenir de l'\u00e9tape \u00e0 laquelle l'utilisateur se trouve dans la story courante. Pour cela Tock met \u00e0 disposition la notion de <code>StoryStep</code>.</p> <p>Il existe deux types de <code>StoryStep</code> :</p>"},{"location":"dev/bot-integre/#simplestorystep","title":"<code>SimpleStoryStep</code>","text":"<p>A utiliser dans les cas simples, pour lequels on va g\u00e9rer le comportement induit directement :</p> <pre><code>enum class MyStep : SimpleStoryStep { a, b }\n\nval story = storyWithSteps&lt;MyStep&gt;(\"intent\") {\n    if(step == a) {\n        // ...\n    } else if(step == b) {\n        // ...\n    } else {\n        //default case\n    }\n}\n</code></pre> <p>Pour modifier l'\u00e9tape courante, deux m\u00e9thodes sont disponibles :</p> <ul> <li>Modifier manuellement l'\u00e9tape</li> </ul> <pre><code>val story = storyWithSteps&lt;MyStep&gt;(\"intent\") {\n    //(...)\n    step = MyStep.a\n    // l'\u00e9tape sera persist\u00e9e tant que nous resterons dans cette story\n}\n</code></pre> <ul> <li>Utiliser les boutons ou autres quick replies</li> </ul> <p>Plus de d\u00e9tails sur ce sujet plus bas.</p>"},{"location":"dev/bot-integre/#les-storystep-avec-comportement","title":"Les <code>StoryStep</code> avec comportement","text":"<p>Dans des cas plus complexes, on souhaite pouvoir d\u00e9finir un comportement pour chaque \u00e9tape.  L'utilisation de <code>HandlerDef</code> est alors un pr\u00e9requis.</p> <pre><code>enum class MySteps : StoryStep&lt;MyHandlerDef&gt; {\n\n    //pas de comportement sp\u00e9cifique\n    display,\n\n    select {\n\n        // la step \"select\" sera automatiquement s\u00e9lectionn\u00e9e si la sous-intention select est d\u00e9tect\u00e9e\n        override val intent: IntentAware? = SecondaryIntent.select\n        //dans ce cas la r\u00e9ponse suivante sera apport\u00e9e\n        override fun answer(): MyHandlerDef.() -&gt; Any? = {\n            end(\"I don't know yet how to select something\")\n        }\n    },\n\n    disruption {\n        //seule la r\u00e9ponse est configur\u00e9e\n        override fun answer(): ScoreboardDef.() -&gt; Any? = {\n            end(\"some perturbation\")\n        }\n    };\n}\n</code></pre> <p>Davantage d'options de configuration sont disponibles. Consultez la description de  <code>StoryStep</code>. </p>"},{"location":"dev/bot-integre/#postback-buttons-quick-replies","title":"Postback buttons &amp; quick replies","text":"<p>Messenger met \u00e0 disposition ce type de bouton, et la plupart des connecteurs avec interface graphique font de m\u00eame.</p> <p>Tock permet de d\u00e9finir l'action effectu\u00e9e suite \u00e0 un clic sur ces boutons. </p> <p>Dans l'exemple suivant, le bouton redirigera vers l'intention <code>search</code>. </p> <pre><code>buttonsTemplate(\n            \"The bot is very limited! Only itineraries are supported :)\",\n            postbackButton(\"Itineraries\", search)\n</code></pre> <p>Il est possible de d\u00e9finir \u00e9galement une <code>StoryStep</code> et des param\u00e8tres d\u00e9di\u00e9s :</p> <pre><code>//pour d\u00e9finir des param\u00e8tres, la pratique recommand\u00e9e est d'\u00e9tendre l'interface ParameterKey\nenum class ChoiceParameter : ParameterKey {\n    nextResultDate, nextResultOrigin\n}\n\nbuttonsTemplate(\n            \"The bot is very limited! Only itineraries are supported :)\",\n            postbackButton(\n                \"Itineraries\",\n                intent = search, \n                //si aucune step n'est indiqu\u00e9e, c'est la step courante qui est utilis\u00e9e\n                step = MyStep.a, \n                parameters =  \n                    //ce param\u00e8tre est stock\u00e9 sous forme de cha\u00eene de caract\u00e8re (les crochets sont utilis\u00e9s)\n                    nextResultDate[nextDate] + \n                    //ce param\u00e8tre est stock\u00e9 en json (les parenth\u00e8ses sont utilis\u00e9es)\n                    nextResultOrigin(origin)\n            )\n</code></pre> <p>Pour r\u00e9cup\u00e9rer les param\u00e8tres du bouton sur lequel on a cliqu\u00e9 :</p> <pre><code>    val isClick = isChoiceAction()\n    val nextDate = choice(nextResultDate)\n    val nextOrigin : Locality = action.jsonChoice(nextResultOrigin)\n</code></pre>"},{"location":"dev/bot-integre/#tests-unitaires","title":"Tests Unitaires","text":"<p>La page Tests Unitaires pr\u00e9sente le framework fourni pour r\u00e9aliser des TUs  avec Tock.</p>"},{"location":"dev/connectors/","title":"Tock Connectors","text":"<p>The Multichannel Bot page of the user documentation introduces the concept of Tock connectors and provides a list of the connectors already available.</p> <p>This page only adds elements specific to developing with Tock connectors or creating new connectors.</p>"},{"location":"dev/connectors/#connectors-provided-with-tock","title":"Connectors Provided with Tock","text":"<p>To learn more about the connectors included with the Tock distribution, you can refer to the folder for each connector. The Multichannel Bot page lists all available connectors.</p> <p>For example, the folder connector-messenger contains the source code and the README for the Tock connector for Messenger.</p>"},{"location":"dev/connectors/#kits-based-on-the-web-connector","title":"Kits Based on the Web Connector","text":"<p>Components using the Web Connector to integrate Tock bots with other channels are available in their own GitHub repositories, alongside the main Tock repository. The Multichannel Bot page lists all available kits.</p> <p>For example, the repository <code>tock-react-kit</code> contains the source code and the README for the React kit.</p>"},{"location":"dev/connectors/#developing-your-own-connector","title":"Developing Your Own Connector","text":"<p>It is possible to create your own Tock connector, for example, to interface a Tock bot with an organization-specific channel (often a specific website or mobile application), or when a public channel opens to conversational bots and a Tock connector is not yet available.</p> <p>An example of a custom connector is available in the sample project Bot Open Data.</p> <p>To define your own connector, four steps are required:</p> <p>1) Implement the <code>Connector</code> interface  </p> <p>Here is an implementation example:</p> <pre><code>val testConnectorType = ConnectorType(\"test\")\n\nclass TestConnector(val applicationId: String, val path: String) : Connector {\n\n    override val connectorType: ConnectorType = testConnectorType\n\n    override fun register(controller: ConnectorController) {\n        controller.registerServices(path) { router -&gt;\n            // main API\n            router.post(\"$path/message\").blockingHandler { context -&gt;\n                // ConnectorRequest is the business object passed by the frontend app\n                val message: ConnectorRequest = mapper.readValue(context.bodyAsString)\n\n                // transforming the business object into a Tock Event\n                val event = readUserMessage(message)\n                // passing the event to the framework\n                val callback = TestConnectorCallback(applicationId, message.userId, context, controller)\n                controller.handle(event, ConnectorData(callback))\n            }\n        }\n    }\n\n    override fun send(event: Event, callback: ConnectorCallback, delayInMs: Long) {\n        callback as TestConnectorCallback\n        if (event is Action) {\n            // storing the action\n            callback.actions.add(event)\n            // if this is the last action to send, sending the response\n            if (event.metadata.lastAnswer) {\n                callback.sendAnswer()\n            }\n        } else {\n            logger.trace { \"unsupported event: $event\" }\n        }\n    }    \n}\n\n// to retrieve all actions before sending\nclass TestConnectorCallback(\n        override val applicationId: String,\n        val userId: String,\n        val context: RoutingContext,\n        val controller: ConnectorController,\n        val actions: MutableList&lt;Action&gt; = CopyOnWriteArrayList()): ConnectorCallbackBase(applicationId, testConnectorType) {\n\n    internal fun sendAnswer() {\n            // transforming the list of Tock responses into a business response\n            val response = mapper.writeValueAsString(actions.map { ... })\n            // then sending the response\n            context.response().end(response)\n    }\n}         \n\nImplement the ConnectorProvider interface\nHere is an implementation example:\n\nkotlin\nCopier le code\nobject TestConnectorProvider : ConnectorProvider {\n\n    override val connectorType: ConnectorType = testConnectorType\n\n    override fun connector(connectorConfiguration: ConnectorConfiguration): Connector {\n        return TestConnector(\n                connectorConfiguration.connectorId,\n                connectorConfiguration.path\n        )\n    }\n}\n\nclass TestConnectorProviderService: ConnectorProvider by TestConnectorProvider\n</code></pre> <p>3) Make this connector available via a Service Loader :</p> <p>To do this, place a file <code>META-INF/services/ai.tock.bot.connector.ConnectorProvider</code> in the classpath, containing the name of the class:</p> <p><code>mypackage.TestConnectorProviderService</code></p> <p>4) Add all the classes and files created in the classpath of the admin and the bot.</p> <p>The new connector must then be available in the interface Bot Configurations of Tock Studio.</p>"},{"location":"dev/examples-code/","title":"Tock code examples","text":""},{"location":"dev/examples-code/#examples-in-bot-samples","title":"Examples in Bot Samples","text":"<p>The tock-bot-samples repository contains code examples, including those used in Tock documentation to program journeys in WebHook or WebSocket modes.</p>"},{"location":"dev/examples-code/#the-open-data-bot","title":"The Open Data bot","text":"<p>The tock-bot-open-data repository contains an example of a bot implementation based on the SNCF Open Data API.</p> <p>This bot uses the Kotlin framework for Tock (and not the Bot API mode via Webhook or WebSocket).</p> <p>It also implements internationalization with two languages \u200b\u200boffered: French and English.</p>"},{"location":"dev/examples-code/#deploy-the-bot-with-docker","title":"Deploy the bot with Docker","text":"<p>To deploy the bot with Docker / Docker Compose, follow the instructions in the tock-docker repository.</p>"},{"location":"dev/examples-code/#deploy-the-bot-in-your-ide","title":"Deploy the bot in your IDE","text":"<p>If you prefer to deploy a Tock platform without the Open Data Bot, and run it in your IDE (allowing you to do step-by-step debugging, for example), follow these instructions:</p> <ul> <li> <p>Deploy a Tock NLU stack using the <code>docker-compose.yml</code> descriptor as explained here</p> </li> <li> <p>Request your own SNCF Open Data key (free) and configure the environment variable (see OpenDataConfiguration)</p> </li> <li> <p>Set up a connector: Messenger, Google Assistant or other (see channels and connectors)</p> </li> <li> <p>Start the <code>OpenDataBot</code> launcher in your IDE, IntelliJ or other. The bot is operational, talk to it! :)</p> </li> </ul>"},{"location":"dev/i18n/","title":"Developing a multilingual bot (i18n)","text":"<p>The Multilingual bot page of the user documentation presents the basics of internationalization (i18n) to build bots with Tock: prerequisites, Locale, etc.</p> <p>This page completes this documentation with elements specific to development.</p>"},{"location":"dev/i18n/#prerequisites","title":"Prerequisites","text":"<p>To activate internationalization in Tock, programmatically or not, see Multilingual bot.</p>"},{"location":"dev/i18n/#principles","title":"Principles","text":"<p>The code does not change once internationalization is activated. For example:</p> <pre><code>send(\"Arrival at {0}\", time)\n</code></pre> <p>is a valid code whether the module is activated or not.</p> <p>However, at runtime, the behavior differs significantly.</p> <p>If internationalization is enabled, the following operations will be performed:</p> <ol> <li> <p>A key will be generated from the text passed as a parameter, based on the namespace (the organization of the bot creator) and the story in which this label is requested. In the above case, this should look like <code>app_arrivals_Arrival at {0}</code> where app is the namespace and arrivals the main intention of the story.</p> </li> <li> <p>Tock then checks if this key is already present in the database. * If this is the case, it uses the label present in the database for the requested language in order to find the most appropriate translation (the connector or the interface type can also be taken into account)</p> </li> <li>Otherwise, a key is created in the database with the default label (\"Arrival at {0}\" in our example) used for the current language</li> <li> <p>If the text passed as a parameter is an <code>I18nLabelValue</code> object whose <code>defaultI18n</code> field contains a value for the current language, this will be used</p> </li> <li> <p>It is then possible to consult and modify this label in the administration interface:</p> </li> </ol> <p></p>"},{"location":"dev/i18n/#message-format","title":"Message format","text":"<p>The supported format is that of Java's i18n support, in particular that of the class MessageFormat in java. This includes support for ChoiceFormat:</p> <pre><code>send(\"There {0,choice,0#are no files|1#is one file|1&lt;are {0,number,integer} files}.\", 2)\n</code></pre> <p>Additionally, Tock provides a by extension for dates that allows you to specify a format in the parameters:</p> <pre><code>send(\"Departure at {0}\", departureDateTime by timeFormat)\n</code></pre>"},{"location":"dev/i18n/#user-locale","title":"User locale","text":"<p>See Multilingual bot.</p>"},{"location":"dev/i18n/#points-of-attention","title":"Points of attention","text":"<p>Tock's internationalization module is efficient, but some practices, although intuitive in Kotlin, should be banned under penalty of unpleasant surprises.</p> <p>For example, this code works perfectly well with the i18n module disabled.</p> <pre><code>send(\"There are $nb files\") //DANGER!!\n</code></pre> <p>but poses a problem if it is enabled. Indeed, a new label will be created for each different value of the variable nb!</p> <p>If it is necessary to send \"not to be translated\" responses, use the BotBus.sendRaw, BotBus.endRaw or String.raw methods</p> <pre><code>send(\"There are $nb files\".raw) //CORRECT\n</code></pre> <pre><code>send(\"There are {0} files\", nb) //FORMAT TO FOLLOW\n</code></pre> <ul> <li>The risk of collision between two labels is low since the main intention of the story is part of the key. If you want to avoid any risk, however, you can use the i18nKey method:</li> </ul> <pre><code>send(i18nKey(\"my_unique_key\", \"There are {0} files\", nb))\n</code></pre>"},{"location":"dev/i18n/#specifying-localizations-programmatically","title":"Specifying localizations programmatically","text":"<p>It is possible to define default values \u200b\u200bfor multiple localizations in a bot's code:</p> <pre><code>send(i18nKey(\"departure\", \"Departure at {0}\", setOf(I18nLocalizedLabel(Locale.FRENCH, textChat, \"D\u00e9part \u00e0 {0}\")), nb))\n</code></pre> <p>By default, these default values \u200b\u200bwill only be used when the key is used for the first time. To overwrite existing values \u200b\u200b(including those set via TOCK Studio) when the <code>defaultI18n</code> setting is changed, set the configuration value <code>tock_i18n_reset_value_on_default_change</code> to <code>true</code> (either as an environment variable or as a system property).</p>"},{"location":"dev/i18n/#testing-internationalization","title":"Testing internationalization","text":"<p>A sample test device is available in the source code of the sample bot It is necessary to extend the test extension to then indicate the label correspondence to be tested.</p> <p>All that remains is to indicate the desired locale</p> <pre><code>    @Test\n    fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context`() {\n        ext.newRequest(\"Recherche\", search, locale = Locale.FRENCH) {\n            destination = lille\n            origin = paris\n\n            run()\n\n            firstAnswer.assertText(\"when do you want to leave?\")\n        }\n    }\n</code></pre>"},{"location":"dev/modes/","title":"Developing bots with Tock","text":"<p>Tock Studio allows you to build conversational paths (or stories) including text, buttons, images, carousels, etc. To go further, it is possible to program paths in Kotlin, Javascript, Python or other languages.</p> <p> </p> <p>Two modes / frameworks / architectures are proposed:</p>"},{"location":"dev/modes/#the-bot-api-mode","title":"The Bot API mode","text":"<p>The Tock Bot API mode (recommended for most cases) allows you to develop in Kotlin or other languages \u200b\u200bwith the clients provided for Javascript/Nodejs and Python or any language using the Tock API:</p> <p></p> <p>This mode is the only one available on the Tock demo platform. It is also the only mode that allows you to develop in any programming language, via the API.</p> <p>For more information, see the Bot API page.</p>"},{"location":"dev/modes/#the-integrated-bot-mode","title":"The Integrated Bot mode","text":"<p>In this mode, you can access all the features and possibilities of the Tock framework to develop a bot.</p> <p>This is the historical development mode of Tock, and currently most of the bots published by Tock designers. are developed in this way.</p> <p>Setting up the solution is more complex than the Bot API mode and requires in particular that the bot component accesses the MongoDB database directly. It is therefore necessary to use this mode:</p> <ul> <li>To install a platform (usually with Docker) on your workstation or on a server</li> <li>To share the connection to the MongoDB database between the development workstations and the other components of the Tock platform used</li> <li>To master the programming language Kotlin</li> </ul> <p></p> <p>For more information, see the page Bot int\u00e9gr\u00e9.</p>"},{"location":"dev/test/","title":"Use the test framework","text":"<p>Tock provides extensions to test the bot unitarily.</p> <p>To use them, it is necessary to add the bot-test library to your project.</p> <p>With Maven:</p> <pre><code>        &lt;dependency&gt;\n            &lt;groupId&gt;ai.tock&lt;/groupId&gt;\n            &lt;artifactId&gt;bot-test&lt;/artifactId&gt;\n            &lt;version&gt;24.9.4&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre> <p>Or gradle :</p> <pre><code>      testCompile 'ai.tock:bot-test:24.9.4'\n</code></pre> <p>This entire framework is documented in KDoc format here.</p>"},{"location":"dev/test/#write-a-simple-test","title":"Write a simple test","text":"<p>All of the following examples use JUnit5.</p> <p>A dedicated extension for Tock and JUnit5 is available.</p> <p><pre><code>    @RegisterExtension\n    @JvmField\n    val ext = TockJUnit5Extension(bot)\n</code></pre> In order to test the greetings story of the Open Data bot, simply use the ext.send() method which allows you to obtain a mock of the conversational bus. The unit test is then written as follows:</p> <pre><code>    @Test\n    fun `greetings story displays welcome message WHEN locale is fr`() {\n        ext.send(locale = Locale.FRENCH) {\n            firstAnswer.assertText(\"Bienvenue chez le Bot Open Data Sncf! :)\")\n            secondAnswer.assertText(\"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\")\n        }\n    }\n</code></pre> <p>Since the default connector is Messenger's, it is possible to test the Messenger-specific message in the same way:</p> <pre><code>    lastAnswer.assertMessage(\n                buttonsTemplate(\n                    It is deliberately very limited, but ask him for directions or departures from a station and see the result!\n                    \":)\",\n                    postbackButton(\"Itin\u00e9raires\", search),\n                    postbackButton(\"D\u00e9parts\", Departures),\n                    postbackButton(\"Arriv\u00e9es\", Arrivals)\n                )\n            )\n</code></pre> <p>To test the message specific to Google Assistant (or any other connector), it is necessary to specify the connector that you want to test:</p> <pre><code>    ext.send(connectorType = gaConnectorType, locale = Locale.FRENCH) {\n            firstAnswer.assertText(\" Bienvenue sur le Bot Open Data Sncf !:)\")\n            secondAnswer.assertText(\" Ceci est un bot de d\u00e9monstration du framework Tock: https://github.com/theopenconversationkit/tock\")\n            lastAnswer.assertMessage(\n                gaMessage(\n                    \"C'est volontairement tr\u00e8s limit\u00e9, mais demandez-lui un itin\u00e9raire ou des d\u00e9parts d'une gare et voyez le r\u00e9sultat ! :)\",\n                    \"Routes\",\n                    \"D\u00e9parts\",\n                    \"Arriv\u00e9es\"\n                )\n            )\n        }\n</code></pre>"},{"location":"dev/test/#test-a-specific-story","title":"Test a specific Story","text":"<p>In the previous examples, it was not necessary to indicate the story to test (greetings being the default story). Let's say we want the search story, we need to specify the story to test like this:</p> <pre><code>    @Test\n    fun `search story asks for destination WHEN there is no destination in context`() {\n        ext.send(intent = search, locale = Locale.FRENCH) {\n            firstAnswer.assertText(\"P\u00f6ur quelle destination\")\n        }\n    }\n</code></pre>"},{"location":"dev/test/#testing-a-dialog","title":"Testing a dialog","text":"<p>It is possible to simulate a complete dialog. For example, we simulate here that the user indicates the destination, then the origin:</p> <pre><code>    @Test\n    fun `search story asks for origin WHEN there is a destination but no origin in context`() {\n        ext.send(\"Je voudrais rechercher un itin\u00e9raire\", search, locale = Locale.FRENCH) {\n            firstAnswer.assertText(\"Pour quelle destination?\")\n        }\n        ext.send(\"Lille\", indicate_location, locationEntity setTo lille) {\n            firstBusAnswer.assertText(\"Pour quelle origine?\")\n        }\n        ext.send(\"Paris\", indicate_location, locationEntity setTo paris) {\n            firstBusAnswer.assertText(\"Quand souhaitez-vous partir?\")\n        }\n    }\n</code></pre> <p>The text in the first parameter of the send method is simply indicative, to help understand the tests. The following parameters are used to define how the NLP will analyze the sentence. For example:</p> <pre><code>    private val lille = PlaceValue(\n        SncfPlace(\n            \"stop_area\",\n            90,\n            \"Lille Europe\",\n            \"Lille Europe (Lille)\",\n            \"stop_area:OCE:SA:87223263\",\n            Coordinates(50.638861, 3.075774)\n        )\n    )\n\n    ext.send(\"Lille\", indicate_location, locationEntity setTo lille)\n</code></pre> <p>allows to indicate that the sentence \"Lille\" is categorized as an intention indicate_location and with a value for the entity location which will be the location lille</p> <p>Finally it is possible to modify all the values \u200b\u200bof the mocked bus at initialization. In the following example, we simulate the secondary intention indicate_location in order to indicate the origin:</p> <p><pre><code>    @Test\n    fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context`() {\n        ext.newRequest(\"Recherche\", search, locale = Locale.FRENCH) {\n            destination = lille\n            origin = paris\n\n            run()\n\n            firstAnswer.assertText(\"Quand souhaitez-vous partir?\")\n        }\n    }\n</code></pre> The origin and destination variables are updated, then a call to the bus is simulated with the run() function.</p>"},{"location":"dev/advanced/bot-api/","title":"BotApi","text":"<p>The client <code>botApiClient</code> sends <code>RequestData</code> to the bot and receives <code>ResponseData</code>. The bot definition is defined by its <code>BotConfiguration</code> which builds Stories via its <code>ClientConfiguration</code></p>"},{"location":"dev/advanced/bot-api/#exchanges-with-the-botapi","title":"Exchanges with the botApi","text":""},{"location":"dev/advanced/bot-api/#botapidefinition","title":"BotApiDefinition","text":"<p>Inherits from a <code>BotDefinitionBase</code> and implements a <code>BotDefinition</code> Defines the bot in Api mode.</p> <ul> <li>Either: <pre><code>classDiagram\nBotDefinitionBase &lt;|.. BotDefinition\nBotApiDefinition &lt;|-- BotDefinitionBase\nBotDefinition : &lt;&lt;interface&gt;&gt;\nBotApiDefinition : findIntent(String,String)</code></pre></li> </ul>"},{"location":"dev/advanced/bot-api/#botconfiguration","title":"BotConfiguration","text":"<p>Contains the information present on the bot configuration (example its apikey, its name, the nlp model, the supported locations, the webhook url)</p>"},{"location":"dev/advanced/bot-api/#a-new-story-definition-and-its-handler","title":"A new story definition and its handler","text":"<pre><code>classDiagram\nStoryDefinition &lt;|.. StoryDefinitionBase\nStoryDefinitionBase ..&gt; SimpleStoryHandlerBase\nSimpleStoryHandlerBase ..|&gt; StoryDefinition\nSimpleStoryDefinition ..&gt; StoryHandlerDefinition\nStoryHandlerDefinition &lt;|.. StoryHandlerDefinitionBase~T~\nSimpleStoryHandlerBase ..&gt; SimpleStoryHandlerDefinition : create\nSimpleStoryHandlerDefinition ..|&gt; StoryHandlerDefinition\nFallbackStoryDefinition --|&gt; SimpleStoryDefinition\nFallbackStoryDefinition ..&gt; FallbackStoryHandler : create\nFallbackStoryHandler --|&gt; SimpleStoryHandlerBase\nSimpleStoryHandlerBase ..&gt; StoryDefinition\nStoryHandlerBase~T~ &lt;|-- SimpleStoryHandlerBase\nStoryDefinition ..&gt; StoryHandler\nFallbackStoryDefinition ..&gt; StoryHandler\nStoryHandler &lt;|.. StoryHandlerBase~T~\nStoryDefinition : &lt;&lt;interface&gt;&gt;\nStoryHandler : &lt;&lt;interface&gt;&gt;</code></pre>"},{"location":"dev/advanced/collections/","title":"The Tock collections","text":""},{"location":"dev/advanced/collections/#tock_bot-and-tock_bot_test","title":"tock_bot and tock_bot_test","text":"collection description class action_nlp_stats ? statistics of pre-recorded actions? NlpStatsCol archived_entity_values \u200b\u200b ? value of preserved entities? ArchivedEntityValuesCol bot Identity of bots BotConfiguration bot_configuration Configuration of bots with for example the configurations of connectors, the associated urls etc. BotApplicationConfiguration connector_message Stores for example the quickreplies/categories exchanged from the connector ConnectorMessageCol dialog Contains the general information of the dialog thread with the bot: the transmitters/receivers, the state of the conversation in the thread, the triggered stories and their contents with the actions of the bot and the user actions. DialogCol dialog_snapshot Contains a snapshot of the threads with the ID of the stories and entities saved and triggered SnapshotCol dialog_text Contains the textual exchanges sent by the users DialogTextCol feature Contains the configurations to for example disable/enable a bot or the features in <code>Stories &amp; Answers/Rules/Application Features</code> Feature flow_state Concerns the analytics information: defines the different states that can be reached, the storyType (ex: builtin) DialogFlowStateCol flow_transition Concerns the analytics information: Defines the transitions between the intentions DialogFlowStateTransitionCol flow_transition_stats Concerns the analytics information: Lists the utterances to be counted DialogFlowStateTransitionStatCol i18n_alternative_index Defines alternatives in different languages \u200b\u200bfor an i18n label? I18nAlternativeIndex i18n_label Defines i18n labels for bot responses I18nLabel i18n_label_stat Label usage statistics I18nLabelStat story_configuration Story configuration, intent name, handler type class, step definition, children StoryDefinitionConfiguration story_configuration_history Story configuration history? StoryDefinitionConfigurationHistoryCol test_plan Test plan, defined via a copy of a Dialog and has the target connector type TestPlan test_plan_execution Test plan statistics executed: indicates the number of errors, execution time, status (example COMPLETE) TestPlanExecution user_lock ? User lock status management UserLock user_timeline User information relative to <code>Analytics/users</code> UserTimelineCol"},{"location":"dev/advanced/collections/#tock_front","title":"tock_front","text":"<p>Related to editable information in the front</p> collection description class DTO application_definition Application configuration: name, languages, nlp type ApplicationDefinition classified_sentence Information of a Sentence declared in Tock and the NLP classification, its status (to review, unknown) ClassifiedSentenceCol dictionary_data Dictionary of data related to custom defined entities, can contain predefined values \u200b\u200b example: export <code>{\"namespace\":\"app\",\"entityName\":\"test\",\"values\":[{\"value\":\"donn\u00e9esA\",\"labels\":{\"fr\":[\"label1\",\"label2\"]}}],\"onlyValues\":false,\"minDistance\":0.5,\"textSearch\":false}</code>  Configurable in <code>Language Understanding/Entities</code> DictionaryData entity_test_error ? Related to entity testing EntityTestError entity_type_definition Entity class configuration example: duckling EntityTypeDefinition intent_definition Definition of intents with information such as entities, sharedIntents, which application they are related to IntentDefinition intent_test_error ? Related to intent testing IntentTestError model_build ? Related to <code>Trigger Build</code> advanced options in `Settings//Edit/Advanced Options ModelBuild model_build_trigger ? Related to <code>Trigger Build</code> advanced options in `Settings//Edit/Advanced Options ModelBuildTrigger parse_request_log Query parsing log with NLP classification specific information ParseRequestLog parse_request_log_intent_stats Query parsing log with NLP classification specific information between multiple intents ParseRequestLogIntentStat parse_request_log_stats Query stats against text expressing the number of times it was called, the intentProbability and the entitiesProbability ParseRequestLogStat test_build ? build for the botApi ? TestBuild user_action_log Logs of user actions in the interface (example: update of a configuration, creation/update of an intent) UserActionLog user_namespace Definition of the different users of the interface UserNamespace"},{"location":"dev/advanced/collections/#tock_model","title":"tock_model","text":"<p>Probably for downloading and exporting data from Tock.</p> collection description class fs_entity.chunks Chunks of entity data defined in NlpEngineModelMongoDAO fs_entity.files Different files for different bots for entities defined in NlpEngineModelMongoDAO fs_intent.chunks Chunks of intent data defined in NlpEngineModelMongoDAO fs_intent.files Different files for different bots for intents defined in NlpEngineModelMongoDAO nlp_application_configuration Contains the configuration present in the advanced options in <code>Settings/&lt;Application&gt;/Edit/Advanced Options</code> NlpApplicationConfigurationCol"},{"location":"dev/advanced/main-classes-explanation/","title":"Main classes explanation","text":"<p>Le projet est constitu\u00e9 de divers modules, les modules principaux concerne le moteur <code>tock-bot-engine</code></p>"},{"location":"dev/advanced/main-classes-explanation/#story","title":"Story","text":"<p>Une Story est un bout de conversation \u00e0 propos d'un sujet pr\u00e9cis. Elle est li\u00e9e au minimum a une intention (intent) - la StarterIntent</p> <p>Pas de service \"s\u00e9lection de story\" comme il peut y avoir une biblioth\u00e8que de lecture du scxml pour la machine \u00e0 \u00e9tat, le routage des story fait partie du moteur de mani\u00e8re g\u00e9n\u00e9rale.</p>"},{"location":"dev/advanced/main-classes-explanation/#pre-defined-story-slot","title":"Pre-defined story slot","text":"<p>Ce sont StoryDefinition appel\u00e9es \u00e0 divers moments dans le bot en-dehors du flux classique, g\u00e9n\u00e9ralement pour une action sp\u00e9cifique. - unknownStory : Story par default si aucune intention n'est d\u00e9tect\u00e9e - keywordStory  : Si un mot clef est reconnu dans le message utilisateur, court-circuit le NLP et lance directement cette story - helloStory        : Lanc\u00e9e au d\u00e9marrage du bot - goodbyeStory  : Lanc\u00e9e \u00e0 la sortie du bot - noInputStory   : ? appel\u00e9e si l'utilisateur est inactif - userLocationStory : Story utilis\u00e9e pour l'action SendLocation - handleAttachmentStory : Story utilis\u00e9e pour l'action SendAttachment - keywordStory : Story utilis\u00e9e pour bypass la NLP avec des mots cl\u00e9s</p>"},{"location":"dev/advanced/main-classes-explanation/#piece-jointes","title":"Pi\u00e8ce jointes","text":"<p>Tock prend un comportement sp\u00e9cifique pour les pi\u00e8ces jointes. Dans le cas de la r\u00e9ception d'une pi\u00e8ce jointe le bot attend du connecteur une action SendAttachment. Le NLP est alors court-circuit\u00e9</p>"},{"location":"dev/advanced/main-classes-explanation/#switchstory","title":"SwitchStory","text":"<p>Il est possible de basculer automatiquement d'une Story \u00e0 une autre depuis une story gr\u00e2ce \u00e0 BotBus::switchStory(StoryDefinition). La story est ajout\u00e9 au dialog comme derni\u00e8re story et son intention principale est d\u00e9finit comme intention courante. Basculer d'une Story \u00e0 une autre n'a pas de sens pour la machine \u00e0 \u00e9tat, les changements sont effectu\u00e9s, par d\u00e9finition, par l'interm\u00e9diaire d'une transition jamais d'\u00e9tat \u00e0 \u00e9tat. En mettant en place le syst\u00e8me d'\u00e9v\u00e9nements internes il est possible d'avoir un comportement similaire avec la machine \u00e0 \u00e9tat, l'\u00e9v\u00e9nement d\u00e9clenche la transition dans la machine \u00e0 \u00e9tat qui d\u00e9clenche la Story correspondante.</p>"},{"location":"dev/advanced/main-classes-explanation/#intent-story-id","title":"Intent = Story Id","text":"<p>Le Bot utilise l'intention courante pour faire le lien directement avec la StoryDefinition \u00e0 ex\u00e9cuter, le NlpController utilise la liste de story pour v\u00e9rifier si l'intent est support\u00e9e par le bot,</p>"},{"location":"dev/advanced/main-classes-explanation/#bot","title":"Bot","text":"<p>Controller pour le comportement du bot. Fait appel \u00e0 la partie NLP (si besoin) pour trouver l'intention et les entit\u00e9s \u00e0 partir d'un message et execute la story correspondant \u00e0 l'intention. Pour trouver la Story un lien directe est fait entre Story et intention.</p>"},{"location":"dev/advanced/main-classes-explanation/#nlp-nlpcontroller-impl","title":"Nlp (NlpController impl)","text":"<p>Controller pour la partie NLP. Fait appel au NLP pour identifier l'intention et les entit\u00e9s d'un message et les enregistre dans le Dialog. V\u00e9rifie gr\u00e2ce \u00e0 <code>BotDefinition::findIntent</code> si une intention retourn\u00e9e par le  NLP est connue du bot, transmet <code>Intent::unknown</code> si ce n'est pas le cas.</p>"},{"location":"dev/advanced/main-classes-explanation/#technico-fonctionnel-tock","title":"Technico-fonctionnel Tock","text":""},{"location":"dev/advanced/main-classes-explanation/#usertimeline","title":"UserTimeline","text":"<p>Contient les informations du dialogue et les donn\u00e9es utilisateurs. Contient la derni\u00e8re Action du dialog (bot) et la derni\u00e8re UserAction (user) Action</p>"},{"location":"dev/advanced/main-classes-explanation/#dialog","title":"Dialog","text":"<p>Repr\u00e9sente la conversation entre l'utilisateur et le ou les bots. Dispose d'un objet DialogState qui semble int\u00e9ressant pour introduire l'\u00e9tat de la machine \u00e0 \u00e9tat afin d'\u00eatre r\u00e9trocompatible.</p>"},{"location":"dev/advanced/main-classes-explanation/#definitionbuilders","title":"DefinitionBuilders","text":"<p>Regroupe des fonctions utilitaires pour instancier de nouvelles definition de Bot et Story. Pour les Stories utilise l'interface IntentAware pour faire le lien entre divers intentions pr\u00e9-d\u00e9finies  et la StoryDefinition qui sera ex\u00e9cut\u00e9e. Utilise les intentions pour r\u00e9cup\u00e9rer la story correspondante. Dokka - Bot Api Client <code>ClientDefintionBuilders</code> - Bot Engine <code>DefinitionBuilders</code></p> <p>Peut-\u00eatre utile pour cr\u00e9er des d\u00e9finitions de FAQ simples ou scenarii qui seront instanci\u00e9es c\u00f4t\u00e9 client.</p>"},{"location":"dev/advanced/main-classes-explanation/#les-classes-definitions","title":"Les classes definitions :","text":"<ul> <li>Bot engine :  Ce sont les abstractions qui d\u00e9finissent les objets principaux (d\u00e9finis dans l'engine) du chatbot Tock et utilis\u00e9s dans le Dialog Manager, il y a notamment <code>StoryDefinition</code>,<code>BotDefinition</code> C'est ici le plus int\u00e9ressant si on souhaite ajouter de nouvelles fonctionnalit\u00e9s r\u00e9troactives \u00e0 l'ensemble du chatbot.  Les impl\u00e9mentations par d\u00e9faut sont <code>BotDefinitionBase</code> et <code>StoryDefinitionBase</code>.</li> <li>Bot Api Client :   Ce sont les impl\u00e9mentations utilis\u00e9es lors de l'instance d'un bot Api Client :   <code>ClientStoryDefinition</code>, <code>ClientBotDefinition</code> qui cr\u00e9e des <code>StoryConfiguration</code> et <code>BotConfiguration</code> lors de leur instanciantion.</li> <li>NOTE : Les d\u00e9finitions entre l'engine et le client sont diff\u00e9rentes. L'engine (en mode int\u00e9gr\u00e9) dispose de plus de pr\u00e9defined story slots dans <code>BotDefinitionBase</code>, cf plus haut)</li> <li> <p>Sinon il peut-\u00eare utile de surcharger le <code>BotApiDefinition</code> qui impl\u00e9mente un BotDefinitionBase sp\u00e9cfique.</p> </li> <li> <p>NLP Front Shared D\u00e9finition des objets dans le front : <code>ApplicationDefinition</code>, <code>IntentDefinition</code>, <code>EntityDefinition</code></p> </li> </ul>"},{"location":"dev/advanced/main-classes-explanation/#storydefinition","title":"StoryDefinition","text":"<p>Interface pour les objets qui porteront le code m\u00e9tier. Une StoryDefinition d\u00e9finit les actions effectu\u00e9es lors de l\u2019ex\u00e9cution d'une Story. Porte la liste des intentions primaires support\u00e9es par une story, la liste compl\u00e8te des intentions support\u00e9es par la story. Propose la v\u00e9rification du support d'une intention ou si elle est une intention primaire. Expose l'intention de r\u00e9f\u00e9rence.</p>"},{"location":"dev/advanced/main-classes-explanation/#storydefinitionbase","title":"StoryDefinitionBase","text":"<p>Impl\u00e9mentation abstraite de StoryDefinition</p>"},{"location":"dev/advanced/main-classes-explanation/#storystep","title":"StoryStep","text":"<p>Une \u00e9tape dans l'ex\u00e9cution d'une Story. Les Steps d\u00e9finissent les diff\u00e9rents comportements d'une Story au cours des ex\u00e9cutions successives ou d'intentions diff\u00e9rentes. Les Steps reprennent les m\u00eame intentions que leur Story et ont une structure similaire avec une liste d'intentions primaires et secondaire et une intention (facultative) principale.</p>"},{"location":"dev/advanced/main-classes-explanation/#botbus","title":"BotBus","text":"<p>Porte le flux d'information d'une ex\u00e9cution du bot suite \u00e0 un message utilisateur. Un Bus est instanci\u00e9 \u00e0 chaque message. Porte l'ensemble des donn\u00e9es pertinentes \u00e0 l'ex\u00e9cution du workflow, y compris le Dialog, la UserTimeline, la Story courante, les entit\u00e9es et l'action de l'utilisateur. Expose l'API de r\u00e9ponses du bot. \u00c9tendu par les connecteurs pour ajouter des r\u00e9ponses sp\u00e9cifiques</p>"},{"location":"dev/advanced/main-classes-explanation/#storystep_1","title":"StoryStep","text":"<p>Le moteur de Tock propose le m\u00e9canisme de step, les Step correspondent \u00e0 une \u00e9tape dans l'ex\u00e9cution d'une Story et une Story peut passer d'une Step \u00e0 une autre selon des crit\u00e8res arbitraires comme l'intention courante ou le nombre d'ex\u00e9cution de la Story. Les Step sont structur\u00e9es comme les Story avec des intentions primaires et secondaires et une intention principale mais celles-ci sont facultatives. Si des intentions sont d\u00e9finit pour une Step elle sera ex\u00e9cut\u00e9 automatiquement, si une intention principale est d\u00e9finit le bot basculera automatiquement vers la Story correspondante. Les Step peuvent aussi contenir des Step enfant permettant de faire des stepceptions. Les Step n'ont pas d'\u00e9quivalent c\u00f4t\u00e9 machine \u00e0 \u00e9tat, les \u00e9tats sont normalement d\u00e9j\u00e0 la plus petite unit\u00e9 d'ex\u00e9cution dans la machine \u00e0 \u00e9tat.</p>"},{"location":"dev/advanced/packages/","title":"Explication des packages Tock","text":""},{"location":"dev/advanced/packages/#bot-tock-bot-regroupe-lensemble-qui-definit-un-bot","title":"Bot : (tock-bot) regroupe l'ensemble qui d\u00e9finit un bot","text":"<pre><code>\u251c\u2500\u2500 bot : \n\u2502\u00a0\u00a0 \u251c\u2500\u2500 admin : Li\u00e9 \u00e0 l'interface Tock studio\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 kotlin-compiler : (facultatif) : compilateur de scripts pour les saisir directement dans l'interface [_Stories and Answers_] du Studio\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 server : backend de lancement du studio\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 test : g\u00e8re les plans de tests du studio\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 web : front du studio en Angular qui concerne notamment les \u00e9crans pour la partie analytics bot, et le squelette des \u00e9crans de configuraion\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 api : bot en mode Api\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 client : classes/interfaces et d\u00e9finitions de base du client Bot Api\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 model : Dto du BotApi\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 retrofit-jackson-client : gestion des mappers Jackson via le type-safe HTTP Retrofit\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 service : Defintion des services pour le bot Api qui contient BotApiService, BotApiDefinition, BotApiClient, BotApiHandler et le d\u00e9marrage du botApi\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 webhook : jar du mode webhook\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 webhook-base : base de lancement et definition Verticle du mode Webhook\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 websocket : jar du mode websocket\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 websocket-base : base de lancement et definition du mode Websocket\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 chatbase : gestion du lien avec chatbase (https://www.chatbase.com/), \u00e9teint depuis 27 sept 2021\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 connector-alexa : impl\u00e9mentation du connecteur \u00e0 Alexa \n\u2502\u00a0\u00a0 \u251c\u2500\u2500 connector-businesschat: impl\u00e9mentation du connecteur \u00e0 Business Chat\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 connector-ga : impl\u00e9mentation du connecteur \u00e0 Google Assistant\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 connector-google-chat : impl\u00e9mentation du connecteur \u00e0 Google Chat\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 connector-messenger : impl\u00e9mentation du connecteur \u00e0 Messenger\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 connector-rest : impl\u00e9mentation d'un connecteur rest de base\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 connector-rest-client : impl\u00e9mentation d'un connecteur client rest de base (utilis\u00e9 dans les tests)\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 connector-rocketchat : impl\u00e9mentation d'un connecteur Rocketchat\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 connector-slack : impl\u00e9mentation d'un connecteur Slack\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 connector-teams : impl\u00e9mentation d'un connecteur Teams\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 connector-twitter : impl\u00e9mentation d'un connecteur Twitter\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 connector-web : impl\u00e9mentation du connecteur Web dans le studio\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 connector-web-model : D\u00e9finition des types de mod\u00e8les d'\u00e9changes web, exemple via Bouton, QuickReply, Image, Carousel, Message, etc.\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 connector-whatsapp impl\u00e9mentation du connecteur Watsapp\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 dialogflow : impl\u00e9mentation de la gestion de NLP d\u00e9l\u00e9gu\u00e9 via DialogFlow\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 engine : Moteur du bot o\u00f9 sont d\u00e9finit l'ensemble des objets conceptuels et fonctionnels de Tock, soit du mode tock Integr\u00e9, du DialogManager, des Connecteurs, du Bot, des Stories etc.\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 admin : d\u00e9fintion du moteur du bot admin compos\u00e9s des organes de l'arborescence ci-dessous :\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 answer : DTO des r\u00e9ponses dans le studio (simple, message, script, builtin)\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 bot : DTO de configuration de Bot et Version du studio\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 dialog : DTO sur les statistiques du dialog\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 message : DTO de type de message\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 story : DTO li\u00e9s aux story et interface de DAO pour g\u00e9rer les stories\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 dump DTO d'export dump de story\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 test : DTO et DAO li\u00e9s aux TestPlan et TestExecution /rest/admin/application/plans\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 user : DTO et DAO li\u00e9s aux analytics utilisateurs `/rest/admin/users/search`\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 connector : \n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 media : Messages de types m\u00e9dias (contiennent plus qu'un simple text et peuvent \u00eatre transform\u00e9s par le connecteur), exemple carousel, carte, ou encore fichier\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 definition : package de definition des classes abstraites et interfaces de BotDefinition, Story, Handler, Steps, EventListener, etc., tous les aspects socles du DialogManager, TestBehavior\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 engine : Coeur du moteur de Tock avec Bot, Bus, ConnectorController et les diff\u00e9rents aspects ci-dessous\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 action : abstraction d'une Action (user ou bot), enum de type d'actions, et classes d'impl\u00e9mentation des diff\u00e9rents types d'actions (sendSentence, sendLocation, sendChoice, SendAttachment)  \n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 config : classes et m\u00e9thodes de configuration/ refresh de bots\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 dialog : DTO et m\u00e9thodes pour influer, r\u00e9cup\u00e9rer des informations sur le d\u00e9roulement du dialog avec notamment les Story, les Entities, l'\u00e9tat / state de la conversation. \n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 event :  Package regroupant la d\u00e9finition absraite d'un \u00e9v\u00e8nement dans Tock et les impl\u00e9mentations de diff\u00e9rents types d'\u00e9v\u00e8nements : exemple Login, Login, EndConversation, StartConversation \n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 feature : Gestion des features du bot par exemple ACtivation/D\u00e9sactivation de bot\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 message : D\u00e9finition des diff\u00e9rents types de messages (Sentence,Suggestion,Location,Choice, Attachment, etc.) qui vont ensuite \u00eatre pars\u00e9s dans la partie NLP\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 parser : m\u00e9thodes simples de parsing de DSL pour les diff\u00e9rents types de messages\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 monitoring : Tra\u00e7age du Timer sur les requ\u00eates\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 nlp : D\u00e9fintion des processus de traitement Nlp avec l'interface NLPController, NlpListener et NLPCallStats. \n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 stt : Helpers et M\u00e9thodes pour surcharger les r\u00e9sultats du speech to text\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 user : Toutes les informations utilisateurs o\u00f9 liaison du dialog \u00e0 un utilisateur (UserTimeline)\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 engine-jackson: bindings avec Jackson\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 orchestration : gestion d'orchestration entres diff\u00e9rents bots (principaux et secondaires)?\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 storage-mongo : d\u00e9fintion de la base mongo et de ses DAO\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 test : jar du test-base de tock\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 test-base : Socle pour les tests avec mocks et d\u00e9fintions pour junit\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 toolkit : Toolkit-base et avec connecteurs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 toolkit-base : D\u00e9claration de m\u00e9thodes d'installations de bot dans le code et des Iocs de base. \"Bot Toolkit - to build chatbots with ease\", ici sans connecteur\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 xray : Plugin de test automatis\u00e9 xray utilisable notamment avec Jira\n</code></pre>"},{"location":"dev/advanced/packages/#docs-et-dokka-documentation-de-tock","title":"Docs et dokka : Documentation de Tock","text":"<pre><code>\u251c\u2500\u2500 docs \n\u2502\u00a0\u00a0 \u251c\u2500\u2500 api : documentation rest de l'admin, du nlp  aux formats yaml et swagger\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _data : internationnalisation de la doc tock\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 dokka : format dokka html pour la doc\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 tock\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _en : doc anglais au format markdown\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _fr : doc fran\u00e7ais au format markdown\n\u251c\u2500\u2500 dokka : documentation via Dokka : permet d'afficher des markdown au format html\n</code></pre>"},{"location":"dev/advanced/packages/#etc-scripts-de-deploiement-et-process-lies-au-deploiement-open-source","title":"Etc : scripts de d\u00e9ploiement et process li\u00e9s au d\u00e9ploiement open source","text":"<pre><code>\u251c\u2500\u2500 etc : scripts de d\u00e9ploiement documentation markdown li\u00e9s au d\u00e9ploiement\n</code></pre>"},{"location":"dev/advanced/packages/#nlp-tock-nlp-definition-du-moteur-de-nlp-de-tock","title":"Nlp (tock-nlp) : D\u00e9finition du moteur de NLP de Tock","text":"<pre><code>\u251c\u2500\u2500 nlp : D\u00e9finition du moteur de NLP de Tock\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 admin : nlp-admin partie nlp du mode admin\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 server : backend sur la partie admin nlp\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 web : frontend sur l'ensemble des \u00e9crans li\u00e9s \u00e0 la nlp, l'entrainement, les tests etc. Coeur des process front.\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 api : D\u00e9finition de controllers, services et doc swagger pour l'Api Nlp\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 client : D\u00e9finition de controllers pour le Nlp\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 doc : swagger mode api\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 service : Verticle Nlp et launcher NlpService\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 build-model-worker : contient des classes utilis\u00e9es pour builder les mod\u00e8les NLP\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 build-model-worker-on-aws-batch : sur un batch aws\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 build-model-worker-on-demand : sur une plateforme \u00e0 la demande\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 core : Coeur de service Nlp\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 client : Interface cliente pour les points d'entr\u00e9e de Tock NLP\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 service : Classes sur les Dictionnaires et les Entit\u00e9s et DTO d'\u00e9valuation de r\u00e9sultat de NLP\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 shared : DTO et interface utilis\u00e9es dans le module NLP\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 entity-evaluator : evaluateur/classificateur d'entit\u00e9s NLP\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 duckling : d\u00e9finition duckling\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 entity-value : d\u00e9fintion d'entit\u00e9s par d\u00e9faut exemple Email, num\u00e9ro de t\u00e9l\u00e9hone, distance, date, temp\u00e9rature, url etc.\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 rest : connecteur rest de la classification NLP\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 front : classes li\u00e9es au NLP en front\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 client\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ioc : ioc de modules pour le Front\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 service : D\u00e9finition d'interface de DAO, et de service pour la gestion de la NLP en front\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 shared : DTOs li\u00e9s au Front et pour les dumps\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 storage-mongo : les DAO mongo li\u00e9es au frontend\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 integration-tests : test d'integration nlp\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 model : Package li\u00e9 aux diff\u00e9rents mod\u00e8les de NLP\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 client : client pour des op\u00e9rations sur les mod\u00e8le de NLP\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 opennlp : moteur de NLP OpenNlp\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 rasa : moteur de NLP Rasa\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 service : classes pour impl\u00e9menter un nouveau moteur de NLP\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 shared : classes partag\u00e9es DTO \n\u2502\u00a0\u00a0     \u2514\u2500\u2500 storage-mongo : Enregistrement dans la base mongo des diff\u00e9rentes types de libraries d\u00e9tection Nlp\n</code></pre>"},{"location":"dev/advanced/packages/#scripts","title":"Scripts :","text":"<pre><code>\u251c\u2500\u2500 scripts : scripts li\u00e9es aux tokens d'acc\u00e8s sur Messenger\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 connector-messenger\n</code></pre>"},{"location":"dev/advanced/packages/#shared-classes-partagees-et-utilitaires","title":"Shared : classes partag\u00e9es et utilitaires","text":"<pre><code>\u251c\u2500\u2500 shared : Avec notamment VertX, Jackson, Mongo, des Provider de s\u00e9curit\u00e9s (ex : AWS, Github)\n</code></pre>"},{"location":"dev/advanced/packages/#stt-et-translator-speech-to-text-et-translator-pour-linternationalisation-i18n-des-reponses","title":"Stt et translator : Speech to text et translator pour l'internationalisation (i18n) des r\u00e9ponses","text":"<pre><code>\u251c\u2500\u2500 stt : Support du speech to text de google\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 core : coeur du code de speech to text\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 google-speech : d\u00e9l\u00e9gation d'appel \u00e0 google speech\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 noop : impl\u00e9mentation du stt sans op\u00e9ration\n\u2514\u2500\u2500 translator : Support de l'internationalisation des r\u00e9ponses\n    \u251c\u2500\u2500 core : coeur du code du translate et des I18n\n    \u251c\u2500\u2500 google-translate : d\u00e9l\u00e9gation d'appel \u00e0 google translate\n    \u2514\u2500\u2500 noop : impl\u00e9mentation de la traduction sans op\u00e9ration\n</code></pre>"},{"location":"dev/advanced/nlp/nlp-evaluation-with-duckling-and-dictionary%20%28%20end%20of%20file%29/","title":"Nlp evaluation with duckling and dictionary ( end of file)","text":"<p>```mermaid sequenceDiagram     Note over NlpVerticle : override configure</p> <pre><code>NlpVerticle-&gt;&gt; ParserService: parse(query) &lt;br&gt; ParseQuery(queries=[Je veux 2 cookies au chocolat], namespace=app, applicationName=..., context=QueryContext(language=fr..)\nactivate ParserService\nParserService -&gt;&gt; ParserService: parse(query: ParseQuery, metadata: CallMetadata) : ParseResult\nNote over ParserService : formatage de requete si tabulation/ s\u00e9lection de la premi\u00e8re\nParserService -&gt;&gt; ParserService: formatQuery(query: string, metadata: CallMetadata) : ParseResult\nNote over ParserService,ApplicationConfiguration : Recherche si la sentence est d\u00e9j\u00e0 valid\u00e9e\nParserService -&gt;&gt; ApplicationConfiguration:  \nApplicationConfiguration --&gt;&gt; ParserService:  validatedSentences\nNote over ParserService,ConfigurationRepository : R\u00e9cup\u00e8re les intentDefinition selon l'application id\nParserService -&gt;&gt; ConfigurationRepository: \nConfigurationRepository --&gt;&gt; ParserService: intents\ndeactivate ParserService\n\nactivate ParserService\nNote over ParserService,IntentSelectorService : V\u00e9rification si on a bien une phrase classifi\u00e9 (intent et/ou entit\u00e9s reconnues)\nalt isValidClassifiedSentence\nParserService -&gt;&gt; IntentSelectorService: isValidClassifiedSentence(data: ParserRequestData)\n\nNote over ParserService,NlpCore : Evaluation des entit\u00e9s\nactivate NlpCoreService\nParserService-&gt;&gt; NlpCoreService: evaluateEntities()\nNlpCoreService-&gt;&gt;NlpCoreService: evalutate\n\ndeactivate NlpCoreService\ndeactivate ParserService\n\nelse\nactivate NlpCoreService\nactivate ParserService\nParserService-&gt;&gt; NlpCoreService: parse()\nNote over NlpCoreService : Pr\u00e9paration du texte par rapport \u00e0 un nb de charact\u00e8res maxi (50000)\nNlpCoreService-&gt;&gt;NlpCoreService: prepareText\n\nNote over NlpCoreService,NlpClassifierService : Reconnaissance des entit\u00e9s et de l'intention par la NLP via le moteur de NLP (OpenNLP ou autre)\nNote over NlpCoreService,NlpClassifierService : Recup\u00e8re le type de classifieur pour l'intent (classifieur = mod\u00e8le ou type de mod\u00e8le NLP) et classifie l'intention via le mod\u00e8le\nNlpClassifierService-&gt;&gt; NlpEngineRepository: getIntentClassifier\nNlpClassifierService --&gt;&gt; NlpCoreService : IntentClassification\n\nNlpCoreService-&gt;&gt; NlpClassifierService: classifyEntities(context: EntityCallContext,text: String)\nNote over NlpCoreService,NlpEngineRepository : Recup\u00e8re le type de classifieur (via le provider ) pour l'entit\u00e9\nNlpClassifierService-&gt;&gt; NlpEngineRepository: getEntityClassifier\nNlpClassifierService --&gt;&gt; NlpCoreService : List&lt;EntityRecognition\n\nNote over NlpCoreService : Parsing de l'intention et des entit\u00e9s qualifi\u00e9es pr\u00e9c\u00e9demment\nNlpCoreService-&gt;&gt;NlpCoreService: parse\nNlpCoreService-&gt;&gt;NlpCoreService: parse internal\n\nNote over NlpCoreService : selection de l'intention et de sa probabilit\u00e9\nNlpCoreService-&gt;&gt;IntentSelector: selectIntent\nIntentSelector--&gt;&gt;NlpCoreService : Intent,probability\n\nNote over NlpCoreService : Evaluation et classification des entit\u00e9s en double Array[evaluatedEntities, notRetainedEntities]\nloop\n    NlpCoreService-&gt;&gt;NlpCoreService: classifiyAndEvaluate\n    NlpCoreService-&gt;&gt;NlpCoreService: evaluateEntities\n\n    Note over NlpCoreService : Evaluation des entit\u00e9s reconnues\n    NlpCoreService-&gt;&gt;EntityCoreService: evaluateEntities\n\n    Note over EntityCoreService : R\u00e9cup\u00e8re le type d'entity provider parmis ceux dispnobiles (Duckling, Dictionnary)\n    EntityCoreService-&gt;&gt;EntityCoreService: getEntityEvaluator\n    NlpCoreService-&gt;&gt;EntityCoreService: evaluate\n    Note over EntityCoreService : Appelle le evaluate dans le parser sp\u00e9cifique (DucklingParser ou DictionnaryEntityTypeEvaluator)\n    EntityCoreService-&gt;&gt;EntityCoreService: evaluate\n    EntityCoreService--&gt;&gt;EntityCoreService: EvaluationResult\n\n    EntityCoreService--&gt;&gt;NlpCoreService: List&lt;EntityRecognition&gt;\n\n        alt (mergeEntitytype &amp;&amp; classifyEntityTypes) == true &amp;&amp; classifiedEntityTypes &gt; 0\n        Note over NlpCoreService,EntityCoreService : Evaluation des diff\u00e9rents types de contexte d'entit\u00e9s (EntityCallContextForIntent,EntityCallContextForEntity,EntityCallContextForSubEntities) selon les providers (Duckling ou autre)\n        NlpCoreService-&gt;&gt;EntityCoreService: classifyEntityTypes\n        EntityCoreService --&gt;&gt;NlpCoreService: List&lt;EntityTypeRecognition&gt;\n\n        Note over NlpCoreService : V\u00e9rification du support de la classification pour les providers d\u00e9tect\u00e9s et enl\u00e8vement de doublons \u00e9ventuels\n        NlpCoreService-&gt;&gt;NlpCoreService: classifyEntityTypesForIntent\n\n        Note over NlpCoreService : Evaluation des entit\u00e9s reconnues via Duckling\n        NlpCoreService-&gt;&gt;DucklingParser: classifyEntities\n        activate DucklingParser\n        DucklingParser-&gt;&gt;DucklingParser : classifyforIntent\n        DucklingParser--&gt;&gt;NlpCoreService: List&lt;EntityTypeRecognition&gt;\n        deactivate DucklingParser\n\n    end\n    alt mergeEntityType == true\n\n        Note over NlpCoreService : Gestion du merge des entit\u00e9s selon poids de reconnaissance\n        NlpCoreService-&gt;&gt; EntityMergeService: mergeEntityTypes\n        EntityMergeService--&gt;&gt;NlpCoreService: List&lt;EntityTypeRecognition&gt;\n\n    end\n\nend\n\n\nNlpCoreService--&gt;&gt;ParserService: ParsingResult\n\nNote over ParserService,ParseRequestLogDao : Sauvegarde du Dao\nParserService-&gt;&gt; ParseRequestLogDao: save\ndeactivate ParserService\ndeactivate NlpCoreService\n\n\n\nend\n</code></pre>"},{"location":"dev/advanced/nlp/nlp-intents-and-entities-evaluation-simplifed-diagram/","title":"Nlp intents and entities evaluation simplifed diagram","text":"<pre><code>sequenceDiagram\n    Note over NlpVerticle : override configure\n\n    NlpVerticle-&gt;&gt; ParserService: parse(query) &lt;br&gt; ParseQuery(queries=[Je veux 2 cookies au chocolat], namespace=app, applicationName=..., context=QueryContext(language=fr..)\n    activate ParserService\n    ParserService -&gt;&gt; ParserService: parse(query: ParseQuery, metadata: CallMetadata) : ParseResult\n    deactivate ParserService\n\n    activate ParserService\n\n    Note over ParserService,IntentSelectorService : V\u00e9rification si on a bien une phrase classifi\u00e9 (intent et/ou entit\u00e9s reconnues)\n    alt isValidClassifiedSentence\n    ParserService -&gt;&gt; IntentSelectorService: isValidClassifiedSentence(data: ParserRequestData)\n\n    Note over ParserService,NlpCoreService : Evaluation des entit\u00e9s\n    activate NlpCoreService\n    ParserService-&gt;&gt; NlpCoreService: evaluateEntities()\n    NlpCoreService-&gt;&gt;NlpCoreService: evalutate\n\n    deactivate NlpCoreService\n    deactivate ParserService\n\n    else\n    activate NlpCoreService\n    activate ParserService\n    ParserService-&gt;&gt; NlpCoreService: parse()\n\n    Note over NlpCoreService,NlpClassifierService : Reconnaissance des entit\u00e9s et de l'intention par la NLP via le moteur de NLP (OpenNLP ou Rase)\n    NlpCoreService-&gt;&gt; NlpClassifierService: classifyIntents\n    NlpClassifierService--&gt;&gt;NlpCoreService : IntentClassification\n    Note over NlpCoreService,NlpClassifierService : Recup\u00e8re le type de classifieur (via le provider ) pour l'entit\u00e9 (classifieur = mod\u00e8le ou type de mod\u00e8le NLP) et classifie l'entit\u00e9\n    NlpCoreService-&gt;&gt; NlpClassifierService: classifyEntities(context: EntityCallContext,text: String)\n    NlpClassifierService--&gt;&gt;NlpCoreService : List&lt;EntityRecognition&gt;\n\n    Note over NlpCoreService : Parsing de l'intention et des entit\u00e9s qualifi\u00e9es pr\u00e9c\u00e9demment\n    NlpCoreService-&gt;&gt;NlpCoreService: parse\n\n    Note over NlpCoreService : selection de l'intention et de sa probabilit\u00e9\n    NlpCoreService-&gt;&gt;IntentSelector: selectIntent\n    IntentSelector--&gt;&gt;NlpCoreService : Intent,probability\n\n    Note over NlpCoreService : Evaluation et classification des entit\u00e9s en double Array[evaluatedEntities, notRetainedEntities]\n    loop\n        NlpCoreService-&gt;&gt;NlpCoreService: classifiyAndEvaluate\n        NlpCoreService-&gt;&gt;NlpCoreService: evaluateEntities\n\n        Note over NlpCoreService : Evaluation des entit\u00e9s reconnues\n        NlpCoreService-&gt;&gt;EntityCoreService: evaluateEntities\n\n        Note over EntityCoreService : R\u00e9cup\u00e8re le type d'entity provider parmis ceux dispnobiles (Duckling, Dictionnary)\n        EntityCoreService-&gt;&gt;EntityCoreService: getEntityEvaluator\n        NlpCoreService-&gt;&gt;EntityCoreService: evaluate\n        Note over EntityCoreService : Appelle le evaluate dans le parser sp\u00e9cifique (DucklingParser ou DictionnaryEntityTypeEvaluator) qui impl\u00e9mente EntityTypeEvaluator\n        EntityCoreService-&gt;&gt;EntityTypeEvaluator: evaluate\n        EntityTypeEvaluator--&gt;&gt;EntityCoreService: EvaluationResult\n\n        EntityCoreService--&gt;&gt;NlpCoreService: List&lt;EntityRecognition&gt;\n\n            alt (mergeEntitytype &amp;&amp; classifyEntityTypes) == true &amp;&amp; classifiedEntityTypes &gt; 0\n            Note over NlpCoreService,EntityCoreService : Evaluation des diff\u00e9rents types de contexte d'entit\u00e9s (EntityCallContextForIntent,EntityCallContextForEntity,EntityCallContextForSubEntities) selon les providers (Duckling ou autre)\n            NlpCoreService-&gt;&gt;EntityCoreService: classifyEntityTypes\n            EntityCoreService --&gt;&gt;NlpCoreService: List&lt;EntityTypeRecognition&gt;\n\n            Note over NlpCoreService : V\u00e9rification du support de la classification pour les providers d\u00e9tect\u00e9s et enl\u00e8vement de doublons \u00e9ventuels\n            NlpCoreService-&gt;&gt;NlpCoreService: classifyEntityTypesForIntent\n            NlpCoreService-&gt;&gt; EntityTypeClassifier : classifyEntities\n            alt mergeEntityType == true\n\n            Note over NlpCoreService : Gestion du merge des entit\u00e9s selon poids de reconnaissance\n            NlpCoreService-&gt;&gt; EntityMergeService: mergeEntityTypes\n            EntityMergeService--&gt;&gt;NlpCoreService: List&lt;EntityTypeRecognition&gt;\n\n            end\n\n    end\n\n    NlpCoreService--&gt;&gt;ParserService: ParsingResult\n\n    end\n\n        Note over ParserService,ParseRequestLogDao : Sauvegarde du Dao\n    ParserService-&gt;&gt; ParseRequestLogDao: save\n    deactivate ParserService\n    deactivate NlpCoreService\n\nend</code></pre>"},{"location":"dev/advanced/nlp/nlp-models-and-entity-models/","title":"Les mod\u00e8les NLP","text":"<p>Il existe diff\u00e9rents types de classificateur NLP. Ceux pour de la d\u00e9tection d'intention et ceux pour la d\u00e9tection d'entities. Ceux qui viennent des diff\u00e9rentes libs de NLP <code>EngineType</code> : - Stanford - Rasa - OpenNlp</p> <p>Pour les entit\u00e9s des impl\u00e9mentations \u00e9tendent <code>EntityTypeClassifier</code> Ces types sont trouv\u00e9s notamment lors de <code>getIntentClassifier</code> pour les intentions et <code>getEntityClassifier</code> dans NlpEngineRepository, d\u00e9finit dans le bot configuration avec le <code>EngineType</code> de d\u00e9fini</p> <p>Le module Nlp par d\u00e9faut est indiqu\u00e9 dans <code>ApplicationDefinition.kt</code> dans <code>tock-nlp-front-shared</code> avec valeur <code>opennlp</code>. Les modules de classification ou de la nlp sont charg\u00e9s via injection de d\u00e9pendences dans <code>FrontIoc.kt</code>, on retrouve dans coreModule dans <code>tock-nlp-core-service</code> le module DictionaryRepository et dans ducklingModule le module pour Duckling.</p>"},{"location":"dev/advanced/nlp/nlp-models-and-entity-models/#providers-de-modele-nlp","title":"Providers de mod\u00e8le Nlp","text":"<p>Les injections de d\u00e9pendences pour les mod\u00e8les de NLP participent \u00e0 leur chargement via SPI via <code>tock.nlp.model.service.engine.NlpEngineProvider</code>.</p>"},{"location":"dev/advanced/nlp/nlp-models-and-entity-models/#astuce-creer-un-nouveau-modele-de-nlp","title":"Astuce : cr\u00e9er un nouveau mod\u00e8le de NLP","text":"<ul> <li>Exemple : <code>OpenNlpEngineProvider.kt</code> Il semble n\u00e9cessaire de cr\u00e9er un nouveau provider de NLP et d'impl\u00e9menter l'interface <code>NlpEngineProvider</code> et d'ajouter la d\u00e9finition dans <code>META-INF/services/ai.tock.nlp.model.service.engine.NlpEngineProvider</code></li> </ul>"},{"location":"dev/advanced/nlp/nlp-models-and-entity-models/#les-modeles-dentites","title":"Les mod\u00e8les d'entit\u00e9s :","text":"<p>Ls mod\u00e8les d'entit\u00e9s par d\u00e9faut dans Tock sont ceux provenant de dictionnaires ou de duckling.</p>"},{"location":"dev/advanced/nlp/nlp-models-and-entity-models/#les-providers-dentites","title":"Les providers d'entit\u00e9s :","text":"<p>Par ailleurs, concernant les entit\u00e9s pour chaque entit\u00e9s exploitable c\u00f4t\u00e9 duckling ou dictionnaire, il existe un <code>EntityTypeProvider</code> qui fonctionne via SPI et d'ajouter la classe dans <code>ai.tock.nlp.core.service.entity.EntityTypeProvider</code></p>"},{"location":"dev/advanced/nlp/nlp-models-and-entity-models/#les-contextes-dentites","title":"Les contextes d'entit\u00e9s","text":"<p>Il existe diff\u00e9rents types de contexte d'entit\u00e9s reconnus via <code>EntityCallContext</code>, le contexte remonte des information concernant la langue, le type de NlpEngineType, le nom de l'application et la date. - EntityCallContextForIntent : le plus utilis\u00e9 - EntityCallContextForEntity - EntityCallContextForSubEntities</p>"},{"location":"dev/advanced/nlp/nlp-models-and-entity-models/#astuce-creer-une-nouveau-moteur-de-nlp-en-sinspirant-de-duckling","title":"Astuce cr\u00e9er une nouveau moteur de NLP en s'inspirant de Duckling :","text":"<p>L'exemple int\u00e9ressant \u00e0 suivre le fonctionnement du Duckling <code>nlp/entity-evaluator/tock-nlp-duckling</code>:</p> <p>C'est un bon moyen \u00e9galement pour bypasser l'existant ou ajouter un nouveau module. Il peut-\u00eatre int\u00e9ressant de suivre le mode de fonctionnement pr\u00e9sent.</p>"},{"location":"dev/advanced/nlp/nlp-models-and-entity-models/#exemple-de-limplementation-de-duckling","title":"Exemple de l'impl\u00e9mentation de Duckling","text":""},{"location":"dev/advanced/nlp/nlp-models-and-entity-models/#pour-le-client","title":"Pour le client","text":"<pre><code>classDiagram\nEntityTypeClassifier &lt;|.. DucklingParser\nEntityTypeEvaluator &lt;|.. DucklingParser\nParser &lt;|.. DucklingParser\n\nEntityTypeClassifier &lt;.. EntityTypeProvider\nEntityTypeEvaluator &lt;.. EntityTypeProvider\n\nDucklingEntityTypeProvider ..|&gt; EntityTypeProvider\n\n&lt;&lt;interface&gt;&gt; EntityTypeClassifier\n&lt;&lt;interface&gt;&gt; EntityTypeEvaluator\n&lt;&lt;interface&gt;&gt; Parser\n&lt;&lt;interface&gt;&gt; EntityTypeProvider</code></pre>"},{"location":"dev/advanced/nlp/nlp-models-and-entity-models/#utiliser-tock-nlp-entity-rest","title":"Utiliser <code>tock-nlp-entity-rest</code>","text":"<ul> <li>Ajouter dans le pom.xml de <code>nlp-api-service</code> (mode 1) ou <code>nlp-api-client</code> (mode 2), <code>${version}</code> va prendre la valeur de tock d\u00e9j\u00e0 pr\u00e9sente dans <code>nlp-api-service</code> <pre><code>        &lt;dependency&gt;\n            &lt;groupId&gt;ai.tock&lt;/groupId&gt;\n            &lt;artifactId&gt;tock-nlp-entity-rest&lt;/artifactId&gt;\n            &lt;version&gt;${version}&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre></li> <li>Ou bien Aller dans <code>Project structure</code>&gt;<code>nlp-api-service</code>&gt; et ajouter le module <code>tock-nlp-entity-rest</code></li> <li>Lancer NlpService et si besoin mettre \u00e0 jour la valeur : <code>tock_nlp_entity_type_url</code> (par exemple pour tester avec <code>tock-flair</code>) mettre \u00e9gal \u00e0  <code>http://localhost:5000/api/v1/</code></li> </ul>"},{"location":"dev/advanced/nlp/nlp-models-and-entity-models/#structure-de-restentityprovider","title":"Structure de RestEntityProvider","text":"<pre><code>classDiagram\nEntityTypeClassifier &lt;|.. RestEntityTypeProvider\nEntityTypeProvider &lt;|.. RestEntityTypeProvider\n\nRestEntityTypeClient ..&gt; RestEntityTypeProvider\n\n&lt;&lt;interface&gt;&gt; EntityTypeClassifier\n&lt;&lt;interface&gt;&gt; EntityTypeProvider</code></pre> <ul> <li> <p>Trois modes de fonctionnement : </p> <ol> <li>Appel de l'API \u00e0 chaque \u00e9change qui n'est pas unknown.</li> <li> <p>Erreur nominale : <code>2021-12-31T10:50:22.831 [vert.x-worker-thread-1] ERROR ai.tock.nlp.entity.rest.RestEntityTypeClient - Instantiation of [simple type, class ai.tock.nlp.entity.rest.RestEntityTypeClient$EntityTypeDescription] value failed for JSON property name due to missing (therefore NULL) value for creator parameter name which is a non-nullable type</code> : c'est parce que la phrase a d\u00e9tect\u00e9 une entit\u00e9 mais n'est pas entra\u00een\u00e9e et ne sait pas quoi prendre parmi les mots</p> </li> <li> <p>Pensez \u00e0 entra\u00eener une phrase avec une entit\u00e9 : exemple \"bonjour Jacques\" avec Jacques pour <code>flair:person</code>, dans le front et dans les logs on observe bien que l'entit\u00e9 reconnue est bien <code>person</code></p> </li> <li> <p>Erreur nominale : Ne pas oublier de relancer <code>botApi</code> et <code>botAdmin</code> si vous constater une erreur de <code>Response has already been thrown</code></p> </li> <li> <p>Pour g\u00e9rer l'appel au nlp compl\u00e9mentaire il est possible de faire un appel direct au composant de Nlp :    <code>val nlp = restEntityTypeClient.parse(this.message.toString(), this.userLocale)</code>    Il peut \u00eatre utile en cas de bypass total de la NLP, sinon cela peut-\u00eatre appel\u00e9 dans un storie sp\u00e9cifique ou un \u00e9tat \u00e9ventuellement pour pr\u00e9ciser la prochaine action.</p> </li> </ol> </li> </ul>"},{"location":"user/concepts/","title":"Conversational concepts for Tock","text":"<p>This page presents and popularizes the main concepts and conversational terminology used in Tock and its documentation.</p> <p>A table also offers equivalences and similar terms in other conversational solutions.</p>"},{"location":"user/concepts/#basic-notions","title":"Basic notions","text":""},{"location":"user/concepts/#application","title":"Application","text":"<p>In pure NLP mode (language recognition), an application corresponds to a corpus of qualified sentences from which Tock will draw a set of statistical models (allowing it to analyze and interpret user sentences).</p> <p>In conversational mode, the application also includes different parameters defining the responses and behavior of the bot. In other words, an application generally corresponds to a bot.</p> <p>See Tock Studio &gt; Settings &gt; Applications.</p>"},{"location":"user/concepts/#configuration","title":"Configuration","text":"<p>In a Tock application in NLP mode, a configuration groups one or more connectors for different channels (see below).</p> <p>In conversational mode, a configuration corresponds to a set of responses and behaviors of the bot on these channels. For example, for the same scenario (story) of the application it is possible to configure different responses (answers, story rules, etc.) according to several configurations.</p> <p>See Tock Studio &gt; Settings &gt; Configurations.</p>"},{"location":"user/concepts/#connector","title":"Connector","text":"<p>A connector allows Tock to \"connect\" a bot to an external channel such as Messenger, Alexa, a website, etc.</p> <p>Its detailed configuration depends on the channel concerned.</p> <p>Tock makes it very easy to share the code of a bot so that it responds on several channels thanks to its connectors. However, it is possible to fine-tune responses and behaviors depending on the connector, if needed.</p> <p>See Tock Studio &gt; Settings &gt; Configurations and the Bot Multichannel page to learn more about the available connectors.</p>"},{"location":"user/concepts/#namespace","title":"Namespace","text":"<p>The namespace is used to identify the organizational group of an object.</p> <p>The namespace usually appears as a prefix followed by <code>:</code> in a string. For example, an entity typed <code>duckling:datetime</code> is of type <code>datetime</code> in the namespace <code>duckling</code> (it comes from the Duckling module).</p> <p>If you are using the demo platform, your namespace is your GitHub identifier.</p> <p>While most objects and settings depend on an application that itself belongs to a namespace, some objects such as answers are directly attached to the namespace: they are therefore shared between the applications in this namespace.</p> <p>See Tock Studio &gt; Settings &gt; Namespaces.</p>"},{"location":"user/concepts/#intentions","title":"Intentions","text":"<p>To be able to define actions following a user request, it is first necessary to classify or categorize this request.</p> <p>What we call an intention is precisely this classification.</p> <p>For example, the sentences \"What's the weather like?\", \"Is it nice tomorrow?\", \"I hope it won't rain in Paris?\" can all be categorized with the \"weather\" intention.</p> <p>From the sentences manually classified by a user, Tock will automatically build a statistical model that will allow it, for a new sentence, to determine what the most likely intention is.</p> <p>To take the example above, with a model made up of the three example sentences, it is likely that a new sentence of the type \"What will the weather be like tomorrow?\" will be automatically recognized by Tock as corresponding to the intention \"weather\".</p> <p>See Tock Studio &gt; Language Understanding.</p>"},{"location":"user/concepts/#entities","title":"Entities","text":"<p>Once the intention has been determined, it is often useful to identify the meaning of certain words in the sentence.</p> <p>In the sentence \"Is it nice tomorrow?\", the word \"tomorrow\" has a meaning that must be used to answer the question in a relevant way.</p> <p>We call entities these significant words in the sentence.</p> <p>An entity has a type and a role. For example, in the sentence \"I leave at 11am and I arrive at 6pm\", the words \"at 11am\" and \"at 6pm\" are both entities of type 'datetime' but \"11am\" will have a role departure where \"6pm\" will have a role arrive. In cases where the role does not provide additional information, it is often equal to the type.</p> <p>There are two steps in taking an entity into account:</p> <ul> <li>Identification: what are the words in the sentence that constitute the entity</li> <li>Valorization: what is the value of this entity. For example, how to translate \"at 11am\" into a system date.</li> </ul> <p>By default, Tock identifies the entity, but does not value it, except for certain types. By default, entities in the namespace \"duckling\" will be automatically valued.</p> <p>See Tock Studio &gt; Language Understanding.</p>"},{"location":"user/concepts/#scenario-or-story","title":"Scenario (or Story)","text":"<p>A scenario or story is a functional grouping that allows you to answer questions on a well-defined subject.</p> <p>It is generally initiated by a main intention and can also use, optionally, a tree of so-called \"secondary\" intentions.</p> <p>To take the weather example, to someone asking \"What's the weather like?\", it can be useful to ask the question of where they are.</p> <p>This question will be taken into account in the \"weather\" story since it is only an extension of the initial question.</p> <p>The Story is the main unit of the Tock conversational framework.</p> <p>See Tock Studio &gt; Stories &amp; Answers.</p>"},{"location":"user/concepts/#terms-mappings","title":"Terms &amp; Mappings","text":"<p>The tables below provide mappings between terms used in Tock and other conversational solutions:</p> Tock DialogFlow Alexa Watson Intent Intent Intent Intent Entity Entity Entity / Slot Value Entity Sentence Query Utterance / Slot Message Story Context Dialog / Node Builtin Story Fulfillment Request Handler Webhook Connector Integration Integration / Channel Configuration Application Project / Agent Skill Skill / Assistant Tock RASA DYDU (Do You Dream Up) Clevy Intent Intent Reword Question Entity Entity Group Sentence User input Sentence Reformulation Story Story Knowledge Knowledge Builtin Story Connector Channel Channel integration Configuration Space Application Domain Bot <p>The documentation of the Tock connectors also gives the correspondence with other terms specific to this or that channel.</p>"},{"location":"user/concepts/#continue","title":"Continue...","text":"<p>You can now start the next chapter: Interfaces Tock Studio.</p>"},{"location":"user/guides/","title":"User guides","text":"<p>To learn more about Tock Studio features here are the step-by-step tutorials for:</p> <ul> <li>Build a conversational model</li> <li>Create a multichannel bot (connectors)</li> <li>Create a multilingual bot (internationalization)</li> </ul>"},{"location":"user/studio/","title":"Tock Studio interfaces","text":"<p>Tock Studio brings together all the user, technical and business interfaces, allowing to design conversational models, create paths and responses, follow conversations, analyze trends, etc.</p> <p>In this section, you will find the description of each view and interface. For specific themes or features, see also the user guides.</p> <ul> <li>Tock Studio interfaces:</li> <li>General interface</li> <li>The Language Understanding menu</li> <li>The Stories &amp; Answers menu</li> <li>The Gen AI menu</li> <li>The Test menu</li> <li>The Analytics menu</li> <li>The Model Quality menu</li> <li> <p>The Settings menu</p> </li> <li> <p>User guides:</p> </li> <li>Building a conversational model</li> <li>Creating a multichannel bot (connectors)</li> <li>Creating a multilingual bot (internationalization)</li> </ul> <p>You can also skip directly to the next chapter: Development.</p>"},{"location":"user/guides/build-model/","title":"Building conversational models","text":"<p>The Tock Studio documentation can be browsed screen by screen, including the Language Understanding and Model Quality menus for managing conversational models. Feel free to refer to it if you have a question about a particular tab/option.</p> <p>This page presents the construction of models by focusing more on usage and learning, allowing you to move from one screen to another without exhaustively detailing each feature of the platform.</p> <p>Note that it is possible to deploy the Tock NLU platform alone, in this case the Tock graphical interfaces are limited to the Settings, Language Understanding and Model Quality menus. This page can therefore be used as a tutorial for a use of Tock restricted to Language Understanding, for example for a use such as the Internet of Things.</p>"},{"location":"user/guides/build-model/#go-to-the-language-understanding-section","title":"Go to the Language Understanding section","text":"<p>The Language Understanding menu returns to the Inbox tab by default. Initially, you have no sentences if no one has yet spoken to the bot:</p> <p></p>"},{"location":"user/guides/build-model/#add-and-qualify-sentences","title":"Add and qualify sentences","text":""},{"location":"user/guides/build-model/#add-a-sentence","title":"Add a sentence","text":"<ul> <li>Go to the New Sentence screen</li> <li>Enter a sentence</li> </ul>"},{"location":"user/guides/build-model/#create-a-new-intent","title":"Create a new intent","text":"<ul> <li>Assign a new intent to the sentence by selecting Create a New Intent in the Intent selection list.</li> </ul>"},{"location":"user/guides/build-model/#specify-entities","title":"Specify entities","text":"<p>Depending on what the intent is for, you can specify the entities you want your model to recognize in the sentence:</p> <ul> <li>Select a portion of the sentence corresponding to the entity (ie. a group of words to select with the mouse)</li> <li>Click on Add Entity that just appeared</li> </ul> <p></p> <ul> <li>Choose an existing entity type or create a new one</li> <li>Give a role to this entity</li> </ul> <p>Example: in the sentence \"I want to go from Paris to New York\", probably Paris and New York are two entities of the same type (locality) but do not have the same role in the intent (origin and destination).</p> <p>It is of course possible to have multiple occurrences of the same role, or a different role in the same sentence.</p> <p></p>"},{"location":"user/guides/build-model/#take-advantage-of-predefined-entities","title":"Take advantage of predefined entities","text":"<p>By default, Tock offers a number of predefined entity types, including the types supported by the Duckling library: amounts, dates, etc. If you select these entity types, they will be automatically recognized and valued.</p> <p></p>"},{"location":"user/guides/build-model/#validate-the-sentence","title":"Validate the sentence","text":"<p>When the intent and entities are correct, complete the qualification of the sentence by clicking on Validate.</p>"},{"location":"user/guides/build-model/#qualify-other-sentences","title":"Qualify other sentences","text":"<p>After two or three sentences for a given intention, it is common for the model to start recognizing the following sentences and detecting the intention well (with an increasing score, as long as the sentences are relatively close / related to the intention of course):</p> <p></p> <p>If a sentence is not well qualified, change the intention / entities then do Validate to apply the correction. If the sentence was well qualified, do Validate directly.</p> <p>In both cases, you feed the model, which rebuilds itself, and becomes more relevant for the following sentences.</p> <p>You are building your conversational model!</p> <p>This is the beginning of learning for your bot or conversational application.</p> <p>The qualification of sentences, their number but also their variety (especially over time, because today's users are not exactly tomorrow's users) are the basis of a relevant model and a good conversational experience for users.</p>"},{"location":"user/guides/build-model/#browse-the-models-sentences","title":"Browse the model's sentences","text":"<p>The Search tab allows you to browse all the model's sentences using a certain number of criteria. The most used is the simple text search for which it is also possible to use regular expressions.</p> <p></p> <p>Each sentence has a Status that can change over time:</p> <ul> <li>Inbox : The sentence has not yet been qualified and is not part of the model</li> <li>Validated : The sentence has been validated but is not yet taken into account in the NLP models (this can take time in the case of large models)</li> <li>Included in model : The sentence has been validated and has been taken into account in the NLP models</li> </ul> <p>This screen therefore allows you to consult the sentences that are already part of the model (in other words already qualified), and to change the sentence qualifications over time. It is notably possible to re-qualify an entire group of sentences.</p> <p>For example, you can create a new intention later and decide that all sentences meeting a certain criterion (keyword or other) must now be qualified in this new intention.</p>"},{"location":"user/guides/build-model/#edit-the-advanced-features-of-the-application","title":"Edit the advanced features of the application","text":"<p>The Applications menu gives access to the list of applications/bots available on the platform:</p> <p></p> <p>With the edit button, several options are available, in particular:</p>"},{"location":"user/guides/build-model/#nlu-engine-selection","title":"NLU engine selection","text":"<p>You have the possibility to select the NLU library used by this bot (provided that several engines are present in the platform installation).</p>"},{"location":"user/guides/build-model/#enable-entity-templates","title":"Enable entity templates","text":"<p>This option allows you to reuse pre-built entity templates in your new intentions. For example, if you create an intention with a <code>duckling:datetime</code> entity, dates will be automatically recognized for this intention in all new sentences assigned to this intention.</p> <p>Internally, an arbitration is made between the information coming from the pre-built entity models and the information taken from your own model.</p> <p>This option is enabled by default. It may be useful to disable it for very large models, for which native detection will be superior in almost all cases to that of the entity models.</p>"},{"location":"user/guides/build-model/#enabling-subentities","title":"Enabling subentities","text":"<p>If you enable this option, you will be able to qualify several levels of entities:</p> <p></p> <p>The number of levels is not limited, but it is recommended not to specify more than 3 or 4.</p>"},{"location":"user/guides/build-model/#predefined-entity-values","title":"Predefined entity values","text":"<p>A given entity can have predefined values. To do this, you must go to the Entities tab, select an entity. The icon next to the delete icon shows the types of entities you can edit:</p> <p></p> <p>In the example above, two labels are defined for the week value:</p> <ul> <li>Week</li> <li>weekly</li> </ul>"},{"location":"user/guides/build-model/#continue","title":"Continue...","text":"<p>To learn more about entity management, especially in programmatically created intentions, or simply to continue browsing the Tock user manual, you can go to the Development chapter.</p>"},{"location":"user/guides/canaux/","title":"Building a multichannel bot with Tock","text":""},{"location":"user/guides/canaux/#notion-of-connector","title":"Notion of connector","text":"<p>A Tock connector allows you to integrate a bot into an external communication channel (text or voice). Aside from the test connector type (used internally by the Tock Studio interface), connectors are associated with channels external to the Tock platform.</p> <p>The whole point of Tock connectors lies in the ability to develop conversational assistants independently of the channel(s) used to talk to it. It is thus possible to create a bot for a channel, then make it multichannel later by adding connectors.</p> <p>The Web connector has the particularity of exposing a generic API to interact with a Tock bot. As a result, it allows even more integrations on the \"frontend\" side, using this API as a gateway.</p> <p>This page actually lists:</p> <ul> <li>The connectors provided with the Tock distribution:  {style=\"width: 75px;\"}</li> </ul> <p>{style=\"width: 75px;\"} </p> <p>{style=\"width: 75px;\"}</p> <p> </p> <ul> <li> <p>The kits using the Web connector to integrate other channels:  </p> </li> <li> <p>The possible integrations for voice processing:  </p> </li> </ul>"},{"location":"user/guides/canaux/#connectors-provided-with-tock","title":"Connectors provided with Tock","text":"<p>Tock provides many connectors for different types of channels (see below). New connectors are regularly added to the platform, depending on project needs but also on the schedule for opening public channels to bots.</p> <p>Examples: arrival of Google Home in France in 2017, Alexa in 2018, opening of WhatsApp APIs then Business Chat in 2019, etc.</p> <p>To learn more about the referenced bots using this or that connector in production, do not hesitate to consult the page Tock showcase.</p>"},{"location":"user/guides/canaux/#messenger","title":"Messenger","text":"<ul> <li>Channel : Facebook Messenger</li> <li>Type : text (+ voice via voice message upload )</li> <li>Status : Tock connector used in production since 2016</li> </ul> <p>The guide Connect your bot to Messenger explains how to integrate a bot Tock with a Facebook page / [Messenger] (https://www.messenger.com/).</p> <p>To learn more about this connector, you can also go to the folder connector-messenger on GitHub, where you will find the sources and the README of the connector.</p>"},{"location":"user/guides/canaux/#slack","title":"Slack","text":"<ul> <li>Channel : Slack</li> <li>Type : text</li> <li>Status : Tock connector used outside production</li> </ul> <p>The guide Connect your bot to Slack explains how to integrate a bot Tock with a Slack channel.</p> <p>To learn more about this connector, you can also go to the folder connector-slack on GitHub, where you will find the sources and the README of the connector.</p>"},{"location":"user/guides/canaux/#google-assistant-home","title":"Google Assistant / Home","text":"<ul> <li>Channel: Google Assistant / Google Home</li> <li>Type: text + voice</li> <li>Status : Tock connector used in production since 2017</li> </ul> <p>To learn more about this connector, see its sources and its README in the folder connector-ga on GitHub.</p>"},{"location":"user/guides/canaux/#alexa-echo","title":"Alexa / Echo","text":"<ul> <li>Channel : Amazon Alexa / Amazon Echo</li> <li>Type : voice</li> <li>** Status**: Tock connector used in production since 2018</li> </ul> <p>Important note: in the case of Alexa, the NLP model is necessarily built and hosted at Amazon.</p> <p>Only the conversational framework part of Tock can be used.</p> <p>To learn more about this connector, see its sources and its README in the connector-alexa folder on GitHub.</p>"},{"location":"user/guides/canaux/#rocketchat","title":"# Rocket.Chat","text":"<ul> <li>Channel : Rocket.Chat</li> <li>Type : text</li> <li>Status : to be specified</li> </ul> <p>To learn more about this connector, see its sources and its README in the folder connector-rocketchat on GitHub.</p>"},{"location":"user/guides/canaux/#whatsapp","title":"WhatsApp","text":"<ul> <li>Channel : WhatsApp from Facebook</li> <li>Type : text</li> <li>Status : Tock connector used in production since 2019</li> </ul> <p>To learn more about this connector, see its sources and its README in the folder connector-whatsapp on GitHub.</p>"},{"location":"user/guides/canaux/#teams","title":"Teams","text":"<ul> <li>Channel : Microsoft Teams</li> <li>Type : text + voice</li> <li>Status : Tock connector used in production since 2019</li> </ul> <p>To learn more about this connector, see its sources and its README in the folder connector-teams on GitHub.</p>"},{"location":"user/guides/canaux/#business-chat","title":"Business Chat","text":"<ul> <li>Channel : Apple Business Chat (Messages)</li> <li>Type : text</li> <li>Status : Tock connector used in production since 2019</li> </ul> <p>To learn more about this connector, see its sources and its README in the folder connector-businesschat on GitHub.</p>"},{"location":"user/guides/canaux/#twitter","title":"Twitter","text":"<ul> <li>Channel : Twitter (private messages)</li> <li>Type : text</li> <li>Status : Tock connector used in production since 2019</li> </ul> <p>To learn more about this connector, see its sources and its README in the folder connector-twitter on GitHub.</p>"},{"location":"user/guides/canaux/#allo-media","title":"Allo-Media","text":"<ul> <li>Channel : Allo-Media (telephony)</li> <li>Type : voice</li> <li>Status : Tock connector used in production since 2020</li> </ul> <p>This connector was developed for the AlloCovid bot. For more information, see the AlloMediaConnector class with the bot sources on GitHub.</p>"},{"location":"user/guides/canaux/#google-chat","title":"Google Chat","text":"<ul> <li>Channel : Google Chat (formerly Google Hangouts)</li> <li>Type : text</li> <li>Status : Tock connector used outside of production</li> </ul> <p>To learn more about this connector, see its sources and README in the connector-google-chat folder on GitHub.</p>"},{"location":"user/guides/canaux/#web-generic","title":"Web (generic)","text":"<p>This generic connector allows you to integrate a Tock bot into any website or application: portal, web or mobile application, REST client, etc.</p> <p>The connector exposes a REST API to the bot, easily integrated from any web or mobile application, or programming language.</p> <p>Several kits and components based on the Web connector are already available to integrate Tock bots into different sites and applications, such as websites with React, native mobile applications with Flutter or even intranets SharePoint.</p> <ul> <li>Channel : Web (generic for all sites &amp; web applications)</li> <li>Type : text</li> <li>Status : Tock connector used in production since 2020</li> </ul> <p>To learn more about this connector, see its sources and its README in the folder connector-web on GitHub. It contains examples and documentation in Swagger format of the REST API.</p>"},{"location":"user/guides/canaux/#test-generic","title":"Test (generic)","text":"<p>This connector is internal to Tock, it is used to communicate with a bot directly in the Tock Studio interface (Test &gt; Test the bot view) by emulating other connectors.</p>"},{"location":"user/guides/canaux/#integrations-via-the-web-connector","title":"Integrations via the Web connector","text":"<p>The Web connector exposes a generic API to interact with a Tock bot. As a result, it allows even more integrations on the \"frontend\" side, using this API as a gateway.</p>"},{"location":"user/guides/canaux/#react","title":"React","text":"<p>This React component integrates a Tock bot and renders it graphically in a web application. The web application communicates with the bot via a Web connector.</p> <ul> <li>Integration : React (JavaScript / JSX)</li> <li>Type : Web applications</li> <li>Status : Used in production since 2020</li> </ul> <p>For more information, see the sources and the README in the repository <code>tock-react-kit</code> on GitHub.</p>"},{"location":"user/guides/canaux/#flutter-beta","title":"Flutter (beta)","text":"<p>This Flutter component integrates a Tock bot and provides its graphical rendering in a mobile or web application. The app communicates with the bot via a web connector.</p> <ul> <li>Integration: Flutter (Dart)</li> <li>Type: Native mobile and web apps</li> <li>Status: Beta, in development</li> </ul> <p>For more information, see the sources and the README in the <code>tock-flutter-kit</code> repository on GitHub.</p>"},{"location":"user/guides/canaux/#sharepoint-beta","title":"SharePoint (beta)","text":"<p>This WebPart component allows you to integrate a Tock bot into a SharePoint site. It embeds the tock-react-kit to communicate with the bot via a Web connector and manage the graphic rendering of the bot in the SharePoint page.</p> <ul> <li>Integration : Microsoft SharePoint</li> <li>Type : Websites &amp; Intranets</li> <li>Status : Beta, in development</li> </ul> <p>For more information, see the sources and the README in the <code>tock-sharepoint</code> repository on GitHub.</p>"},{"location":"user/guides/canaux/#voice-technologies","title":"Voice technologies","text":"<p>Tock bots process sentences in text format by default (chatbots). However, voice technologies can be integrated into the bot's \"terminals\" in order to obtain voice conversations (voicebots and callbots):</p> <ul> <li>Translation of voice into text (Speech-To-Text) upstream of the processing by the bot (ie. before the NLU step)</li> <li>Translation of text into voice (Text-To-Speech) downstream of the processing by the bot (ie. voice synthesis of the bot's response)</li> </ul> <p>Some connectors provided with Tock allow a bot to be integrated into an external channel managing the STT and TTS voice aspects.</p> <p>In addition, other voice technologies have been integrated into Tock in recent years. They are mentioned for information purposes, even when no ready-to-use connector is provided.</p>"},{"location":"user/guides/canaux/#google-android","title":"Google / Android","text":"<p>Google's Speech-To-Text and Text-To-Speech functions are used through the Google Assistant / Home connector, also by the voice functions of the Microsoft Teams app for Android compatible with the Teams connector, as well as within the Android platform in particular for native mobile developments. &lt;!--&gt;&lt;To do bug img &lt;!--&gt;  </p> <ul> <li>Technology : STT &amp; TTS Google / Android</li> <li>Status : used with Tock in production (via connectors Google Assistant / Home, Microsoft Teams and natively Android for botsintegrated on-app)</li> </ul>"},{"location":"user/guides/canaux/#apple-ios","title":"Apple / iOS","text":"<p>Apple's Speech-To-Text and Text-To-Speech features are used through the Business Chat connector, as well as within iOS for native mobile developments.</p> <p> </p> <ul> <li>Technology : STT &amp; TTS Apple / iOS</li> <li>Status : used with Tock in production (via Business Chat connector and natively iOS for integrated on-app bots)</li> </ul>"},{"location":"user/guides/canaux/#amazon-alexa","title":"Amazon / Alexa","text":"<p>Alexa (Amazon) Speech-To-Text and Text-To-Speech functions are used through the Alexa connector / Echo.</p> <p></p> <ul> <li>Technology: STT &amp; TTS Amazon / Alexa</li> <li>Status: used with Tock in production (via Alexa connector)</li> </ul>"},{"location":"user/guides/canaux/#allo-media-voxygen","title":"Allo-Media &amp; Voxygen","text":"<p>The company Allo-Media offers an AI platform based on phone calls.</p> <p>Voxygen offers speech synthesis services.</p> <p>On the occasion of the development of the AlloCovid bot, an Allo-Media connector was developed to integrate the bot (Tock) with the Allo-Media services: Speech-To-Text and Text-To-Speech with Voxygen.</p> <p> </p> <ul> <li>Technology: Allo-Media &amp; Voxygen</li> <li>Status: used with Tock in production (via Allo-Media connector)</li> </ul>"},{"location":"user/guides/canaux/#nuance","title":"Nuance","text":"<p>Nuance offers speech recognition &amp; AI solutions.</p> <p>For voice command experiments in 2016, Nuance had been integrated with Tock for its Speech-To-Text functions.</p> <p>Although this integration has not been maintained since, it worked after a few days of implementation.</p> <p></p> <ul> <li>Technology: Nuance</li> <li>Status: used with Tock in 2016</li> </ul>"},{"location":"user/guides/canaux/#connector-architecture-data-governance","title":"Connector architecture &amp; data governance","text":"<p>With a view to governance of conversational models and data, the Tock connector architecture has several advantages:</p> <ul> <li>The model is built in Tock, it is not shared via connectors</li> <li>The choice of a bot's connectors allows you to control the propagation (or not) of conversations</li> </ul> <p>For example, for a bot internal to a company, you can choose to use only connectors</p> <p>to its own channels (website, etc.) or internal to the company (enterprise applications, professional space on</p> <p>an Android phone, etc.).</p> <ul> <li>Even if a bot is connected to several external channels/partners, only the Tock platform has all the conversations on all these channels.</li> </ul>"},{"location":"user/guides/canaux/#developing-your-own-connector","title":"Developing your own connector","text":"<p>It is possible to create your own Tock connector, for example to interface a Tock bot with a channel specific to the organization (often a specific website or mobile application), or when a general public channel opens to conversational bots and the Tock connector does not yet exist.</p> <p>The Bot Framework section of the Tock developer manual gives instructions for implementing your own connector.</p>"},{"location":"user/guides/i18n/","title":"Building a multilingual bot with Tock","text":"<p>The Tock Studio interface allows you to translate and modulate a bot's responses according to the language but also the channel used.</p>"},{"location":"user/guides/i18n/#prerequisites","title":"Prerequisites","text":"<p>Tock provides a complete internationalization framework. It is enabled by default in Bot API mode (for example on the demo platform).</p> <p>In Integrated Bot mode (see the developer manual), internationalization is disabled by default. To enable it, it is then necessary to configure the platform at startup:</p> <ul> <li>Either via the bot startup code (developer): <pre><code>Translator.enabled = true\n</code></pre></li> <li>Or with a System property (administrator) by passing <code>-Dtock_i18n_enabled=true</code> at JVM startup</li> </ul>"},{"location":"user/guides/i18n/#enable-multiple-languages-for-a-bot","title":"Enable multiple languages \u200b\u200bfor a bot","text":"<p>It is possible to add and manage active languages \u200b\u200bfor a bot in the NLU Applications section (in Tock Studio). See The Settings menu.</p> <p>At any time in Tock Studio, it is possible to change the language selected in the banner at the top of the page, in particular to communicate with a bot in the Test the bot interface. See General interface.</p>"},{"location":"user/guides/i18n/#user-language-and-locale","title":"User language and locale","text":"<p>When possible, the user's locale (language/region) is imported from their account's.</p> <p>For example, if a Messenger user's account is set to French, French will be automatically selected by Tock.</p> <p>If there is no locale specified, Tock's default locale is used.</p> <p>A developer can change the user's locale in the bot's code itself:</p> <pre><code>userPreferences.locale = Locale.FRENCH\n</code></pre> <p>Finally, the default locale can be changed by a platform administrator, by passing the System property <code>-Dtock_default_locale=fr</code> when starting the JVM.</p>"},{"location":"user/guides/i18n/#translate-and-vary-the-bots-answers","title":"Translate and vary the bot's answers","text":"<p>In Tock Studio, the Stories &amp; Answers &gt; Answers section allows you to manage the labels of the bot's answers.</p> <p>See The Stories &amp; Answers menu.</p> <p>Each label has a default value for each language of the bot.</p> <p>It is possible to design and configure different variants:</p> <ul> <li>Depending on the language</li> <li>Depending on the channel / connector <p>For example, some channels require specific labels, either because the channel owner requires it (on Alexa, the use of the formal \"vous\" is required), or because the user experience differs from other channels (for example in voice, we will avoid sentences that are too long).</p> </li> <li>Randomly (so that the bot does not always answer the same thing)</li> </ul>"},{"location":"user/guides/i18n/#massively-translate-models-and-responses","title":"Massively translate models and responses","text":"<p>Features are being studied to allow the more or less automated translation of many user sentences (corpus / conversational model) and responses (labels / i18n). To be continued...</p> <p>For the moment, to consider a mass translation, we can for example:</p> <ol> <li>Export the data in JSON or CSV with Tock Studio</li> <li>Translate the sentences/responses outside of Tock (SaaS API, agency...)</li> <li>Import the translations with Tock Studio</li> </ol> <p>Note: at the time of import, only the labels marked validated are taken into account.</p>"},{"location":"user/guides/i18n/#develop-with-internationalization","title":"Develop with internationalization","text":"<p>The Tock developer manual gives more details on the development of multilingual bots.</p>"},{"location":"user/guides/intents-restrictions/","title":"Restricting the scope of intents","text":"<p>In some cases, intent detection can be complex, especially when training part of the model is impossible due to the scope of possibilities. This is the case, for example, if you want to retrieve a user's last name during a conversation. It is obviously not possible to train an intent to detect all existing proper names.</p> <p>Intent restriction allows you to limit the choice of eligible intents when exiting a story, whether it is configured via the studio or programmatic. Several intents can be defined, each assigned a weighting that determines their preponderance over each other.</p> <p>Intent restriction is only effective for the next action.</p>"},{"location":"user/guides/intents-restrictions/#programmatic-story","title":"Programmatic Story","text":"<p>The nextIntentsQualifiers object is a ClientBus property that can be used in a programmatic story:</p> <pre><code>nextIntentsQualifiers = listOf(\nNlpIntentQualifier(\"ask_last_name\",10.0),\nNlpIntentQualifier(\"cancel\",0.0)\n)\n</code></pre> <p>The eligible intents after this story are therefore \u2018ask_last_name\u2019 and \u2018cancel\u2019, the latter being less likely to be triggered due to its lower weighting</p>"},{"location":"user/guides/intents-restrictions/#configured-story","title":"Configured Story","text":"<p>The restriction of intents can be done within the studio when editing a story.</p> <p>Warning: If you define quick replies and a list of restricted intents, the intents associated with the quick replies will be added to the list of restricted intents. This mechanism avoids conflicts where the defined restricted intents would contradict the quick replies defined in the story.</p> <p>The weights can take the following values: * unlikely : * likely : 0.5 * very likely : 0.9</p> <p></p>"},{"location":"user/studio/analytics/","title":"The Analytics menu","text":"<p>This menu contains a series of tabs to view and analyze the bot's use cases, configurations, stories, and intentions.</p> <p>The Monitoring menu allows you to track and observe connected users and conversations.</p>"},{"location":"user/studio/analytics/#the-activity-tab","title":"The Activity tab","text":"<p>This screen allows you to track different indicators over time:</p> <ul> <li>Number of messages received by the bot</li> <li>Messages per Story,</li> <li>Messages per Configuration,</li> <li>Messages per Connector,</li> <li>Etc.</li> </ul> <p>A calendar allows you to define the time period to be viewed.</p> <p>Each indicator can be viewed in several ways:</p> <ul> <li>Histogram</li> <li>Pie chart (over the selected period)</li> <li>\u200b\u200bSortable table</li> <li>CSV export</li> </ul> <p>The Preferences tab allows you to create your own dashboard, choose your indicators, and presentation options.</p>"},{"location":"user/studio/analytics/#the-behavior-tab","title":"The Behavior tab","text":"<p>This screen presents other indicators for a defined period, without representing their evolution:</p> <ul> <li>Type of messages received by the bot</li> <li>Most used channels</li> <li>Hourly traffic</li> <li>Traffic by day of the week</li> <li>Etc.</li> </ul> <p>A calendar allows you to define the period of time to be viewed.</p> <p>Each indicator can be viewed in several ways:</p> <ul> <li>Pie chart (over the selected period)</li> <li>\u200b\u200bSortable table</li> <li>CSV export</li> </ul> <p>The Preferences tab allows you to compose your own dashboard, choose your indicators and presentation options.</p>"},{"location":"user/studio/analytics/#the-flow-tab","title":"The Flow tab","text":"<p>This screen allows you to analyze the flow of intentions and conversations:</p> <ul> <li> <p>Conversation flow (Dynamic / User Flow): dynamic analysis of the paths actually taken by users</p> </li> <li> <p>Intention flow (Static / Available Stories): static analysis of the paths and decision trees proposed by the bot</p> </li> </ul> <p>By expanding the interface (arrow to the right of the frame), many filters appear: focus on an intention, incoming/outgoing transitions, all transitions or only the most representative in terms of traffic, etc.</p>"},{"location":"user/studio/analytics/#the-users-tab","title":"The Users tab","text":"<p>This tab allows you to see the last users connected to the bot:</p> <ul> <li>Number of connected users</li> <li>Date of the last exchange with a user</li> <li>Last message sent</li> <li>Etc.</li> </ul> <p>By clicking on Display dialog, you can see this user's conversation.</p> <p></p>"},{"location":"user/studio/analytics/#the-search-tab","title":"The Search tab","text":"<p>Like the Users view, this screen allows you to observe the latest conversations.</p> <p>It is possible to filter them by connector, intention, etc.</p>"},{"location":"user/studio/analytics/#the-preferences-tab","title":"The Preferences tab","text":"<p>This screen allows you to configure the dashboards of the Activity and Behavior views, both the indicators/graphs to display but also different presentation options: 3D diagrams, curve smoothing, etc.</p> <p>An action allows the user to save their preferences.</p>"},{"location":"user/studio/analytics/#continue","title":"Continue...","text":"<p>Go to Menu Model Quality for the rest of the user manual.</p> <p>You can also go directly to the next chapter: Development.</p>"},{"location":"user/studio/configuration/","title":"The Settings menu","text":"<p>The Settings menu allows you to create and configure Tock conversational applications (i.e. models / bots that can coexist on a platform). Several administration and configuration functions for bots are also available via this menu: import/export a configuration, configure the language, connectors, etc.</p>"},{"location":"user/studio/configuration/#the-applications-tab","title":"The Applications tab","text":"<p>This screen allows you to create, modify, delete Tock conversational applications.</p> <p></p> <p>When you first connect to the demo platform, a simplified wizard allows you to create the first application (the first bot). You can then go through this screen to add other applications.</p>"},{"location":"user/studio/configuration/#create-an-application","title":"Create an application","text":"<p>To add an application, click on Create New Application :</p> <ul> <li> <p>Enter a name / identifier for the application</p> </li> <li> <p>Choose whether the template can include entities or even sub-entities (see Concepts for more information)</p> </li> <li> <p>Select one or more languages \u200b\u200b(see Building a multilingual bot for more information)</p> </li> <li> <p>Select an NLU engine (Apache OpenNLP or Stanford CoreNLP, see Installation for more information)</p> </li> </ul>"},{"location":"user/studio/configuration/#edit-import-and-export-an-application","title":"Edit, import and export an application","text":"<p>For each application already created, you can then:</p> <ul> <li> <p>Download an application dump : download its configuration in JSON format: language, intent/entity model, etc.</p> </li> <li> <p>Download a sentences dump: download its qualified sentences in JSON format</p> </li> <li> <p>Edit: modify the application configuration</p> </li> <li>A form allows you to modify the initial configuration</li> <li>An Advanced options section adds other parameters for advanced users:</li> <li>Upload dump: load a configuration or qualified sentences from a file in JSON format. Only new intents/phrases will be added, this function does not modify/delete existing intents/phrases</li> <li>Trigger build: trigger/force model rebuild</li> <li>NLU Engine configuration: fine-tune the underlying NLU engine (parameters depend on the engine used, Apache OpenNLP or Stanford CoreNLP)</li> <li>Alexa Export: export the Tock model in a format usable by Alexa</li> </ul> <p></p> <p>The Upload dump function (see above) is also directly accessible at the bottom of the screen, allowing:</p> <ul> <li>Either to modify an application (if the <code>application name</code> exists)</li> <li>Either create/import a new one</li> </ul>"},{"location":"user/studio/configuration/#the-configurations-tab","title":"The Configurations tab","text":"<p>This screen allows you to access the connectors of a bot, to add, modify or delete them. This is also where you find the information to connect programmatically.</p>"},{"location":"user/studio/configuration/#connect-programmatically-to-the-bot","title":"Connect programmatically to the bot","text":"<p>The settings to connect to the bot programmatically (ie. via a program / programming language) are found in this screen:</p> <ul> <li> <p>The API Key can be copied and embedded in the client code of the Bot API to connect programmed paths in Kotlin or in another programming language like Javascript/Nodejs or Python</p> </li> <li> <p>An address / URL can be configured to use the WebHook mode of Bot API</p> </li> </ul> <p>To learn more about these settings and path development, see Bot API.</p>"},{"location":"user/studio/configuration/#manage-connectors","title":"Manage connectors","text":"<p>The list of connectors of the bot is displayed under the API key. To add a connector to the bot, click on Create a new Configuration.</p> <p>All connectors have the following configuration:</p> <ul> <li>Configuration name : the name/identifier of the bot</li> <li>Connector type : the channel type (e.g. Messenger, Slack, etc.)</li> <li>Connector identifier : an identifier for the connector, unique for the bot</li> <li>Relative REST path : a relative path unique for the platform, to communicate with the bot on this channel.</li> </ul> <p>By default, the path is of the form <code>/io/{organisation}/{application}/{channel}</code> which makes it unique on the platform</p> <p>(unless two connectors of the same type are declared for the same bot).</p> <p>Each connector also has an additional configuration specific to this connector type. These settings</p> <p>are in Connector Custom Configuration. These specific settings are documented with each connector/channel type, see Connectors.</p>"},{"location":"user/studio/configuration/#test-connectors","title":"Test connectors","text":"<p>For each connector added to the bot, a test connector is also created and configured. It is used to \"simulate\" the connector when testing the bot directly in the Tock Studio interface (menu Test &gt; Test the bot).</p> <p>By default, test connectors are not displayed in the Bot Configurations screen. Click on Display test configurations to view them and possibly modify them.</p> <p>In particular, if you get connection error messages in the Test the bot page, do not hesitate to check the test configuration, in particular the Application base url address (for a platform deployed with Docker Compose by default, it should be <code>http://bot_api:8080</code> with the container name and port declared in the <code>docker-compose-bot.yml</code> descriptor).</p>"},{"location":"user/studio/configuration/#the-namespaces-tab","title":"The Namespaces tab","text":"<p>This screen allows you to manage one or more namespaces or namespaces. Each application, each bot is created within a namespace. It is possible to manage several namespaces, and to share some of them with a team or other Tock Studio users. To do this, simply edit the namespace and add other users (giving them more or less rights on the namespace).</p>"},{"location":"user/studio/configuration/#the-log-tab","title":"The Log tab","text":"<p>This view allows you to track the main application configuration changes made by users via Tock Studio: application creation, connector modifications, imports, etc.</p>"},{"location":"user/studio/configuration/#continue","title":"Continue...","text":"<p>Go to Menu FAQ Training for the rest of the user manual.</p> <p>You can also go directly to the next chapter: Development.</p>"},{"location":"user/studio/custom-metrics/","title":"The Custom Metrics menu","text":"<p>The Custom Metrics menu allows you to create and view statistics on the consultation and use of Tock stories.</p> <p>It is intended for a business audience that wants to monitor the performance of stories (FAQs, scenarios, etc.) within a Tock application.</p> <p>To access this page, you must have the botUser role.</p>"},{"location":"user/studio/custom-metrics/#metrics-tab","title":"Metrics tab","text":"<p>This page allows you to display a certain number of business-oriented statistics (unlike the Analytics menu, whose statistics relate to technical criteria).</p> <p>The statistics are displayed for a given period, which can be specified using the field at the top of the page. On its right, a set of shortcuts allow you to define this period in one click (last 3 days, last 7 days, last 30 days and last 3 months).</p> <p>Then, for the selected period, come the following statistics:</p> <ul> <li>Number of user messages</li> <li>Number of answers provided by the bot</li> <li>Number of questions not understood by the bot</li> <li>Bot response rate</li> </ul> <p></p> <p>To obtain reliable and correctly broken down statistics, it is necessary to create an unknown story (see section Create an Unknown story).</p>"},{"location":"user/studio/custom-metrics/#section-number-of-user-messages","title":"Section Number of user messages","text":"<p>This graph displays the number of user messages per day for the requested period</p>"},{"location":"user/studio/custom-metrics/#section-distribution-of-stories","title":"Section Distribution of stories","text":"<p>This graph displays the distribution of stories triggered following user questions. Hovering over the graph entries allows you to obtain the number of times the story was triggered as well as the share taken by this story in the total number of stories triggered for the requested period.</p> <p>If the number of stories to display exceeds a certain threshold, an Other stories category will be displayed, bringing together the stories that recorded the lowest trigger rates.</p> <p>Clicking on any of the graph entries opens a window displaying these same statistics in a detailed list (and possibly displaying the details of the Other stories)</p> <p>To the right of the section title, a drop-down menu allows you to filter the stories displayed by type and/or category. It also allows you to display stories metrics that are not listed by default.</p>"},{"location":"user/studio/custom-metrics/#section-indicators","title":"Section Indicators","text":"<p>Indicators, associated with metrics stories, allow you to record user feedback, generally as part of a satisfaction story or a survey. For more information on creating indicators and assigning them to metrics stories, refer to the Indicators and Metrics Stories sections</p> <p>A drop-down list to the right of the section title allows you to select the indicator dimension to display. A dimension is a collection of indicators (see Indicators tab).</p> <p>For each indicator in the chosen dimension, a graph displays the distribution of user responses. The gray No answer given section corresponds to the number of times a user did not answer the question asked. Hovering over the portions of the graph displays the number of responses provided for each indicator option as well as the percentage represented of all times the corresponding question was asked.</p> <p>For each graph, a Detail by story button is provided. Detail by story displays a window gathering the graphs of the responses given to this indicator by story.</p>"},{"location":"user/studio/custom-metrics/#indicators-tab-indicators-tab","title":"Indicators tab {#indicators-tab}","text":"<p>Indicators are used to measure user satisfaction or to conduct surveys.</p> <p>An indicator generally corresponds to a question that will be asked to users after the execution of a story. It gathers one or more values \u200b\u200bcorresponding to the possible responses to this question.</p> <p>Once defined, the indicators can be associated with Actions of Metric story. The Metric story can in turn be defined as a satisfaction story of your FAQs or other types of stories. For more information on the definition of Metric story, refer to the section Metrics Stories.</p> <p>This page lists all the existing indicators.</p> <p>An indicator is composed of the following elements:</p> <ul> <li>Its label</li> <li>The dimension to which it belongs</li> <li>Its possible values</li> </ul> <p>An indicator must necessarily belong to at least one dimension but the same indicator can belong to several different dimensions. Dimensions are simple groupings of indicators facilitating their manipulation and consultation.</p> <p>The following actions are available for each indicator:</p> <ul> <li>Edit: allows you to modify the attributes of the indicator (label, description, dimensions, values)</li> <li>Delete: allows you to delete the indicator. Note that deleting an indicator will prohibit viewing the statistics recorded for this indicator.</li> </ul>"},{"location":"user/studio/custom-metrics/#creating-an-indicator","title":"Creating an indicator","text":"<p>You can create a new indicator by clicking on the + New Indicator button at the top right of the page. This opens a panel in which you can define:</p> <ul> <li>The indicator label</li> <li>A description (optional)</li> <li>One or more dimensions to which the indicator will be attached</li> <li>One or more values \u200b\u200bthat the indicator is likely to carry</li> </ul> <p>For example, we can imagine a \"Satisfaction\" indicator that carries the values \u200b\u200b\"Satisfied\" and \"Not satisfied\".</p> <p>Note that the name of the indicator and its values \u200b\u200bwill not be directly displayed to users. The question and answer sentences will be defined at the level of the actions of the Metric story that you will be required to create in the next step. You can therefore choose a label and simple values \u200b\u200bthat will facilitate their manipulation.</p> <p>As an example, we can imagine a dimension that brings together the following indicators and values:</p> <ul> <li>DIMENSION: Satisfaction</li> <li>INDICATOR: Overall satisfaction</li> <li>VALUE: Satisfied</li> <li>VALUE: Not satisfied</li> <li>INDICATOR: Reason for dissatisfaction</li> <li>VALUE: Question not understood</li> <li>VALUE: Incorrect answer</li> <li>INDICATOR: Dissatisfaction action</li> <li>VALUE: Redirect to a human</li> <li>VALUE: Reformulate my question</li> </ul> <p>Based on this set of indicators, we can configure a Metric story asking a set of questions to users and recording their answers with the aim of improving our Bot (see Metrics Stories).</p>"},{"location":"user/studio/custom-metrics/#filters","title":"Filters","text":"<p>It is possible to search for indicators by entering text in the Search field.</p> <p>It is also possible to filter the list of indicators by selecting one or more dimensions in the drop-down list.</p>"},{"location":"user/studio/custom-metrics/#create-a-story-unknown-create-unknown-story","title":"Create a Story Unknown {#create-unknown-story}","text":"<p>In order to explicitly distinguish user questions not understood by the bot, it is necessary to create a story unknown. This story will be returned by the bot in cases where it has not identified an intent corresponding to the user questions. The story unknown also allows you to provide a message to display to the user in the event that their question has not been understood.</p> <p>To create a story unknown, go to Stories &amp; Answers in the main menu and access the New story tab. In the field provided, give a name to your story unknown (for example <code>story unknown</code>) and click on the add button. On the page that appears, click on the Edit story button.</p> <p></p> <p>A window opens. In the Intent field, enter the string <code>unknown</code> and click Save.</p> <p>In the Answers section, enter the answer to return to users when their question has not been understood, then click Create story.</p>"},{"location":"user/studio/custom-metrics/#metrics-stories-metrics-stories","title":"Metrics Stories {#metrics-stories}","text":"<p>Once defined, the indicators must be associated with the actions of a story in order to be triggered by users and thus result in the recording of a hit.</p>"},{"location":"user/studio/custom-metrics/#creating-a-satisfaction-metrics-story","title":"Creating a satisfaction Metrics Story","text":"<p>From the main menu, go to Stories &amp; Answers then to the New story tab.</p> <p>In the field provided, enter the name of your satisfaction story (for example <code>Story satisfaction</code>) then validate. In the Answer field, enter a user prompt (e.g. <code>Are you satisfied with the answer provided?</code>)</p> <p>In the Actions section, add a first action using the + Add action button:</p> <p>Define the User phrase of the action (e.g. <code>Yes</code>).</p> <p>Indicate an Intent name for the action (e.g. <code>satisfaction_ok</code>). A window appears to validate the creation of the intent. Validate by clicking on the Create button. Enter a response using the Answer field of the action (e.g. <code>I am delighted to have been able to help you</code>).</p> <p>In the Indicators list, select the value of the indicator provided for this purpose (in our example, <code>Overall satisfaction: Satisfied</code>).</p> <p></p> <p>Repeat for the \"Not satisfied\" action:</p> <p>In the Actions section, add a second action using the + Add action button. Define the User phrase of the action (e.g. <code>No</code>). Indicate an Intent name for the action (e.g. <code>satisfaction_nok</code>). Enter a response using the Answer field (e.g. <code>Can you specify the problem encountered?</code>). In the Indicators list, select the value of the indicator provided for this purpose (in our example, <code>Overall satisfaction: Not satisfied</code>).</p> <p></p> <p>You will now be able to define the Actions to propose to users who answered <code>No</code> to the initial question:</p> <p>Using the mouse, hover over the second action created with the user phrase <code>No</code>. A contextual menu appears at the bottom of the action. Click on Add action. Expand the action using the chevron that appears to the left of it.</p> <p>Define the User phrase of the action (for example <code>My question was misunderstood</code>). Indicate an Intent name for the action (for example <code>satisfaction_questionmisunderstood</code>). Enter an answer using the Answer field (for example <code>Thank you for your help. Would you like to try to rephrase your question or be put in touch with an advisor?</code>). In the Indicators list, select the value of the indicator provided for this purpose (in our example, <code>Overall satisfaction: question not understood</code>).</p> <p></p> <p>Continue the operations described above until you have completely defined your satisfaction story according to the desired indicators.</p> <p>Now that you have assigned at least one indicator to an action, you have the possibility to mark this story as a Metric story using the switch located at the top right of the Actions section.</p> <p></p> <p>You can now validate the creation of the Metric story by clicking on the Create story button at the bottom of the page.</p> <p>A story marked as Metric story allows you to record the satisfaction for the story previously triggered by the user. A Metric story must therefore be defined as a story for redirecting business stories. The indicators recorded following user responses will therefore refer to the story that was executed just before the _Metric story was triggered. If indicators are associated with the actions of a story not marked as Metric story, the statistics recorded will only concern the story carrying these actions.</p>"},{"location":"user/studio/custom-metrics/#defining-a-metric-story-as-a-redirection-story","title":"Defining a Metric Story as a redirection story","text":"<p>To define a Metric Story as a story for redirecting all your FAQs, go to the Faq Management entry using the main menu.</p> <p>Click on the <code>Faq parameters</code> icon at the top right of the page.</p> <p></p> <p>Enable the Ask for satisfaction after answering on FAQ question checkbox then select the Metric story previously created.</p> <p></p> <p>Click on the Save button.</p> <p>From now on, after each execution of a story of type Faq, the story \"Story satisfaction\" will be triggered and will allow to ask users for feedback.</p> <p>For a more precise adjustment of the stories giving rise to a redirection, go to Stories &amp; Answers, Rules tab</p>"},{"location":"user/studio/faq-management/","title":"The FAQ Management menu","text":"<p>The FAQ Management menu allows you to create, modify and enrich conversational models with Frequently Asked Questions type questions (Questions/Answers with simple text).</p> <p>It is intended for a business audience not familiar with conversational concepts (intentions, entities, etc.).</p> <p>To access this page, you must have the botUser role (more details on roles in security ).</p>"},{"location":"user/studio/faq-management/#faq-list","title":"FAQ List","text":"<p>This page lists all existing FAQs (with pagination)</p> <p></p> <p>For each FAQ you can find the following elements:</p> <ul> <li>Its name</li> <li>The number of associated questions</li> <li>An example of a question</li> <li>An excerpt of the returned answer</li> <li>A set of tags</li> </ul> <p>The following actions are available for each FAQ:</p> <ul> <li>Enable/Disable: allows you to deactivate an FAQ. Once deactivated, the bot will no longer send the associated answer but the default answer unknown</li> <li>Edit: allows you to modify the elements of the FAQ (name, description, tags, questions, answer)</li> <li>Download: allows you to download the description of the FAQ in JSON format</li> <li>Delete: allows you to delete the FAQ. Note that the underlying intention will also be deleted. However, the questions will be stored in the Inbox.</li> </ul>"},{"location":"user/studio/faq-management/#creating-a-new-faq","title":"Creating a new FAQ","text":"<p>You can create new FAQ questions by clicking on the + New FAQ button. This opens a panel with 3 tabs.</p> <p>A Simple Story is automatically created when a FAQ is created and is associated with it.</p>"},{"location":"user/studio/faq-management/#info-tab","title":"INFO tab","text":"<p>In this tab, you can:</p> <ul> <li>Define the name of the FAQ</li> <li>Give a description to explain what it answers</li> <li>Add tags to be able to group FAQs by theme</li> </ul> <p>The name of the faq is used to generate the underlying intention that will be associated with it</p>"},{"location":"user/studio/faq-management/#question-tab","title":"QUESTION tab","text":"<p>In this tab, you can add as many questions as necessary to feed the model. These questions will be associated with the underlying intention of the FAQ. It is recommended to have a minimum of 10 questions with varied formulations so that the model can have a minimum recognition rate.</p>"},{"location":"user/studio/faq-management/#answer-tab","title":"ANSWER tab","text":"<p>In this tab you will be able to define the answer that should be sent to the user when his question refers to it. The answer is limited to a text format that can contain markdown provided that the rendering interface supports it.</p>"},{"location":"user/studio/faq-management/#filters","title":"Filters","text":"<p>It is possible to search for sentences to qualify by entering text in the Search field.</p> <p>It is also possible to filter the list of FAQs by selecting one or more tags in the drop-down list.</p> <p>Finally, you can filter the FAQs by limiting the display to those that are active/inactive/all by using the Active checkbox.</p>"},{"location":"user/studio/faq-management/#configuration","title":"Configuration","text":"<p>It is possible to configure a default Story that will be executed after sending the FAQ answer in order to collect the user's satisfaction on the quality of the answer provided.</p> <p>A Ending type Rule is automatically created and associated with the Story associated with the FAQ</p> <p></p> <p>Check the Ask for satisfaction after answering on FAQ question box to activate this feature.</p> <p>Choose a Story from the Select story drop-down list.</p> <p>A Activation type Rule will be automatically created for each FAQ</p>"},{"location":"user/studio/faq-management/#continue","title":"Continue...","text":"<p>Go to User guides for the rest of the user manual.</p> <p>You can also go directly to the next chapter: Development.</p>"},{"location":"user/studio/faq-training/","title":"The FAQ Training menu","text":"<p>The FAQ Training menu allows you to enrich conversational models by associating user sentences with FAQ questions. It is intended for a business audience unfamiliar with conversational concepts (intentions, entities, etc.).</p> <p>To access this page, you must have the nlpUser role. ( more details on roles in security ).</p> <p>This page lists all the sentences received by the NLU model with the detected faq/scores.</p> <p>These sentences can come from real users regardless of the channels, from an entry in the Try it tab or from a conversation via the Test the bot page in Tock Studio.</p>"},{"location":"user/studio/faq-training/#sentence-qualification","title":"Sentence qualification","text":"<p>The following actions are available to qualify sentences:</p> <ul> <li>Create New FAQ: create a new FAQ question by automatically adding the selected sentence to the list of associated questions</li> <li>Validate: confirm the FAQ detected by the model and save the sentence in the latter (ultimately causing a reconstruction of the model)</li> <li>Unknown: qualify the sentence with an unknown intention (default response)</li> <li>Delete: delete the sentence (irreversible action)</li> <li>Details: display the details of the dialog in which the sentence was detected</li> </ul> <p></p>"},{"location":"user/studio/faq-training/#filters","title":"Filters","text":"<p>It is possible to search for sentences to qualify by entering text in the field Search.</p> <p>It is possible to display the sentences associated with the unknown intention by activating the Unknown button.</p>"},{"location":"user/studio/faq-training/#continue","title":"Continue...","text":"<p>Go to Menu FAQ Management for the rest of the user manual.</p> <p>You can also go directly to the next chapter: Development.</p>"},{"location":"user/studio/general/","title":"The Tock Studio interface","text":"<p>This page presents the general characteristics of Tock Studio.</p> <p>The following pages cover the different menus of the application and different functionalities.</p>"},{"location":"user/studio/general/#logging-in-to-the-application","title":"Logging in to the application","text":"<p>A standard browser is enough to access Tock Studio. The user is prompted to authenticate:</p> <ul> <li> <p>On the Tock demo platform, the user is prompted to authenticate via their GitHub account. The user must then accept that Tock accesses their account - only the GitHub account identifier is read by Tock.</p> </li> <li> <p>On a default Tock platform, the credentials are <code>admin@app.com</code> / <code>password</code>.The default credentials are defined in the source file <code>bot/admin/web/src/environments/environment.ts</code> and it is recommended to modify them.</p> </li> </ul> <p>It is also possible, as an alternative, to use an authentication mechanism upstream of the application, for example via an Apache HTTPd service or a cloud service such as AWS Cognito on the one hand and a LDAP type directory on the other hand.</p>"},{"location":"user/studio/general/#the-application-banner","title":"The application banner","text":"<p>At the top left of the interface are:</p> <ul> <li> <p>A button to display (or hide) the different Tock Studio menus</p> </li> <li> <p>The name of the interface</p> </li> </ul> <p>At the top right of the interface are:</p> <ul> <li> <p>The currently selected application / bot (useful when several bots co-exist on the platform)</p> </li> <li> <p>The currently selected language (useful for testing a multilingual bot)</p> </li> <li> <p>A link to log out</p> </li> </ul>"},{"location":"user/studio/general/#continue","title":"Continue...","text":"<p>Go to Configuration_ Menu for the rest of the user manual.</p> <p>You can also go directly to the next chapter: Development.</p>"},{"location":"user/studio/nlu-qa/","title":"The Model Quality menu","text":"<p>The Model Quality (or NLU QA) menu allows you to evaluate and monitor over time the quality/relevance/performance of conversational models.</p>"},{"location":"user/studio/nlu-qa/#the-model-stats-tab","title":"The Model Stats tab","text":"<p>This screen presents graphs to track the evolution of several indicators of the quality of the conversational model:</p> <ul> <li> <p>Relevance: the scores of the detection algorithms on intentions (Intent average probability) and on entities (Entity average probability)</p> </li> <li> <p>Traffic / errors: the number of requests to the model (Calls) and the number of errors (Errors)</p> </li> <li> <p>Performance: the response time of the model (Average call duration)</p> </li> </ul> <p></p>"},{"location":"user/studio/nlu-qa/#the-intent-distance-tab","title":"The Intent Distance tab","text":"<p>The metrics presented in the table on this page (Occurrences and Average Diff) allow you to identify intentions that are more or less close in the model, in particular to optimize the modeling.</p>"},{"location":"user/studio/nlu-qa/#the-model-builds-tab","title":"The Model Builds tab","text":"<p>This screen presents statistics on the latest reconstructions of the model. These are therefore indications on the performance of the model.</p>"},{"location":"user/studio/nlu-qa/#the-tests-trends-tab","title":"The Tests Trends tab","text":"<p>The Partial model tests are a classic way to detect qualification errors, or problems of proximity of intentions (or entities) between them.</p> <p>This involves taking a part of the current model at random (for example 90% of the sentences of the model) in order to build a slightly less relevant model, then testing the remaining 10% with this new model.</p> <p>The principle established, all that remains is to repeat the process a certain number of times so that the most frequent errors are presented to a manual corrector.</p> <p>Note that these tests are only useful with already substantial models.</p> <p>This tab shows the evolution of the relevance of the partial model tests.</p> <p>By default, the tests are scheduled to be launched from midnight to 5am, every 10 minutes. It is possible to configure this behavior with the <code>tock_test_model_timeframe</code> property (default: <code>0.5</code>).</p>"},{"location":"user/studio/nlu-qa/#the-test-intent-errors-tab","title":"The Test Intent Errors tab","text":"<p>This screen shows the results of the partial tests of intent detection (see above), with the details of the phrases/expressions recognized differently from the real model.</p> <p></p> <p>In this example, no \"real\" error was detected. However, we can see that in some cases the model is systematically wrong, with a high probability.</p> <p>For each sentence, it is possible via the Actions column to confirm that the basic model is correct (with Validate Intent) or to correct the detected error (Change The Intent).</p> <p>It is interesting to periodically analyze these differences, some differences being well explained, even being sometimes \"assumed\" (false negatives), others can reveal a problem in the model.</p>"},{"location":"user/studio/nlu-qa/#the-test-entity-errors-tab","title":"The Test Entity Errors tab","text":"<p>Like Intent Test Errors for entities, this screen presents the results of partial tests for entity detection.</p> <p></p> <p>It is interesting to periodically analyze these differences, some differences being well explained, even being sometimes \"assumed\" (false negatives), others can reveal a problem in the model.</p>"},{"location":"user/studio/nlu-qa/#continue","title":"Continue...","text":"<p>Go to Menu Settings for the rest of the user manual.</p> <p>You can also go directly to the next chapter: Development.</p>"},{"location":"user/studio/nlu/","title":"The Language Understanding menu","text":"<p>The Language Understanding (or NLU) menu allows you to create, modify, and enrich conversational models: declare intentions and entities, qualify sentences, etc. (see Concepts for more information).</p> <p>In this page, the details of each tab are presented. See also Building conversational models for a more usage-driven presentation.</p>"},{"location":"user/studio/nlu/#the-new-sentence-tab","title":"The New Sentence tab","text":"<p>This screen allows you to enter sentences and check which intention/entities are detected.</p> <p>Enter a sentence and validate to see the detection resulting from the conversational model (in practice: how the bot interprets the sentence). The following are then displayed:</p> <ul> <li>Intent: the recognized intention</li> <li>Language: the detected language</li> <li>The score(s) returned by the algorithms (according to their level of confidence on the intention and on any entities)</li> <li>If applicable, each entity detected with its role/type and score</li> </ul> <p></p> <p>It is possible to modify all the elements detected from this screen:</p> <ul> <li>To modify the intention (or even create a new one on the fly) or the detected language, use the fields / selection lists under the sentence</li> <li>To delete an entity, use the button next to the entity score</li> <li>To add an entity, select a block of words in the sentence with the mouse then specify its role/type.</li> </ul> <p></p> <p></p> <p>Note: if you have enabled this option at the application/bot level, it is possible to declare sub-entities. You will learn more in Building conversational models.</p> <p>The following buttons and commands are available for the sentence as a whole:</p> <ul> <li>Delete: delete the sentence</li> <li>Unknown: qualify the sentence as an unknown intention (default response)</li> <li>Validate: confirm the detected intention/entities and save the sentence in the model (ultimately causing a reconstruction of the model, its corpus being enriched with this sentence)</li> </ul> <p>Other links are available to display conversations containing this sentence, copy the content of the sentence, create a path from this sentence.</p>"},{"location":"user/studio/nlu/#the-inbox-tab","title":"The Inbox tab","text":"<p>This tab shows (with pagination and some display options) all the sentences received by the NLU model with the detected intentions/entities/language/scores.</p> <p>These sentences can come from real users regardless of the channels, from an entry in the Try it tab or from a conversation via the Test the bot page in Tock Studio.</p> <p>When you are testing from an external channel, do not hesitate to click on the Refresh button (top left of the screen) to refresh the list of sentences.</p> <p>The buttons and commands under each sentence are identical to those in the Try it tab (see above).</p>"},{"location":"user/studio/nlu/#the-search-tab","title":"The Search tab","text":"<p>This screen allows you to search through all the sentences: Inbox but also qualified sentences saved in the model.</p> <p></p>"},{"location":"user/studio/nlu/#the-unknown-tab","title":"The Unknown tab","text":"<p>This screen allows you to browse sentences whose intent has not been recognized (unknown intent).</p>"},{"location":"user/studio/nlu/#the-intents-tab","title":"The Intents tab","text":"<p>This screen allows you to manage intentions.</p>"},{"location":"user/studio/nlu/#the-entities-tab","title":"The Entities tab","text":"<p>This screen allows you to manage entities, including shared entity concepts.</p>"},{"location":"user/studio/nlu/#the-logs-tab","title":"The Logs tab","text":"<p>This screen displays the complete log of sentences received and allows you to go back to conversations (i.e. all the sentences received and bot responses for a user).</p> <p>Note: unlike the Inbox view, the Logs show the sentences received even when they already exist identically in the model (in this case, the model and algorithms are not even queried, the response being known).</p>"},{"location":"user/studio/nlu/#continue","title":"Continue...","text":"<p>Go to Menu Stories &amp; Answers for the rest of the user manual.</p> <p>You can also go directly to the next chapter: Development.</p>"},{"location":"user/studio/stories-and-answers/","title":"The Stories and Answers menu","text":"<p>The menu allows you to build paths and answers to the user's sentences.</p> <p>On this page, the details of each tab are presented. See also Create your first bot with Tock Studio for an example of creating a path or Build a multilingual bot for using the Answers tab.</p>"},{"location":"user/studio/stories-and-answers/#the-new-story-tab","title":"The New Story tab","text":""},{"location":"user/studio/stories-and-answers/#create-a-simple-answer","title":"Create a simple answer","text":"<p>The guide Create your first bot with Tock Studio presents an example of creating a path with a simple answer via New Story.</p> <p>The Test tab &gt; Test the bot then allows you to quickly check the behavior of the bot on this path.</p> <p></p>"},{"location":"user/studio/stories-and-answers/#creating-complex-responses","title":"Creating complex responses","text":"<p>It is possible to indicate several responses and also \"rich\" responses called Media Message.</p> <p>This allows, regardless of the channel, to display images, titles, subtitles and action buttons.</p>"},{"location":"user/studio/stories-and-answers/#mandatory-entities","title":"Mandatory entities","text":"<p>It is possible, before displaying the main response, to check if certain entities are filled in, and if not, to display the appropriate question.</p> <p>The corresponding option is called Mandatory Entities.</p> <p>For example, let's suppose that we need to know the user's destination.</p> <p>If he has not already indicated it, the bot should ask him \"To which destination?\".</p>"},{"location":"user/studio/stories-and-answers/#actions","title":"Actions","text":"<p>Actions are presented as suggestions, when the channel allows it.</p> <p>It is possible to present a tree of actions to build a decision tree.</p>"},{"location":"user/studio/stories-and-answers/#the-stories-tab","title":"The Stories tab","text":"<p>This screen allows you to browse and manage the paths or stories created.</p> <p>These can be paths configured via Tock Studio (ie. with the New Story tab) but also paths declared programmatically via Bot API. To see the latter, uncheck the Only Configured Stories option.</p>"},{"location":"user/studio/stories-and-answers/#the-rules-tab","title":"The Rules tab","text":"<p>This tab contains the following sections:</p> <ul> <li>Tagged Stories</li> </ul> <p>This section allows you to view the different stories that have a particular function depending on the tags with which they are configured.</p> <p>We can therefore identify the following types:</p> <ul> <li>Bot deactivation stories that are tagged with the DISABLE tag</li> <li> <p>Bot reactivation stories that are tagged with the ENABLE tag</p> </li> <li> <p>Story Rules</p> </li> </ul> <p>This section allows you to create or modify deactivation or redirection rules on stories.</p> <ul> <li>Application Features</li> </ul> <p>This section allows you to manage functions that can be activated or deactivated via the interface (or Feature Flipping).</p>"},{"location":"user/studio/stories-and-answers/#the-answers-tab","title":"The Answers tab","text":"<p>This tab allows you to modify the bot's answers, dynamically according to several possible criteria:</p> <ul> <li> <p>The language (this is called internationalization or i18n)</p> </li> <li> <p>The channel (text or voice), that is to say in practice the connector</p> </li> <li> <p>According to a rotation: it is possible to record several response texts for the same label in the same language on the same connector - the bot will then randomly answer one of these texts, then perform a rotation so as not to always answer the same thing.</p> </li> </ul> <p>This makes the bot more pleasant by varying its answers.</p> <p></p> <p>See also Building a multilingual bot for the use of the Responses tab but also the development aspects on this topic.</p>"},{"location":"user/studio/stories-and-answers/#continue","title":"Continue...","text":"<p>Go to Menu Test for the rest of the user manual.</p> <p>You can also go directly to the next chapter: Development.</p>"},{"location":"user/studio/test/","title":"The Test menu","text":"<p>The Test menu allows you to test a bot directly in the Tock Studio interface, as well as to manage automatic test plans.</p>"},{"location":"user/studio/test/#the-test-the-bot-tab","title":"The Test the Bot tab","text":"<p>Via this menu, you can talk directly to the bot by simulating different languages \u200b\u200band connectors.</p> <p>This allows you to quickly and easily test a bot in the Tock Studio interface,</p> <p>without having to use external software and channels.</p> <p>The interface remains minimal because the goal is to quickly test the bot, not to obtain a real user interface or even a rendering identical to that of a particular connector.</p> <p>Depending on the type of messages returned by the bot and the connector used, the rendering in</p> <p>the Test the bot screen may not be satisfactory. Indeed, for perfect compatibility with this screen,</p> <p>the connectors must respect certain implementation rules.</p> <p>If you notice that a certain type of message for a given connector is not well managed in this interface, do not hesitate to raise a issue GitHub.</p> <p>To talk to a bot in the interface, once in Test &gt; Test the bot :</p> <ul> <li>Check the language (top right of the interface)</li> <li>Select an application/bot</li> <li>Select a connector to emulate</li> <li>Start typing sentences...</li> </ul> <p></p> <p>Here is another example with a conversation including rich components of the Messenger connector, with their rendering in the generic Tock Studio interface :</p> <p></p> <p>For each message exchange with the bot, the detected language is indicated. By clicking on View Nlp Stats you can see the details of the model's response: intent, entities, scores, etc.</p>"},{"location":"user/studio/test/#the-test-plans-tab","title":"The Test Plans tab","text":"<p>This tool allows you to create and track the execution of automated conversation tests, in order to automatically and regularly check the non-regression of the bot. This part is under development and a complete documentation will arrive soon.</p>"},{"location":"user/studio/test/#continue","title":"Continue...","text":"<p>Go to Menu Analytics for the rest of the user manual.</p> <p>You can also go directly to the next chapter: Development.</p>"},{"location":"user/studio/gen-ai/gen-ai/","title":"Gen AI","text":"<p>D\u00e9couvrez l'IA g\u00e9n\u00e9rative sur Tock :</p> <ul> <li>Le menu Gen AI / RAG Settings</li> <li>Le menu Gen AI / RAG Exclusions</li> <li>Le menu Gen AI / Sentence Generation</li> <li>Le menu Gen AI / Observability Settings</li> <li>Le menu Gen AI / Vector Store Settings</li> </ul> <p>D\u00e9mo : </p> <p></p>"},{"location":"user/studio/gen-ai/features/gen-ai-feature-observability/","title":"Le menu Gen AI - Observability Settings","text":"<ul> <li>L'observabilit\u00e9 des mod\u00e8les de langage (LLM Observability) aide \u00e0 surveiller, d'analyser et de comprendre le comportement des mod\u00e8les de langage \u00e0 grande \u00e9chelle.</li> <li>Cela inclut la collecte de donn\u00e9es sur leurs performances, la d\u00e9tection d'anomalies et la compr\u00e9hension des erreurs qu'ils peuvent produire. </li> <li>L'objectif est de garantir que ces mod\u00e8les fonctionnent de mani\u00e8re fiable, transparente, en fournissant des informations qui permettent d'am\u00e9liorer leur performance et de corriger les probl\u00e8mes potentiels.</li> <li>Plus pr\u00e9cis\u00e9ment, nous pourrons :<ul> <li>Voir les diff\u00e9rents enchainements d'appels de LLM avec le prompt d'entr\u00e9e et de sortie</li> <li>Analyser les portions de documents contextuels utilis\u00e9s</li> <li>Suivre les informations et les m\u00e9triques sur les co\u00fbts, le nombre de jetons consomm\u00e9s, la latence, etc.</li> </ul> </li> </ul> <p>Pour acc\u00e9der \u00e0 cette page il faut b\u00e9n\u00e9ficier du r\u00f4le botUser. ( plus de d\u00e9tails sur les r\u00f4les dans securit\u00e9 ).</p>"},{"location":"user/studio/gen-ai/features/gen-ai-feature-observability/#configuration","title":"Configuration","text":"<p>Pour permettre \u00e0 Tock de se connecter \u00e0 un outil d'observabilit\u00e9, un \u00e9cran de configuration a \u00e9t\u00e9 mis en place : </p> <p></p>"},{"location":"user/studio/gen-ai/features/gen-ai-feature-observability/#utilisation","title":"Utilisation","text":"<ul> <li>Voici la liste des fournisseurs d'observabilit\u00e9 des LLM qui sont pris en compte par Tock.</li> <li>Veuillez vous r\u00e9f\u00e9rer \u00e0 la documentation de chaque outil pour comprendre comment l'utiliser.</li> </ul>"},{"location":"user/studio/gen-ai/features/gen-ai-feature-rag-exclusion/","title":"Le menu Gen AI / RAG Exclusions","text":"<p>La \"RAG Exclusions\" est un concept qui permet \u00e0 TOCK d'exclure des sujets du p\u00e9rim\u00e8tre de r\u00e9ponse IA apport\u00e9e par la RAG.</p> <p></p> <p>En compl\u00e9ment du prompt, il permet de limiter les r\u00e9ponses du bot afin qu\u2019il reste dans son p\u00e9rim\u00e8tre d\u2019action et ne cr\u00e9e pas de r\u00e9ponse trop inventive.</p> <p>Pour ajouter des sujets ou phrases que le bot ne doit pas traiter : 1. Aller dans le menu Language Understanding / Inbox 2. S\u00e9lectionner la phrase que vous souhaitez exclure 3. Cliquer sur \u201cExclude from RAG handling\u201d</p> <p>Sur l'\u00e9cran Gen Ai / RAG Exclusions, vous verrez toutes les phrases/sujets qui ont \u00e9t\u00e9 exclus des r\u00e9ponses du Bot.</p> <p></p>"},{"location":"user/studio/gen-ai/features/gen-ai-feature-rag/","title":"Le menu Gen AI / RAG Settings","text":""},{"location":"user/studio/gen-ai/features/gen-ai-feature-rag/#configuration","title":"Configuration","text":"<p>Le menu Gen AI / RAG Settings (Retrieving augmented Generation) vous permet de choisir les mod\u00e8les d'IA g\u00e9n\u00e9rative pris en charge par Tock et de configurer un ensemble de crit\u00e8res sp\u00e9cifiques \u00e0 chaque fournisseur d'IA. Cette fonctionnalit\u00e9 permettra \u00e0 TOCK de g\u00e9n\u00e9rer une r\u00e9ponse \u00e0 une requ\u00eate de l'utilisateur, sur la base d'un ensemble de documents int\u00e9gr\u00e9s dans une base de donn\u00e9es vectorielle.</p> <p>Pour acc\u00e9der \u00e0 cette page il faut b\u00e9n\u00e9ficier du r\u00f4le botUser. ( plus de d\u00e9tails sur les r\u00f4les dans securit\u00e9 ).</p>"},{"location":"user/studio/gen-ai/features/gen-ai-feature-rag/#activation-du-rag-configuration-du-llm-engine","title":"Activation du RAG &amp; Configuration du LLM Engine","text":"<p>RAG activation : - L\u2019activation n\u2019est possible qu\u2019une fois que tous les champs marqu\u00e9s d\u2019un * sont remplis. - Une fois les champs remplis, choisir si oui ou non, le bot doit offrir l\u2019option RAG.</p> <p>Un provider IA : (LLM Engine) - Cette section permet de param\u00e9trer les options li\u00e9es au mod\u00e8le IA qui g\u00e9n\u00e8re la r\u00e9ponse \u00e0 l\u2019utilisateur. - Voir la liste des fournisseurs d'IA</p> <p>Temp\u00e9rature : - On peut d\u00e9finir une temp\u00e9rature situ\u00e9e entre 0 et 1. - Celle-ci permet de d\u00e9terminer le niveau de cr\u00e9ativit\u00e9 du Bot dans la r\u00e9ponse apport\u00e9e \u00e0 une requ\u00eate qui lui est envoy\u00e9e.</p> <p>Prompt : - Le prompt est le script qui d\u00e9termine la personnalit\u00e9 du Bot, le contexte dans lequel il doit r\u00e9pondre, la fa\u00e7on dont il doit s\u2019adresser \u00e0 l\u2019utilisateur, les recommandations ou instructions de r\u00e9ponses, les styles et formats de r\u00e9ponses.</p>"},{"location":"user/studio/gen-ai/features/gen-ai-feature-rag/#embedding-engine-gestion-de-la-conversation","title":"Embedding Engine &amp; Gestion de la conversation","text":"<p>Un provider IA : (Embedding Engine) - Cette section permet de param\u00e9trer les options li\u00e9es au mod\u00e8le IA qui interagit avec la base documentaire vectoris\u00e9e. - Voir la liste des fournisseurs d'IA</p> <p>Indexing session : - Renseigner l\u2019ID de l\u2019Indexing Session de votre base documentaire vectoris\u00e9e</p> <p>Conversation Flow : - No rag sentences : Lorsque le LLM, via le prompt et sa base documentaire, n\u2019arrive pas \u00e0 apporter une r\u00e9ponse, il entre dans le Conversation Flow, ce qui permet d'activer une story particuli\u00e8re. - Par exemple : \u201cD\u00e9sol\u00e9, je ne trouve aucune information documentaire pour vous r\u00e9pondre, souhaitez-vous parler \u00e0 un conseiller ou reformuler votre question ?\u201d</p>"},{"location":"user/studio/gen-ai/features/gen-ai-feature-rag/#import-dune-story-unkown-si-le-rag-est-active","title":"Import d'une Story Unkown si le RAG est activ\u00e9","text":"<p>Attention : Lorsqu\u2019on importe les Story d\u2019un bot \u00e0 l'autre, et que la RAG est activ\u00e9e en dans le bot recepteur, un message d\u2019avertissement apparait concernant la Story Unknown (Story qui permet au Bot de r\u00e9pondre qu\u2019il ne connait pas la r\u00e9ponse \u00e0 une question).  - Deux options sont donc possibles :   - D\u00e9sactiver le RAG et permettre l\u2019import de la Story Unknown.   - Garder le RAG activ\u00e9 et importer la Story Unknown mais d\u00e9sactiv\u00e9e.</p>"},{"location":"user/studio/gen-ai/features/gen-ai-feature-rag/#utilisation","title":"Utilisation","text":"<p>Une fois le RAG configur\u00e9 et activ\u00e9, il peut \u00eatre utilis\u00e9 pour prendre le contr\u00f4le de toutes les questions qualifi\u00e9es d'Inconnues par la NLP.</p> <p>En voici un exemple : </p>"},{"location":"user/studio/gen-ai/features/gen-ai-feature-sentence-generation/","title":"Le menu Gen AI - Sentence generation","text":""},{"location":"user/studio/gen-ai/features/gen-ai-feature-sentence-generation/#configuration","title":"Configuration","text":"<p>Le menu Gen AI - Sentence Generation Settings permet de configurer la fonctionnalit\u00e9 de g\u00e9n\u00e9ration de phrases d'entra\u00eenement pour les bots FAQ.</p> <p>Pour acc\u00e9der \u00e0 cette page il faut b\u00e9n\u00e9ficier du r\u00f4le botUser. ( plus de d\u00e9tails sur les r\u00f4les dans securit\u00e9 ).</p> <p></p> <p>Pour activer la fonction de g\u00e9n\u00e9ration de phrases, vous devez choisir :</p> <p>Un provider IA : - Voir la liste des fournisseurs d'IA</p> <p>Une temp\u00e9rature : - C\u2019est la temp\u00e9rature qui appara\u00eetra par d\u00e9faut lors de la cr\u00e9ation des phrases d'entra\u00eenement. - Elle Permet de d\u00e9finir le degr\u00e9 d\u2019inventivit\u00e9 du mod\u00e8le utilis\u00e9 pour g\u00e9n\u00e9rer des phrases. - Elle est situ\u00e9 entre 0 et 1.0.     - 0 = pas de latitude dans la cr\u00e9ation des phrases     - 1.0 = Plus grande latitude dans la cr\u00e9ation des phrases.</p> <p>Un prompt : - Encadr\u00e9 dans lequel inclure le prompt qui permet la g\u00e9n\u00e9ration de nouvelles phrases d'entra\u00eenement.</p> <p>Le nombre de phrases : - D\u00e9fini le nombre de phrases d'entra\u00eenement g\u00e9n\u00e9r\u00e9es par chaque requ\u00eate.</p> <p>Activation : - Permet d'activer ou pas la fonctionnalit\u00e9.</p>"},{"location":"user/studio/gen-ai/features/gen-ai-feature-sentence-generation/#utilisation","title":"Utilisation","text":"<p>Pour utiliser la fonctionnalit\u00e9 de Generate Sentences, rendez-vous au menu FAQs Management :</p> <p></p> <ol> <li>S\u00e9lectionner une ou plusieurs phrases qui serviront de base d'entra\u00eenement.</li> <li>Cliquer sur Modifier puis sur l'onglet Question</li> <li>Cliquer sur l\u2019ampoule, une fen\u00eatre avec de nouveaux param\u00e8tres appara\u00eet :</li> </ol> <p></p> <ol> <li>Choisir la ou les questions qui serviront de base d'entra\u00eenement.</li> <li>Choisir si l\u2019IA doit inclure des fautes d\u2019orthographe, du langage de type SMS et des abr\u00e9viations.</li> <li>La temp\u00e9rature par d\u00e9faut est celle qui a \u00e9t\u00e9 choisie dans les Settings mais elle peut \u00eatre modifi\u00e9e ici selon le besoin.</li> <li>Cliquer sur Generate.</li> </ol> <p>L\u2019IA va g\u00e9n\u00e9rer une liste de variantes de la question s\u00e9lectionn\u00e9e pour l'entra\u00eenement. S\u00e9lectionner les variantes les plus appropri\u00e9es \u00e0 la requ\u00eate et valider la s\u00e9lection.</p> <p>Les phrases  issues de la session d'entra\u00eenement appara\u00eetront alors dans les questions de la FAQ.</p>"},{"location":"user/studio/gen-ai/features/gen-ai-feature-vector-store/","title":"Le menu Gen AI - Vector Store Settings","text":""},{"location":"user/studio/gen-ai/features/gen-ai-feature-vector-store/#configuration","title":"Configuration","text":"<p>Le menu Gen AI - Vector Store Settings permet de configurer la base vectorielle \u00e0 laquelle le RAG du bot sera connect\u00e9.</p> <p>Dans l'IA, les bases vectorielles sont utilis\u00e9es pour repr\u00e9senter des donn\u00e9es sous forme de vecteurs, facilitant des op\u00e9rations comme la similarit\u00e9 s\u00e9mantique ou la classification.  Elles sont notamment utilis\u00e9es dans les mod\u00e8les d'apprentissage automatique pour traiter et analyser des textes, des images ou d'autres types de donn\u00e9es complexes.</p> <p>Pour acc\u00e9der \u00e0 cette page il faut b\u00e9n\u00e9ficier du r\u00f4le botUser. ( plus de d\u00e9tails sur les r\u00f4les dans securit\u00e9 ).</p>"},{"location":"user/studio/gen-ai/features/gen-ai-feature-vector-store/#configuration_1","title":"Configuration","text":"<p>Pour permettre \u00e0 Tock de se connecter \u00e0 une base vectorielle, un \u00e9cran de configuration a \u00e9t\u00e9 mis en place :</p> <p></p>"},{"location":"user/studio/gen-ai/features/gen-ai-feature-vector-store/#utilisation","title":"Utilisation","text":"<ul> <li>Voici la liste des fournisseurs de base vectorielle qui sont pris en compte par Tock.</li> <li>Veuillez vous r\u00e9f\u00e9rer \u00e0 la documentation de chaque outil pour comprendre comment l'utiliser.</li> <li>Si aucune configuration n'a \u00e9t\u00e9 fournie via le Tock studio, la configuration par d\u00e9faut (sp\u00e9cifi\u00e9e via les variable d'environnement) sera privil\u00e9gi\u00e9e :</li> <li>Dans Bot Admin, la variable <code>tock_gen_ai_orchestrator_vector_store</code> sp\u00e9cifie la nature de la base vectorielle par d\u00e9faut. Cela permet \u00e0 Tock, lors d'un appel RAG, de construire correctement les param\u00e8tres de recherche dans cette base.</li> <li>Dans l'Orchestrateur, voici la liste des variables d'environnements \u00e0 pr\u00e9ciser :<ul> <li><code>tock_gen_ai_orchestrator_vector_store_provider</code> Ex: PGVector</li> <li><code>tock_gen_ai_orchestrator_vector_store_host</code> Ex: localhost</li> <li><code>tock_gen_ai_orchestrator_vector_store_port</code> Ex: 5432</li> <li><code>tock_gen_ai_orchestrator_vector_store_user</code> Ex: postgres</li> <li><code>tock_gen_ai_orchestrator_vector_store_pwd</code> Ex: postgres</li> <li><code>tock_gen_ai_orchestrator_vector_store_database</code> Ex: postgres</li> <li><code>tock_gen_ai_orchestrator_vector_store_secret_manager_provider</code> Ex: GCP</li> <li><code>tock_gen_ai_orchestrator_vector_store_credentials_secret_name</code> Ex: my-secret-name</li> </ul> </li> </ul>"},{"location":"user/studio/gen-ai/providers/gen-ai-provider-llm-and-embedding/","title":"Fournisseurs des mod\u00e8les LLM et d'Embedding","text":"<p>Voici la liste des fournisseurs des mod\u00e8les LLM et d'Embedding pris en compte par Tock :</p> Fournisseur de l'IA Configuration du LLM Configuration de l'Embedding  OpenAI (Docs)  <pre>\n{\n  \"provider\": \"OpenAI\",\n  \"api_key\": {\n    \"type\": \"Raw\",\n    \"value\": \"aebb4b****************7b25e3371\"\n  },\n  \"temperature\": \"1.0\",\n  \"prompt\": \"Customized prompt for the use case\",\n  \"model\": \"gpt-3.5-turbo\"\n}\n</pre> <pre>\n{\n  \"provider\": \"OpenAI\",\n  \"api_key\": {\n    \"type\": \"Raw\",\n    \"value\": \"aebb4b****************7b25e3371\"\n  },\n  \"model\": \"text-embedding-ada-002\"\n}\n</pre>  AzureOpenAIService  (Docs)  <pre>\n{\n  \"provider\": \"AzureOpenAIService\",\n  \"api_key\": {\n    \"type\": \"Raw\",\n    \"value\": \"aebb4b****************7b25e3371\"\n  },\n  \"temperature\": \"1.0\",\n  \"prompt\": \"Customized prompt for the use case\",\n  \"api_base\": \"https://custom-api-name.azure-api.net\",\n  \"deployment_name\": \"custom-deployment-name\",\n  \"model\": \"gpt-4o\",\n  \"api_version\": \"2024-03-01-preview\"\n}\n</pre> <pre>\n{\n  \"provider\": \"AzureOpenAIService\",\n  \"api_key\": {\n    \"type\": \"Raw\",\n    \"value\": \"aebb4b****************7b25e3371\"\n  },\n  \"api_base\": \"https://custom-api-name.azure-api.net\",\n  \"deployment_name\": \"custom-deployment-name\",\n  \"model\": \"text-embedding-ada-002\",\n  \"api_version\": \"2024-03-01-preview\"\n}\n</pre>"},{"location":"user/studio/gen-ai/providers/gen-ai-provider-observability/","title":"Fournisseurs d'observabilit\u00e9 des LLMs.","text":"<p>Voici la liste des fournisseurs d'observabilit\u00e9 des LLM pris en compte par Tock :</p> Fournisseur d'observabilit\u00e9 Configuration   `Langfuse`  ([Docs](https://langfuse.com/docs))  <pre>\n{\n  \"provider\": \"Langfuse\",\n  \"url\": \"http://localhost:3000\",\n  \"secret_key\": {\n    \"type\": \"Raw\",\n    \"value\": \"sk-lf-****************-ceabe45abe8f\"\n  },\n  \"public_key\": \"pk-lf-****************-b77e68ef7d2c\"\n}\n</pre>"},{"location":"user/studio/gen-ai/providers/gen-ai-provider-vector-store/","title":"Fournisseurs de base vectorielle.","text":"<p>Voici la liste des fournisseurs de base vectorielle pris en compte par Tock :</p> Fournisseur de base vectorielle Configuration   `OpenSearch`  [Docs](https://opensearch.org/docs/latest/about/)  <pre>\n{\n  \"provider\": \"OpenSearch\",\n  \"host\": \"localhost\",\n  \"port\": \"9200\",\n  \"user\": \"admin\",\n  \"password\": {\n    \"type\": \"Raw\",\n    \"value\": \"admin\"\n  }\n}\n</pre>   `PGVector`  [Docs](https://github.com/pgvector/pgvector)  <pre>\n{\n  \"provider\": \"PGVector\",\n  \"host\": \"localhost\",\n  \"port\": \"5432\",\n  \"user\": \"postgres\",\n  \"password\": {\n    \"type\": \"Raw\",\n    \"value\": \"postgres\"\n  },\n  \"database\": \"postgres\"\n}\n</pre>"},{"location":"fr/","title":"Bienvenue sur Tock : une plateforme conversationnelle ouverte","text":"<p>Tock (The Open Conversation Kit) est une plateforme compl\u00e8te pour construire des agents conversationnels - souvent appel\u00e9s bots. </p> <p>Contrairement \u00e0 la plupart des solutions conversationnelles, Tock ne d\u00e9pend pas d'API tierces, bien qu'il soit possible d'en int\u00e9grer. L'utilisateur choisit les composants qu'il embarque et peut ainsi conserver la ma\u00eetrise de ses mod\u00e8les et donn\u00e9es conversationnelles.</p> <p>Tock est utilis\u00e9 en production depuis 2016 par OUI.sncf (Web/mobile, r\u00e9seaux sociaux, enceintes connect\u00e9es) et de plus en plus d'organisations  (ENEDIS, Linagora, AlloCovid...).</p> <p>L'ensemble du code source est disponible sur GitHub sous  licence Apache 2. </p>"},{"location":"fr/#apercu","title":"Aper\u00e7u","text":"<p>Le site Tock.ai est un bon point d'entr\u00e9e pour d\u00e9couvrir la solution, ses applications et sa communaut\u00e9 grandissante.  Des guides, supports et une video de d\u00e9monstration  (20 minutes, en Anglais) sont \u00e9galement disponibles :</p> <p> </p>"},{"location":"fr/#fonctionnalites","title":"Fonctionnalit\u00e9s","text":"<ul> <li>Assistants autonomes ou int\u00e9gr\u00e9s \u00e0 des sites Web, applications mobiles, r\u00e9seaux sociaux, enceintes connect\u00e9es etc.  sans d\u00e9pendre d'un canal particulier</li> <li>Plateforme NLU compl\u00e8te <sup>(Natural Language Understanding  ou TAL en fran\u00e7ais)</sup><ul> <li>Utilisant des briques open-source comme OpenNLP, Stanford CoreNLP, Duckling, Rasa  (demain Spacy, CamemBERT, ...)</li> <li>D\u00e9ployable seule si besoin pour des usages comme l'Internet des objets</li> </ul> </li> <li>Interfaces Tock Studio :<ul> <li>Gestion des mod\u00e8les, entra\u00eenement du bot et performances</li> <li>Construction de parcours conversationnels et arbres de d\u00e9cision sans code</li> <li>Support de l'internationalisation (i18n) pour les bots multilingues</li> <li>Suivi des conversations et tendances / parcours utilisateurs (Analytics)</li> </ul> </li> <li>Frameworks pour d\u00e9velopper des parcours complexes et int\u00e9grer des services tiers :  DSLs en  Kotlin, Javascript/Nodejs, Python  et API tous langages (voir Bot API)</li> <li>Nombreux connecteurs texte et voix : Messenger, WhatsApp,  Google Assistant, Alexa, Twitter,  Apple Business Chat, Teams,  Slack... (voir canaux)</li> <li>Installation cloud ou on-premise, avec ou sans Docker,  m\u00eame \"embarqu\u00e9\" sans Internet </li> </ul>"},{"location":"fr/#technologies","title":"Technologies","text":"<p>L'ensemble de la plateforme peut fonctionner conteneuris\u00e9e (impl\u00e9mentation Docker fournie). </p> <p>La plateforme applicative par d\u00e9faut est la JVM.  Le langage de r\u00e9f\u00e9rence est Kotlin mais d'autres langages de programmation peuvent \u00eatre utilis\u00e9s via les API mises \u00e0 disposition.</p> <p>C\u00f4t\u00e9 serveur, Tock utilise Vert.x et MongoDB <sup>(alt. DocumentDB)</sup>.  Diff\u00e9rentes briques NLU peuvent \u00eatre utilis\u00e9es, mais Tock n'a pas de d\u00e9pendance forte envers l'une d'elles.</p> <p>Les interfaces graphiques Tock Studio sont \u00e9crites avec Angular en Typescript.</p> <p>Des int\u00e9grations React et Flutter sont fournies pour les interfaces Web et Mobile.</p>"},{"location":"fr/#demarrer","title":"D\u00e9marrer...","text":"<ul> <li>Table des mati\u00e8res</li> <li>Guides et plateforme de d\u00e9monstration</li> <li>Manuels utilisateur, d\u00e9veloppeur, administrateur</li> <li>Ressources (supports, video) et exemples de code</li> </ul> <p>*NLU: Natural Language Understanding</p>"},{"location":"fr/about/awards/","title":"Prix et r\u00e9compenses","text":"<p>Depuis sa cr\u00e9ation pour OUI.sncf en 2016 jusqu'au service AlloCovid en 2020, la solution technique et  les bots cr\u00e9\u00e9s avec Tock ont \u00e9t\u00e9 r\u00e9compens\u00e9s par plusieurs prix.</p> <p>Un grand merci aux organisateurs de ces \u00e9v\u00e9nements, aux entreprises qui soutiennent Tock (notamment SNCF et TOSIT) ainsi qu'\u00e0 la communaut\u00e9 \ud83d\ude42</p>"},{"location":"fr/about/awards/#meilleure-strategie-open-source-2019-sncf","title":"Meilleure Strat\u00e9gie Open Source 2019 (SNCF)","text":"<p>En d\u00e9cembre 2019, le prix Les Acteurs du Libre de la  Meilleure Strat\u00e9gie Open Source a r\u00e9compens\u00e9 la SNCF pour sa d\u00e9marche et le partage de plateformes ouvertes comme  Tock (filiale e.Voyageurs)  et Navitia (filiale Kisio Digital).</p> <p></p> <p>La remise du prix \u00e0 Simon Clavier et Fran\u00e7ois Nollen  eut lieu le 10 d\u00e9cembre dans le Grand Auditorium du Paris Open Source Summit. Quelques photos et  la captation vid\u00e9o sont disponibles.</p> <p>Pour en savoir plus, voir aussi Les Acteurs Du Libre.</p>"},{"location":"fr/about/awards/#best-robot-experience-2019-ouisncf","title":"Best Robot Experience 2019 (OUI.sncf)","text":"<p>En 2019, OUIbot a re\u00e7u le prix  Best Robot Experience  pour la deuxi\u00e8me ann\u00e9e cons\u00e9cutive.</p> <p>Re\u00e7u par Caroline Chupin et   Evelyne Papon pour OUI.sncf,  le prix a d\u00e9partag\u00e9 cette fois pas moins de 31 robots, chatbots et voicebots. </p> <p>Une interview est disponible en ligne. Voir aussi le blog Cultures Services.</p>"},{"location":"fr/about/awards/#best-robot-experience-2018-ouisncf","title":"Best Robot Experience 2018 (OUI.sncf)","text":"<p>En 2018, OUIbot l'assistant OUI.sncf qui accompagne pr\u00e8s de 10 000 utilisateurs  par jour a \u00e9t\u00e9 \u00e9lu Best Robot Experience  par l'Acad\u00e9mie du Service / Sens du client.</p> <p>Le prix remis \u00e0 Caroline Chupin pour OUI.sncf a d\u00e9partag\u00e9 24 agents virtuels propos\u00e9s par des organisations prestigieuses (grandes entreprises, GAFAM, minist\u00e8res) sur la base de crit\u00e8res comme la rapidit\u00e9, la logique et la simplicit\u00e9. </p> <p></p> <p>Pour en savoir plus, voir le blog Sens du client.</p>"},{"location":"fr/about/community/","title":"Communaut\u00e9 Tock","text":"<p>Tock est b\u00e2ti sur un mod\u00e8le communautaire pour cr\u00e9er une plateforme ouverte. Pour en savoir plus, voir pourquoi Tock.</p> <p>La communaut\u00e9 Tock est ouverte \u00e0 la contribution et tous les retours comme les feature requests et  pull requests sont les bienvenus !</p>"},{"location":"fr/about/community/#rejoindre-la-communaute-gitter","title":"Rejoindre la communaut\u00e9 (Gitter)","text":"<p>La plupart des utilisateurs et contributeurs Tock se retrouvent sur la messagerie instantann\u00e9e   Gitter. C'est un bon moyen de voir \u00e0 quel point la communaut\u00e9 est active et accessible.</p> <ul> <li>Communaut\u00e9 Tock sur Gitter</li> <li>Fil Gitter des releases Tock</li> </ul> <p> </p>"},{"location":"fr/about/community/#suivre-lactualite-de-la-plateforme","title":"Suivre l'actualit\u00e9 de la plateforme","text":"<p>Pour suivre l'actualit\u00e9 des projets Tock mais aussi les meetups, conf\u00e9rences, etc.,  rendez-vous sur le site principal :</p> <ul> <li>Tock.ai</li> </ul> <p>Vous pouvez \u00e9galement retrouver les nouveaut\u00e9s dans ces pages plus sp\u00e9cfiques :</p> <ul> <li>Projets &amp; utilisateurs connus</li> <li>Pr\u00e9sentations &amp; conf\u00e9rences</li> <li>Prix &amp; r\u00e9compenses</li> </ul> <p>Enfin, pour suivre les versions et fonctionnalit\u00e9s de Tock :</p> <ul> <li>Fil Gitter des releases &amp; features</li> <li>Release Notes</li> <li>Roadmap</li> </ul>"},{"location":"fr/about/community/#code-contribution-github","title":"Code &amp; Contribution (GitHub)","text":"<p>L'ensemble de la plateforme et des outils est partag\u00e9 sur  GitHub sous licence Apache 2.</p> <ul> <li>Sources &amp; Projets</li> <li>Licence</li> <li>Issues</li> <li>Contributeurs</li> </ul> <p>Pour en savoir plus sur l'organisation des d\u00e9p\u00f4ts, les conventions de code, etc. voir le guide de contribution Tock. Pour tout autre forme de contribution, n'h\u00e9sitez pas \u00e0 utiliser les issues  GitHub et \u00e0 contacter directement la communaut\u00e9 avec Gitter.</p> <p> </p>"},{"location":"fr/about/community/#association-tosit","title":"Association TOSIT","text":"<p>La solution Tock est actuellement activement \u00e9tudi\u00e9e et exp\u00e9riment\u00e9e par l'association  TOSIT (The Open Source I Trust),  une structure de soutien \u00e0 l\u2019Open Source  qui vise \u00e0 soutenir l\u2019\u00e9mergence de codes, logiciels et   solutions informatiques sous licence open source et/ou licence libre.</p> <p>Fond\u00e9e par Carrefour, EDF, Enedis, Orange, P\u00f4le Emploi et SNCF, TOSIT compte depuis d'autres membres  importants comme Le Minist\u00e8re des Arm\u00e9es, Soci\u00e9t\u00e9 G\u00e9n\u00e9rale ou MAIF par exemple.</p> <p>Tock s'inscrit dans le cadre du Groupe de Travail Chatbots du TOSIT.</p> <p>La solution est d'ores et d\u00e9j\u00e0 utilis\u00e9e par plusieurs membres du TOSIT, dont SNCF.</p> <p>Pour en savoir plus, voir le site de l'association : http://tosit.fr/</p> <p></p>"},{"location":"fr/about/community/#hebergement-de-la-demo-publique","title":"H\u00e9bergement de la D\u00e9mo publique","text":"<p>La plateforme publique de d\u00e9monstration Tock est destin\u00e9e \u00e0 faciliter la prise en main de  la solution. Elle est accompagn\u00e9e d'un guide pour faire ses premiers pas. Merci \u00e0 e.Voyageurs SNCF qui h\u00e9berge et maintient cette  plateforme de d\u00e9mo en ligne.</p> <ul> <li>Plateforme D\u00e9mo en ligne </li> <li>Guide Cr\u00e9er son 1er bot avec Tock</li> </ul>"},{"location":"fr/about/community/#aide","title":"Aide","text":"<p>Que ce soit pour de l'aide, des questions, des suggestions : n'h\u00e9sitez pas \u00e0 nous contacter.</p>"},{"location":"fr/about/contact/","title":"Nous contacter","text":"<p>D\u00e9veloppeurs, utilisateurs ou juste curieux, n'h\u00e9sitez pas \u00e0 contacter les cr\u00e9ateurs de la solution et  d'autres membres de la communaut\u00e9 pour \u00e9changer sur Tock.</p> <ul> <li>Vous pouvez nous retrouver sur Gitter (la messagerie  instantann\u00e9e pour GitHub) : https://gitter.im/tockchat/Lobby</li> </ul> <p> </p> <ul> <li>Les issues GitHub permettent aussi de remonter une anomalie ou proposer une \u00e9volution : https://github.com/theopenconversationkit/tock/issues</li> </ul> <p> </p>"},{"location":"fr/about/contribute/","title":"Contribuer \u00e0 Tock","text":"<p>Le projet Tock est ouvert \u00e0 la contribution et toute proposition est la bienvenue !</p> <p>Cette page donne des indications sur la structure et les conventions du code de la plateforme.</p>"},{"location":"fr/about/contribute/#tldr","title":"TL;DR","text":"<p>Voir <code>CONTRIBUTING.md</code>  (anglais uniquement).</p>"},{"location":"fr/about/contribute/#principales-technologies","title":"Principales technologies","text":"<p>L'ensemble de la plateforme peut fonctionner conteneuris\u00e9e (impl\u00e9mentation Docker fournie). </p> <p>La plateforme applicative par d\u00e9faut est la JVM.  Le langage de r\u00e9f\u00e9rence est Kotlin mais d'autres langages de programmation peuvent \u00eatre utilis\u00e9s via les API mises \u00e0 disposition.</p> <p>C\u00f4t\u00e9 serveur, Tock utilise Vert.x et MongoDB <sup>(alt. DocumentDB)</sup>.  Diff\u00e9rentes briques NLU peuvent \u00eatre utilis\u00e9es, mais Tock n'a pas de d\u00e9pendance forte envers l'une d'elles.</p> <p>Les interfaces graphiques Tock Studio sont \u00e9crites avec Angular en Typescript.</p> <p>Des int\u00e9grations React et Flutter sont fournies pour les interfaces Web et Mobile.</p>"},{"location":"fr/about/contribute/#structure-des-sources","title":"Structure des sources","text":""},{"location":"fr/about/contribute/#les-depots","title":"Les d\u00e9p\u00f4ts","text":"<ul> <li> <p><code>tock</code> : d\u00e9p\u00f4t principal comprend le framework et les composants  de la plateforme sous licence Apache 2. </p> </li> <li> <p><code>tock-corenlp</code> : code utilisant une d\u00e9pendance optionnelle \u00e0  Stanford CoreNLP (\u00e0 la place d'Apache OpenNLP),  sous licence GPL. </p> </li> <li> <p><code>tock-docker</code> : des images Docker  et Docker Compose, pour faciliter la prise en main et le d\u00e9ploiement de la plateforme dans diff\u00e9rentes configurations.</p> </li> <li> <p><code>tock-bot-samples</code> : des exemples de code notamment pour programmer des parcours en mode WebHook ou WebSocket  comme dans les guides Tock.</p> </li> <li> <p><code>tock-bot-open-data</code> : un exemple de bot bas\u00e9  sur les API Open Data de la SNCF, impl\u00e9mentant \u00e9galement des bases pour  l'internationalisation avec deux langues propos\u00e9es.</p> </li> </ul>"},{"location":"fr/about/contribute/#le-depot-tock","title":"Le d\u00e9p\u00f4t <code>tock</code>","text":"<p>Voici une premi\u00e8re description des sources dans le d\u00e9p\u00f4t <code>tock</code> :</p> <ul> <li><code>bot</code> : la plateforme conversationnelle (interfaces, API, connecteurs, etc.), en d\u00e9pendance sur les modules NLU</li> <li><code>docs</code> : le sites de documentation, g\u00e9n\u00e9r\u00e9s avec MkDocs</li> <li><code>docs-mk</code> : les sources pour les sites de documentation, pour MkDocs</li> <li><code>dokka</code> : la documentation Dokka du framework Kotlin</li> <li><code>etc</code> : des scripts utilitaires, par exemple pour g\u00e9n\u00e9rer les sites avec MkDocs</li> <li><code>nlp</code> : la plateforme NLU uniquement (interfaces, API, mod\u00e8les d'entit\u00e9s, etc.) </li> <li><code>scripts</code> : d'autres scripts utilitaires, par exemple pour d\u00e9velopper sur Messenger avec ngrok</li> <li><code>shared</code> : des composants Kotlin partag\u00e9s entre les diff\u00e9rents modules du framework</li> <li><code>stt</code> : des impl\u00e9mentations et wrappers pour le speech-to-text</li> <li><code>translator</code> : des impl\u00e9mentations et wrappers pour le multilingue (i18n)</li> </ul> <p>Remarque : il existe \"deux admin\" (ie. deux interfaces Tock Studio) dans les sources. En effet, il est possible  d'installer la plateforme NLU / NLP seule sans les outils conversationnels. En cons\u00e9quence :</p> <ul> <li><code>nlp/admin</code> : contient les composants et interfaces graphiques pour le NLU / NLP seulement</li> <li><code>bot/admin</code> : reprend les composants NLP / NLU (en d\u00e9pendance dans le build Maven) et reconstruit les interfaces  en y ajoutant les outils conversationnels  </li> </ul>"},{"location":"fr/about/contribute/#le-depot-tock-docker","title":"Le d\u00e9p\u00f4t <code>tock-docker</code>","text":"<p>Le d\u00e9p\u00f4t contient une structure de modules Maven reprenant les diff\u00e9rents composants de la plateforme Tock.  Chacun de ces modules porte une impl\u00e9mentation Docker du composant en s'appuie sur le plugin Maven  <code>io.fabric8:docker-maven-plugin</code> pour encapsuler le build Docker.</p> <p>A la racine du d\u00e9p\u00f4t se trouvent diff\u00e9rents descripteurs Docker Compose permettant de d\u00e9ployer une plateforme  en se basant sur les images d\u00e9j\u00e0 construites. Diff\u00e9rentes configurations existent, notamment en mode Bot API  ou en mode int\u00e9gr\u00e9, avec la plateforme NLU standalone, etc. Le descripteur de r\u00e9f\u00e9rence pour le mode  Bot API est <code>docker-compose-bot.yml</code>.</p>"},{"location":"fr/about/contribute/#construire-tock-a-partir-des-sources","title":"Construire Tock \u00e0 partir des sources","text":""},{"location":"fr/about/contribute/#tock-core","title":"Tock (core)","text":"<p>Le projet est construit avec Maven, y compris les modules Web impliquant  NPM et Angular :</p> <p><code>$ mvn package</code></p> <p>Un build d'int\u00e9gration continue est disponible sur Travis.</p>"},{"location":"fr/about/contribute/#images-docker","title":"Images Docker","text":"<p>Les images Docker de Tock peuvent \u00eatre reconstruites \u00e0 partir des sources du d\u00e9p\u00f4t <code>tock-docker</code>. Pour cela, utilisez Maven qui d\u00e9clenchera le build Docker :</p> <p><code>$ mvn package docker:build</code></p> <p>Vous pouvez ensuite instancier ces images via Docker ou les stacks Docker Compose avec les descripteurs \u00e0 la racine du d\u00e9p\u00f4t.</p>"},{"location":"fr/about/contribute/#executer-dans-un-ide","title":"Ex\u00e9cuter dans un IDE","text":"<p>Pour d\u00e9marrer Tock avec Docker Compose hors d'un IDE, voir D\u00e9ployer Tock avec Docker.</p> <p>Les diff\u00e9rents composants Tock peuvent s'ex\u00e9cuter depuis un IDE (environnement de d\u00e9veloppement int\u00e9gr\u00e9).  Des configurations sont fournies pour IntelliJ.</p> <p>Voir la section Installation Tock.  </p> <p>Pour ex\u00e9cuter le bot/exemple en mode int\u00e9gr\u00e9, une configuration est aussi disponible : OpenDataBot.</p>"},{"location":"fr/about/contribute/#commits-merge-requests","title":"Commits &amp; merge requests","text":"<p>Pour soumettre une \u00e9volution ou un correctif :</p> <ol> <li>Cr\u00e9er une issue:<ul> <li>Format recommand\u00e9 pour le titre :<ul> <li><code>[Component] Title</code></li> <li>De pr\u00e9f\u00e9rence en anglais</li> <li>Composant : par exemple  Studio, Core, Doc, etc.</li> <li>Titre : par exemple Do or fix something</li> </ul> </li> </ul> </li> <li>Cr\u00e9er une pull request et la lier \u00e0 l'issue:<ul> <li>Tous les commits doivent \u00eatre sign\u00e9s </li> <li>SVP rebase ou squash les commits superflus<ul> <li>Astuce : vous pouvez noter la PR comme Draft avant de la soumettre</li> </ul> </li> <li>Format recommand\u00e9 pour le nom de la branche :<ul> <li><code>ISSUEID_short_title</code></li> </ul> </li> <li>Format recommand\u00e9 pour le(s) message(s) de commit(s) :<ul> <li><code>resolves #ISSUEID Component: title</code> pour les \u00e9volutions</li> <li><code>fixes #ISSUEID Component: title</code> pour les correctifs</li> </ul> </li> </ul> </li> <li>Avant d'\u00eatre int\u00e9gr\u00e9e, une pull request doit passer les tests et \u00eatre approuv\u00e9e par au moins deux de ces d\u00e9veloppeurs :<ul> <li>@vsct-jburet, @francoisno, @NainJaune, @elebescond, @SarukaUsagi, @MaximeLeFrancois, @bakic, @broxmik, @mrboizo</li> </ul> </li> </ol>"},{"location":"fr/about/contribute/#conventions-de-code","title":"Conventions de code","text":"<p>Les Kotlin Code Conventions sont utilis\u00e9es pour  d\u00e9velopper le code de Tock.</p>"},{"location":"fr/about/contribute/#tests-unitaires","title":"Tests unitaires","text":"<p>Chaque nouvelle \u00e9volution ou correctif devrait embarquer ses tests unitaires.</p>"},{"location":"fr/about/contribute/#nous-contacter","title":"Nous contacter","text":"<p>Un probl\u00e8me ? Une question sur l'impl\u00e9mentation ? Une id\u00e9e \u00e0 partager ?</p> <p>Pour contribuer au projet ou simplement en savoir plus, n'h\u00e9sitez pas \u00e0 nous contacter.</p>"},{"location":"fr/about/jobs/","title":"Emplois Tock","text":"<p>Int\u00e9ress\u00e9(e) par travailler avec Tock et contribuer \u00e0 la plateforme ?</p> <p>Cette page recense des entreprises et organisations proposants des offres d'emploi dans le domaine conversationnel avec Tock :</p> e.Voyageurs SNCF (\u00e0 l'origine du projet) recrute pour d\u00e9velopper des assistants conversationnels avec Tock. Pour en savoir plus, rendez-vous sur Gitter ou sur https://jobs.oui.sncf/. <p>Vous utilisez Tock et proposez des offres d'emploi en conversationnel ?</p> <p>N'h\u00e9sitez pas \u00e0 nous le signaler pour enrichir cette liste.</p>"},{"location":"fr/about/ressources/","title":"Ressources Tock","text":"<p>Les diff\u00e9rents supports et pr\u00e9sentations ci-dessous donnent un aper\u00e7u de la solution Tock,  en compl\u00e9ment des guides  pour tester soi-m\u00eame la plateforme.</p>"},{"location":"fr/about/ressources/#conferences-video","title":"Conf\u00e9rences / Video","text":"<ul> <li>Gen AI with TOCK @ WAX 2024 (RAG et LLM Open Source ? Vers des IA G\u00e9n\u00e9ratives plus responsables.)   \u2139\ufe0f info \ud83d\udcfd\ufe0f 45 min</li> </ul> <ul> <li>20 minutes from zero to live chatbot with Tock   @ Open Source Experience 2021 (d\u00e9monstration, en Anglais)   \u2139\ufe0f info /   \ud83d\udcfd\ufe0f 20 min</li> </ul> <ul> <li>AlloCovid @ Voice Tech Paris 2020 (REX INSERM, Allo-Media &amp; SNCF)   \u2139\ufe0f info</li> </ul> <ul> <li>Tock &amp; M\u00e9lusine @ AI Paris 2020 (REX SNCF &amp; MAIF) \u2139\ufe0f info / \ud83d\udd33 slides</li> </ul> <ul> <li>Conversationnel &amp; Open Source @ Paris Open Source Summit 2019 (REX SNCF &amp; invit\u00e9s EDF, Enedis, Orange, SogetiLabs, TOSIT) \ud83d\udcfd\ufe0f 30 min /  \ud83d\udd33 slides</li> </ul> <ul> <li>D\u00e9velopper un bot sur Messenger et Google Assistant en 30 minutes @ Devoxx France 2018 (live coding \"tools in action\") \ud83d\udcfd\ufe0f 30 min</li> </ul>"},{"location":"fr/about/ressources/#meetup-supports","title":"Meetup / Supports","text":"<ul> <li>Pr\u00e9sentation de Tock (avec SNCF &amp; Enedis)   @ Innovation Makers Alliance (2021) \u2139\ufe0f info</li> </ul> <ul> <li>Tock - The Open Conversation Kit  @ Meetup Open Transport (2019) \ud83d\udd33 slides</li> </ul> <ul> <li>Tock - The Open Conversation Kit  @ CRiP OpenSource &amp; Co-d\u00e9veloppement (2017) \ud83d\udd33 slides</li> </ul> <p>N'h\u00e9sitez pas \u00e0 partager d'autres supports et liens autour de Tock.</p>"},{"location":"fr/about/ressources/#kit-presse","title":"Kit presse","text":"<p>Comme le reste des sources Tock, les logos sont disponibles sous licence Apache 2.</p> <p>Logo Tock - couleurs par d\u00e9faut / transparent (t\u00e9l\u00e9charger) :</p> <p></p> <p>Logo Tock - bleu / transparent (t\u00e9l\u00e9charger) :</p> <p></p> <p>Logo Tock - noir / transparent (t\u00e9l\u00e9charger) :</p> <p></p> <p>Logo Tock - blanc / transparent (t\u00e9l\u00e9charger) :</p> <p></p>"},{"location":"fr/about/showcase/","title":"Vitrine utilisateurs","text":"<p>Depuis sa cr\u00e9ation pour OUI.sncf en 2016 en passant par le service AlloCovid en 2020, Tock est utilis\u00e9 par de plus en plus d'\u00e9quipes et d'organisations pour cr\u00e9er des bots conversationnels d\u00e9di\u00e9s \u00e0 des usages divers :</p> <ul> <li>domaines : sant\u00e9, transport, \u00e9nergie, e-commerce...</li> <li>business to customer et business to business </li> <li>FAQ et arbres de d\u00e9cision \"0 code\"</li> <li>assistance, selfcare ou bascule \u00e0 un conseiller</li> <li>transactionnel (devis/r\u00e9servations/paiements, help desks, supervision, etc.)</li> <li>canaux : texte &amp; voix (Web &amp; mobile, messageries, enceintes connect\u00e9es, t\u00e9l\u00e9phonie)</li> </ul> <p>Cette page pr\u00e9sente diff\u00e9rents assistants et produits connus construits avec Tock,  dont certains ont \u00e9t\u00e9 r\u00e9compens\u00e9s par la communaut\u00e9.</p>"},{"location":"fr/about/showcase/#sante","title":"Sant\u00e9","text":""},{"location":"fr/about/showcase/#allocovid","title":"AlloCovid","text":"<p>Le service AlloCovid permet d'informer et d'orienter la population sur  le Covid-19, reprenant le questionnaire pr\u00e9d\u00e9fini par le Minist\u00e8re de la Sant\u00e9.</p> <p>IA vocale engag\u00e9e dans la crise sanitaire</p> <p>Ce service conversationnel est le fruit de la collaboration de nombreux experts fran\u00e7ais,  partenaires technologiques et b\u00e9n\u00e9voles. Pour en savoir sur la g\u00e9n\u00e8se du projet, l'\u00e9quipe et les partenaires, le  fonctionnement du bot, la presse, etc.  rendez-vous sur www.allocovid.com.</p> <p>Disponible par t\u00e9l\u00e9phone, sur le Web et WhatsApp, AlloCovid est construit autour d'un bot Tock et int\u00e8gre des solutions compl\u00e9mentaires  comme les technologies vocales Allo-Media et Voxygen. </p> <p>Le bot AlloCovid est construit autour de technologies open source (\u00e0 travers la plateforme Tock),  et lui-m\u00eame open source : les sources du bot sont disponibles sur le d\u00e9p\u00f4t <code>allocovid</code>.</p> <p>Avec les sources du bot on trouve \u00e9galement celles du connecteur Allo-Media,  quelques explications techniques sur le bot et la sp\u00e9cification fonctionnelle  du questionnaire Covid.</p> <p></p> <ul> <li>Nom : AlloCovid</li> <li>Date de naissance : en production au printemps 2020</li> <li>Domaine : informations sanitaires et orientation vers les services de sant\u00e9</li> <li>Canaux : texte &amp; voix, par t\u00e9l\u00e9phone, sur WhatsApp et site Web</li> </ul>"},{"location":"fr/about/showcase/#ouibot-le-bot-ouisncf","title":"OUIbot, le bot OUI.sncf","text":"<p>OUIbot est l'assistant conversationnel de OUI.sncf. Disponible depuis 2016  sur le r\u00e9seau social Facebook Messenger, OUIbot s'est construit avec les premi\u00e8res versions de Tock.</p> <p>Avec OUIbot, r\u00e9server un billet de train n'a jamais \u00e9t\u00e9 aussi simple ! Il vous assiste dans la pr\u00e9paration de vos  voyages, permet d'effectuer rapidement et simplement une r\u00e9servation compl\u00e8te, de la recherche \u00e0 l'achat (paiement inclus),  et vous accompagne durant votre voyage.</p> <p>Gr\u00e2ce aux nombreux connecteurs Tock, OUIbot r\u00e9pond pr\u00e9sent sur de nombreux canaux conversationnels :  site www.oui.sncf, r\u00e9seaux sociaux, assistants vocaux, enceintes connect\u00e9es et m\u00eame   IAffiches avec JCDecaux.</p> <p>En 2019, OUIbot accompagne pr\u00e8s de 10 000 utilisateurs par jour. Il a \u00e9t\u00e9 \u00e9lu Best Robot Experience  pour la deuxi\u00e8me ann\u00e9e cons\u00e9cutive.</p> <p></p> <ul> <li>Nom : OUIbot</li> <li>Date de naissance : en production depuis 2016</li> <li>Domaine : distribution, transactionnel (r\u00e9servations, paiements), alertes &amp; push notifications, relai vers un agent</li> <li>Canaux : texte &amp; voix, sur le site Web entreprise, Messenger, WhatsApp, Business Chat (Messages), Google Assistant,  Google Home, Alexa, IAffiches JCDecaux</li> </ul>"},{"location":"fr/about/showcase/#lassistant-sncf","title":"L'Assistant SNCF","text":"<p>L'Assistant SNCF est l'application mobile des voyageurs SNCF sur Android et iOS, couvrant le train mais aussi d'autres modes de transport.</p> <p>Avec l\u2019Assistant SNCF, vous pouvez calculer votre itin\u00e9raire, rester inform\u00e9 en temps r\u00e9el, acheter directement vos tickets de transport ou encore r\u00e9server votre course en VTC. En attendant de nouvelles fonctionnalit\u00e9s \u00e0 venir.</p> <p>Accessible via le \"microphone\" dans l'application mobile, le bot conversationnel de l'Assistant SNCF est construit avec Tock et les fonctions speech-to-text Android et iOS.</p> <p></p> <ul> <li>Nom : L'Assistant SNCF</li> <li>Date de naissance : en production, fonction vocale Tock depuis 2019</li> <li>Domaine : voyage &amp; transport (recherche itin\u00e9raires en multi-modal, etc.)</li> <li>Canaux : vocal, sur l'application mobile SNCF pour Android et iOS</li> </ul>"},{"location":"fr/about/showcase/#tilien-le-chatbot-transilien","title":"Tilien, le chatbot Transilien","text":"<p>Tilien est le chatbot Transilien sur Messenger.</p> <p>Con\u00e7u comme un compagnon de voyage personnel et amical, il informe des prochains d\u00e9parts, l'\u00e9tat du trafic, les travaux en cours et \u00e0 venir, propose des itin\u00e9raires et bien d'autres choses (plans des lignes, fiches horaires, etc.) sur l'ensemble du r\u00e9seau ferr\u00e9 Ile-De-France : M\u00e9tro, RER, Transilien, Tram.</p> <p>Motoris\u00e9 par Tock, le chatbot vous attend sur Facebook Messenger pour offrir ses services.</p> <p></p> <ul> <li>Nom : Tilien</li> <li>Date de naissance : en production, depuis 2018 sur Tock</li> <li>Domaine : transport &amp; assistance (recherche itin\u00e9raires, plans des lignes, \u00e9tat du trafic, etc.)</li> <li>Canaux : texte, sur Messenger (botsncftransilien)</li> </ul>"},{"location":"fr/about/showcase/#mon-assistant-tgv-inoui","title":"Mon Assistant TGV INOUI","text":"<p>Mon Assistant informe les clients et voyageurs de la marque TGV INOUI avant, pendant et apr\u00e8s leur trajet.</p> <p>Le chatbot est capable de donner l'\u00e9tat du trafic, le quai de d\u00e9part d'un train, la ou les places du client, les services \u00e0 bord (le bar, les prises \u00e9lectriques, etc.). Il permet aussi de parler avec un agent SNCF tout en restant dans la m\u00eame conversation.</p> <p>Pr\u00e9sent sur la page Facebook TGV INOUI et le portail Wifi \u00e0 Bord, l'assistant s'appuie sur Tock et le <code>tock-react-kit</code>.</p> <p></p> <ul> <li>Nom : Mon Assistant TGV INOUI</li> <li>Date de naissance : en production depuis 2019</li> <li>Domaine : assistance &amp; info voyageur (info quai, infos voyage en cours, services \u00e0 bord), relai vers un agent</li> <li>Canaux : texte, sur le portail Wifi \u00e0 Bord   et Messenger (TGV INOUI)</li> </ul>"},{"location":"fr/about/showcase/#lagent-virtuel-sncf","title":"L'Agent virtuel SNCF","text":"<p>L'Agent virtuel SNCF pr\u00e9sente de mani\u00e8re conversationnelle l'information voyageur et les \u00e9ventuelles perturbations sur tous les trains (TGV, IC, TER, Eurostar...).</p> <p>On peut interroger le bot par num\u00e9ro de train, dossier voyageur, prochains d\u00e9parts, etc. pour obtenir les derni\u00e8res informations et l'\u00e9tat du trafic, ou encore parler \u00e0 un Agent.</p> <p>Accessible sur le site Web sncf.com, la page Facebook et la page Twitter de la SNCF, l'Agent virtuel est bas\u00e9 sur Tock et utilise le <code>tock-react-kit</code> pour l'int\u00e9gration Web.</p> <p></p> <ul> <li>Nom : Agent virtuel SNCF</li> <li>Date de naissance : en production depuis 2019</li> <li>Domaine : voyage &amp; transport (\u00e9tat du trafic, travaux, prochains d\u00e9parts), relai vers un agent</li> <li>Canaux : texte, sur sncf.com   (lien direct), Messenger (SNCFOFFICIEL) et   Twitter (@sncf)</li> </ul>"},{"location":"fr/about/showcase/#energie","title":"Energie","text":""},{"location":"fr/about/showcase/#callbot-edf","title":"Callbot EDF","text":"<p>Sous la forme d'un POC (Proof Of Concept) pour \u00e9prouver un cas d'usage, un callbot a \u00e9t\u00e9 con\u00e7u par la Direction des Syst\u00e8mes d'Informations et du Num\u00e9rique (DSIN) d'EDF Commerce.</p> <p>Il a la particularit\u00e9 d'\u00eatre con\u00e7u pour pouvoir fonctionner avec la solution de t\u00e9l\u00e9phonie (Genesys) afin de pouvoir router les appels clients vers la bonne comp\u00e9tence humarine ou automatis\u00e9e. Il permet par ailleurs de transf\u00e9rer le contexte de la conversation qu'il y a eu entre le client et le callbot aupr\u00e8s du conseiller client\u00e8le.</p> <p>Le callbot est construit avec Tock et utilise le connecteur Allo-Media. La solution de Speech-To-Text (STT) utilis\u00e9e est Allo-Media, et la solution de Text-To-Speech (TTS) est Voxygen.</p> <p></p> <ul> <li>Nom : Callbot EDF</li> <li>Date de naissance : janvier 2021</li> <li>Domaine : Relation Client / Conseiller</li> <li>Canaux : voix (t\u00e9l\u00e9phonie)</li> </ul>"},{"location":"fr/about/showcase/#chatbots-enedis","title":"Chatbots Enedis","text":"<p>Plusieurs chatbots Enedis sont con\u00e7us avec la solution Tock.</p> <p>Le Chatbot clients Enedis permet aux 35 millions de clients Enedis de poser des  questions li\u00e9es \u00e0 l'\u00e9nergie, sans n\u00e9cessit\u00e9 de prendre contact avec un conseiller.</p> <p>Cet agent conversationnel permet un premier niveau de prise en charge des sollicitations clients,  adressant des questions simples et non personnalis\u00e9es sur diff\u00e9rentes th\u00e9matiques (espace client, compteur Linky,  demandes de raccordement, d\u00e9pannage, etc.). Il propose \u00e9galement un transfert vers un Live Chat o\u00f9 le client pourra  \u00e9changer avec un conseiller en cas d\u2019impossibilit\u00e9 du chatbot \u00e0 r\u00e9pondre \u00e0 la demande.</p> <p>Co-construit avec des experts m\u00e9tiers Enedis sur la solution Tock, ce chatbot est disponible  sur le site Enedis.fr.</p> <p></p> <ul> <li>Nom : Chatbot clients Enedis</li> <li>Date de naissance : en production depuis f\u00e9vrier 2021</li> <li>Domaine : tous les m\u00e9tiers de l'\u00e9nergie</li> <li>Canaux : texte, sur le site Enedis.fr</li> </ul> <p>Voir aussi le Chatbot interne Enedis, \u00e9galement con\u00e7u avec Tock  pour un usage interne \u00e0 l'entreprise depuis 2020.</p>"},{"location":"fr/about/showcase/#banque","title":"Banque","text":""},{"location":"fr/about/showcase/#maxbot-bot-bancaire-chez-aumax-pour-moi","title":"MaxBot, bot bancaire chez Aumax pour moi","text":"<p>Aumax pour moi est une application qui vous permet de regrouper tous vos comptes et toutes vos cartes dans un seul et m\u00eame endroit. Vous facilitez votre quotidien en n'utilisant qu'une seule application et une unique carte. Pour vous accompagner au quotidien, Aumax pour moi vous permet :</p> <ul> <li>de gagner du cashback ; </li> <li>d'envoyer et recevoir de l'argent ;</li> <li>de faire appel \u00e0 un service de conciergerie ;</li> <li>de demander des conseils d'ordres financiers, pour des projets de vie etc. </li> <li>et bien plus encore !</li> </ul> <p></p> <p>Au sein de cette application, le bot Aumax pour moi, bas\u00e9 sur Tock, vous assiste sur toutes les questions d'ordre pratique, sur le fonctionnement de l'application, de vos comptes et de la carte max.</p> <p>Le bot est disponible sur le chat de l'application Aumax pour moi. Aumax pour moi prend en charge et r\u00e9pond \u00e0 pr\u00e8s de 5 000 sollicitations quotidiennes. </p> <ul> <li>Nom : Aumax pour moi</li> <li>Date de naissance : en production depuis 2019</li> <li>Domaine : bancaire, service, assistant personnel </li> <li>Canaux : texte, sur l'application mobile</li> </ul>"},{"location":"fr/about/showcase/#assistants-personnels","title":"Assistants personnels","text":""},{"location":"fr/about/showcase/#linto-by-linagora","title":"LinTO by Linagora","text":"<p>La plateforme LinTO est une bo\u00eete \u00e0 outils Open Source permettant le d\u00e9veloppement et l'int\u00e9gration de processus d\u2019interactions vocales r\u00e9pondant aux besoins des professionnels et de l\u2019industrie.</p> <p>LinTO est un assistant intelligent Open Source con\u00e7u par LINAGORA : bas\u00e9 exclusivement sur des technologies Open Source, LinTO est pr\u00eat pour le cloud mais sans GAFAM (Google-Amazon-Facebook-Apple-Microsoft), et respecte votre vie priv\u00e9e sans partager vos donn\u00e9es pour usage commercial.</p> <p>LinTO utilise l'IA pour capter votre voix et vous aider tout au long de la journ\u00e9e, m\u00eame en r\u00e9union, \u00e0 r\u00e9duire les t\u00e2ches stressantes ou chronophages : gestion d'agenda, rappels, prise de notes, emails, m\u00e9t\u00e9o, trafic, dictionnaire , actualit\u00e9s, etc.</p> <p>Le projet de recherche est subventionn\u00e9 par le PIA (Programme d'Investissement d'Avenir) de l'\u00e9tat Fran\u00e7ais dans le cadre des Grands D\u00e9fis du num\u00e9rique. Il allie des entreprises technologiques telles que LINAGORA et ZELROS et des laboratoires de recherche comme l'IRIT, le LaaS, le CNRS et le laboratoire de recherche en informatique de l'\u00e9cole polytechnique.</p> <p>Le service LinTO NLU (Natural Language Understanding) est bas\u00e9 sur Tock et permet l\u2019utilisation de plusieurs mod\u00e8les IA d\u00e9di\u00e9s \u00e0 des cas d\u2019utilisation sp\u00e9cifiques. Il apprend automatiquement selon les usages lors de l\u2019ajout ou suppression de comp\u00e9tences (Skills) \u00e0 la plateforme.</p> <p></p> <ul> <li>Nom : LinTO</li> <li>Date de naissance : en production avec Tock depuis 2019</li> <li>Domaine : assistant personnel pour les entreprises (agenda, emails, prise de notes, etc.)</li> <li>Canaux : vocal (portabilit\u00e9 Raspberry Pi, ARM, Android, Web...)</li> </ul>"},{"location":"fr/about/showcase/#bots-internes","title":"Bots internes","text":""},{"location":"fr/about/showcase/#chatbot-interne-enedis","title":"Chatbot interne Enedis","text":"<p>Le Chatbot interne Enedis permet aux 39 000 salari\u00e9s Enedis un acc\u00e8s simplifi\u00e9 aux services logistiques de l\u2019entreprise.</p> <p>Cet agent conversationnel intelligent offre un support de 1<sup>er</sup> niveau en r\u00e9pondant aux questions les plus fr\u00e9quentes des salari\u00e9s et en orientant vers les outils M\u00e9tiers de gestion de demande. Il a \u00e9galement vocation \u00e0 mieux appr\u00e9hender les besoins des salari\u00e9s via l\u2019analyse des questions fr\u00e9quentes.</p> <p>Construit avec Tock, le chatbot est disponible sur un site Web interne \u00e0 l'entreprise.</p> <p></p> <ul> <li>Nom : Chatbot interne Enedis</li> <li>Date de naissance : en production depuis 2020</li> <li>Domaine : services logistiques internes</li> <li>Canaux : texte, sur un site Web interne</li> </ul>"},{"location":"fr/about/showcase/#eve-un-bot-interne-polyvalent-sncf","title":"Eve, un bot interne polyvalent (SNCF)","text":"<p>Eve est l'assistant interne des collaborateurs e.Voyageurs SNCF.</p> <p>Le chatbot r\u00e9pond aux questions courantes, renvoie vers les bons contacts et outils collaboratifs de l'entreprise,  automatise des demandes courantes au Support Informatique, Services G\u00e9n\u00e9raux, Direction Juridique, etc.  Les \u00e9quipes Devops peuvent aussi lui demander l'\u00e9tat de la production, les prochaines interventions, ou d'effectuer  directement certaines op\u00e9rations pour plus de simplicit\u00e9 et de r\u00e9activit\u00e9.</p> <p>Eve est \u00e0 l'\u00e9coute des collaborateurs dans l'entreprise et en mobilit\u00e9 sur Teams avec Tock.</p> <ul> <li>Nom : Eve</li> <li>Date de naissance : en production depuis 2019</li> <li>Domaine : assistance en interne &amp; B2B (FAQ, Support Informatique, RH, Juridique), automatisations DevOps (supervision,  d\u00e9ploiements, gestion de production, etc.)</li> <li>Canaux : texte &amp; voix, en interne dans l'entreprise et en mobilit\u00e9 via Teams</li> </ul>"},{"location":"fr/about/showcase/#rocbot-un-assistant-pour-lexploitation-sncf","title":"RocBOT, un assistant pour l'Exploitation (SNCF)","text":"<p>RocBOT est destin\u00e9 aux Exploitants des \u00e9quipes DEA SNCF. Il est \u00e0 l'\u00e9coute en interne et en mobilit\u00e9 via Teams.</p> <p>Le chabot aide les collaborateurs \u00e0 trouver rapidement les informations utiles sur le parc applicatif.  Il peut aussi v\u00e9rifier si des incidents sont remont\u00e9s par la supervision, donner l'agenda des astreintes,  les bons contacts, etc.</p> <p>RocBOT est en production depuis 2020, disponible sur desktop et en mobilit\u00e9 gr\u00e2ce au  connecteur Teams fourni avec Tock.</p> <p> </p> <ul> <li>Nom : RocBOT</li> <li>Date de naissance : en production depuis 2020</li> <li>Domaine : exploitation et assistance en interne (FAQ, Support exploitabilit\u00e9, relais ITSM, etc.)</li> <li>Canaux : texte &amp; voix, en interne dans l'entreprise et en mobilit\u00e9 via Teams</li> </ul>"},{"location":"fr/about/showcase/#autres","title":"Autres","text":""},{"location":"fr/about/showcase/#toki-le-bot-pour-decouvrir-tock","title":"Toki, le bot pour d\u00e9couvrir Tock","text":"<p>Toki s'adresse \u00e0 tous ceux qui d\u00e9couvrent et utilisent Tock. Il r\u00e9pond \u00e0 des questions courantes et apprend  r\u00e9guli\u00e8rement notamment de la communaut\u00e9 Tock sur Gitter.</p> <p>Comment cr\u00e9er votre premier bot ? Comment installer Tock ? O\u00f9 trouver les sources, la licence ?... N'h\u00e9sitez pas \u00e0 poser la question \u00e0 Toki. S'il ne sait pas (encore) r\u00e9pondre, r\u00e9essayez quelques jours apr\u00e8s ;). Pour les anglophones, Toki arrive bient\u00f4t sur le site EN.</p> <p>Le bot est construit enti\u00e8rement \"0 code\" gr\u00e2ce \u00e0 Tock Studio. Autant une d\u00e9mo qu'un outil pour la  communaut\u00e9, Toki est h\u00e9berg\u00e9 sur la plateforme d\u00e9mo publique,  il utilise le connecteur Web et le  kit React fournis avec Tock pour s'int\u00e9grer en quelques lignes de HTML/JS/CSS  sur le site.</p> <p></p> <ul> <li>Nom : Toki</li> <li>Date de naissance : en production depuis 2021</li> <li>Domaine : assistance \u00e0 la communaut\u00e9 et FAQ</li> <li>Canaux : texte, sur le site Web de la solution</li> </ul>"},{"location":"fr/about/showcase/#et-vous","title":"Et vous ?","text":"<p>D'autres assistants conversationnels d\u00e9velopp\u00e9s avec Tock sont utilis\u00e9s par diff\u00e9rentes organisations (notamment les membres du TOSIT).  Ces bots ne sont pas toujours destin\u00e9s au grand public et leurs organisations ne communiquent pas  n\u00e9cessairement dessus. Nous mentionnons ces projets si l'occasion se pr\u00e9sente ;)</p> <p>N'h\u00e9sitez pas \u00e0 faire un tour sur le tchat Gitter  de la communaut\u00e9, vous pourrez constater que de plus en plus de professionnels et particuliers, \u00e9tudiants, PME et ESN, exp\u00e9rimentent ou utilisent Tock pour leurs projets d'assistants ou d'applications NLP.</p> <p>La plateforme est suffisamment g\u00e9n\u00e9rique pour permettre de nombreux usages et l'int\u00e9gration de canaux  internes ou externes. Si vous avez un doute sur les possibilit\u00e9s de Tock ou la faisabilit\u00e9 d'un nouveau projet, vous pouvez  nous contacter pour en parler.</p> <p>Quant \u00e0 vos propres r\u00e9alisations, n'h\u00e9sitez pas \u00e0 les partager ! \ud83d\ude42</p>"},{"location":"fr/about/why/","title":"Pourquoi Tock ?","text":"<p>Initi\u00e9 en 2016 par l'\u00e9quipe Innovation chez OUI.sncf afin de motoriser l'analyse des  commandes vocales sur ses applications mobiles, le framework fut ensuite utilis\u00e9 pour  cr\u00e9er son bot Messenger, avant d'\u00eatre \u00e9tendu \u00e0 de nombreux canaux et d'accueillir  d'autres bots pour de nouveaux cas d'usage.</p> <p>A ses d\u00e9buts, la plateforme donnait des r\u00e9sultats similaires \u00e0 ceux obtenus avec diff\u00e9rentes solutions du march\u00e9, tout  en restant en ma\u00eetrise du code (embarquant des biblioth\u00e8ques opensource issues du domaine universitaire),  en \u00e9vitant les effets \"bo\u00eete noire\" (notamment pour d\u00e9bugger les mod\u00e8les conversationnels) pour une r\u00e9activit\u00e9 accrue.</p> <p>Depuis, l'\u00e9quipe derri\u00e8re OUIbot ainsi que d'autres \u00e9quipes d\u00e9di\u00e9es \u00e0 diff\u00e9rents  assistants conversationnels SNCF (cf la vitrine) utilisent quotidiennement Tock en  production, tout en enrichissant r\u00e9guli\u00e8rement la plateforme de nouvelles fonctionnalit\u00e9s et connecteurs.</p> <p>Nous pensons qu'il y a un besoin de plateformes conversationnelles et IA ouvertes, permettant des sc\u00e9narios  techniques et m\u00e9tier vari\u00e9s tout en restant en ma\u00eetrise du code, l'utilisateur \u00e9tant propri\u00e9taire de ses  mod\u00e8les et de ses donn\u00e9es.</p> <p>De plus en plus d'acteurs, petites et grandes entreprises en France et \u00e0 l'international, partagent cette vision  et ce besoin pour leurs propres projets.</p> <p>L'ensemble de la solution Tock est partag\u00e9 avec la communaut\u00e9 opensource dans le but de f\u00e9d\u00e9rer et  mutualiser l'effort des cr\u00e9ateurs d'assistants.</p> <p>Depuis 2019, Tock est pr\u00e9conis\u00e9 en interne par le groupe SNCF.  L'outil est \u00e9galement utilis\u00e9 en production par d'autres entreprises  (voir vitrine). </p> <p>A terme, nous pensons que la solution Tock a vocation \u00e0 rejoindre une  association comme le TOSIT (The Open Source I Trust),  une fondation Open Source  ou un consortium.</p>"},{"location":"fr/admin/architecture/","title":"Architecture de Tock","text":"<p>Ce chapitre pr\u00e9sente l'architecture g\u00e9n\u00e9rale d'une plateforme Tock : composants et d\u00e9pendances, flux, configuration de proxies, etc.</p>"},{"location":"fr/admin/architecture/#architecture-fonctionnelle","title":"Architecture fonctionnelle","text":"<p>Deux composants majeurs sont disponibles :</p> <ul> <li>le moteur NLU : Natural Language Understanding (voir Tock Studio)</li> <li>le framework conversationnel int\u00e9gr\u00e9 aux services NLU et \u00e0 diff\u00e9rents connecteurs comme   Messenger, Google Assistant ou Slack (voir manuel d\u00e9veloppeur et connecteurs).</li> </ul> <p></p> <p>La plateforme NLU est ind\u00e9pendante de la partie conversationnelle. Il est possible d'utiliser le NLU sans devoir  ma\u00eetriser la complexit\u00e9 induite par la gestion des conversations. Dans certain cas d'usage importants, comme l'Internet des objets,  l'utilisation d'un mod\u00e8le NLU seule est pertinente.</p>"},{"location":"fr/admin/architecture/#architecture-technique","title":"Architecture technique","text":"<p>Tock est compos\u00e9 de plusieurs composants applicatifs (conteneurs lorsqu'on utilise Docker)  et d'une base de donn\u00e9e MongoDB.</p> <p>Les descripteurs Docker et Docker Compose fournis  (ie. les <code>Dockerfile</code> et <code>docker-compose.yml</code>) d\u00e9crivent l'architecture de Tock.</p> <p>Un exemple complet se trouve dans le fichier <code>docker-compose-bot-open-data.yml</code>  disponible dans le d\u00e9p\u00f4t <code>tock-docker</code>. </p>"},{"location":"fr/admin/architecture/#base-de-donnees-mongodb","title":"Base de donn\u00e9es MongoDB","text":"<p>La base Mongo doit \u00eatre configur\u00e9e en replica set, c'est \u00e0 dire avec au minimum 3 instances d\u00e9ploy\u00e9es. C'est obligatoire car Tock utilise la fonctionnalit\u00e9 des Change Streams qui a comme pr\u00e9-requis l'installation en replica set.</p> <p>Il s'agit \u00e9galement d'une bonne pratique afin d'assurer une haute disponibilit\u00e9 de la base de donn\u00e9es. </p>"},{"location":"fr/admin/architecture/#composants-applicatifs","title":"Composants applicatifs","text":"<p>Voici une description rapide des diff\u00e9rents composants applicatifs (et images Docker fournies  avec Tock) :</p> <ul> <li> <p>Interfaces et outils Tock Studio :</p> <ul> <li><code>tock/bot_admin</code> : Tock Studio</li> </ul> </li> <li> <p>Partie NLU :</p> <ul> <li><code>tock/build_worker</code> : reconstruit les mod\u00e8les automatiquement d\u00e8s que n\u00e9cessaire</li> <li><code>tock/duckling</code> : analyse les dates et types primitifs en utilisant Duckling</li> <li><code>tock/nlp_api</code> : analyse les phrases \u00e0 partir des mod\u00e8les construits dans Tock Studio</li> </ul> </li> <li> <p>Partie conversationnelle :</p> <ul> <li><code>tock/bot_api</code> : API pour d\u00e9velopper des bots (mode Tock Bot API)</li> <li><code>tock/kotlin_compiler</code> (facultatif) : compilateur de scripts  pour les saisir directement dans l'interface Stories and Answers de Tock Studio</li> </ul> </li> </ul> <p>Un dernier composant, le bot lui-m\u00eame, doit \u00eatre ajout\u00e9 et rendu accessible aux partenaires et canaux externes auxquels   on souhaite s'int\u00e9grer.</p> <p>Bien entendu l'impl\u00e9mentation du bot n'est pas fournie avec Tock (chacun impl\u00e9mente ses fonctionnalit\u00e9s propres pour son besoin)  mais un exemple est disponible dans  <code>docker-compose-bot-open-data.yml</code>.</p>"},{"location":"fr/admin/architecture/#modes-de-deploiement","title":"Modes de d\u00e9ploiement","text":"<ul> <li>Le mode plateforme NLU seul (sans partie conversationnelle) :</li> </ul> <ul> <li>Le mode Tock Bot API (recommand\u00e9 pour la plupart des cas), permettant de d\u00e9velopper en Kotlin  ou un autre langage \u00e0 travers l'API conversationnelle de Tock :</li> </ul> <ul> <li>Le mode Tock Bot int\u00e9gr\u00e9 (historique) permettant de d\u00e9velopper en Kotlin uniquement  en utilisant toutes les possibilit\u00e9s de Tock mais en acc\u00e9dant \u00e0 la base MongoDB directement depuis le bot :</li> </ul>"},{"location":"fr/admin/architecture/#voir-aussi","title":"Voir aussi...","text":"<ul> <li>Installation</li> <li>S\u00e9curit\u00e9</li> <li>Supervision</li> <li>Cloud</li> <li>Haute disponibilit\u00e9</li> </ul>"},{"location":"fr/admin/availability/","title":"Haute disponibilit\u00e9","text":"<p>Cette page est destin\u00e9e \u00e0 fournir des conseils et des retours d'ex\u00e9prience sur les configurations  haute disponibilit\u00e9 (ou HA - High Availability) de bots et plateformes Tock.</p> <p>A venir : plus de d\u00e9tails sur les mani\u00e8res d'obtenir une haute disponibilit\u00e9 sur les diff\u00e9rents  composants Tock, et des retours sur notre utilisation en production depuis plusieurs ann\u00e9es  (cf vitrine / utilisateurs). </p>"},{"location":"fr/admin/availability/#redondance-et-resilience","title":"Redondance et r\u00e9silience","text":"<p>Une seule instance de <code>tock/build_worker</code> doit exister.</p> <p>Il est recommand\u00e9 d'utiliser une seule instance de <code>tock/bot_admin</code> et <code>tock/kotlin_compiler</code>.</p> <p>Pour les autres composants, en particulier le composant bot (non fourni) mais \u00e9galement <code>tock/nlp_api</code> et  <code>tock/duckling</code>, il est recommand\u00e9 de d\u00e9ployer plusieurs instances pour assurer une meilleure disponibilit\u00e9  voire de meilleures performances.</p>"},{"location":"fr/admin/availability/#performance","title":"Performance","text":"<p>Comme indiqu\u00e9 dans la section installation, le premier param\u00e8tre \u00e0 surveiller est  la m\u00e9moire disponible.</p> <p>A forte charge - nous avons exp\u00e9riment\u00e9 plus de 80 req/s sur nos propres bots -    le facteur limitant devient la base de donn\u00e9es MongoDB, qu'il faut alors redimensionner en cons\u00e9quence   quand le besoin s'en fait sentir.</p>"},{"location":"fr/admin/cloud/","title":"Cloud","text":"<p>Cette page pr\u00e9sente les aspects li\u00e9s \u00e0 l'utilisation de services Cloud (priv\u00e9s ou publiques) pour d\u00e9ployer  et h\u00e9berger plateformes et bots Tock.</p> <p>En effet, nous avons l'exp\u00e9rience d'utilisations de Tock en production sur des h\u00e9bergements classiques on-premise  et bare metal, mais aussi sur des Clouds priv\u00e9s comme OpenStack ou Clouds publiques  comme AWS.</p> <p>A venir : des d\u00e9tails, exemples et retours d'exp\u00e9rience sur l\"utilisation de Tock sur des h\u00e9bergements  de type Cloud. Nous esp\u00e9rons m\u00eame pouvoir partager avec la communaut\u00e9 du code : infra as code, dashboards, etc.</p>"},{"location":"fr/admin/installation/","title":"Installation Tock","text":"<p>La page architecture pr\u00e9sente l'architecture fonctionnelle et technique Tock, le r\u00f4le des diff\u00e9rents composants ainsi que les diff\u00e9rents modes de d\u00e9ploiement.</p> <p>Ce chapitre pr\u00e9sente les diff\u00e9rentes options d'installation de Tock. En particulier, il s'agit d'\u00e9voquer le cas d'une installation en production ainsi que partager quelques retours d'exp\u00e9rience sur les performances, la r\u00e9silience, la capacit\u00e9 de Tock \u00e0 monter en charge, les d\u00e9ploiementsde type Cloud, la supervision, etc.</p> <p>Si vous cherchez seulement \u00e0 tester Tock avec des donn\u00e9es non sensibles, vous pouvez pr\u00e9f\u00e9rer utiliser la plateforme de d\u00e9monstration Tock.</p>"},{"location":"fr/admin/installation/#installation-avec-docker","title":"Installation avec Docker","text":"<p>Le d\u00e9p\u00f4t <code>tock-docker</code> fournit une impl\u00e9mentation compl\u00e8te de Tock pour les technologies Docker et Docker Compose. Tock est compos\u00e9 par d\u00e9faut de plusieurs conteneurs/images Docker et d'une base de donn\u00e9e MongoDB.</p> <p>Pour en savoir plus sur l'installation de Tock avec Docker, voir les instructions du d\u00e9p\u00f4t <code>tock-docker</code>.</p> <p>Le guide d\u00e9ployer Tock avec Docker dans la section D\u00e9couvrir Tock donne un exemple de d\u00e9ploiement d'une plateforme compl\u00e8te en quelques minutes avec une empreinte minimale en utilisant Docker et Docker Compose. Cependant, cette m\u00e9thode n'est pas envisageable pour un d\u00e9ploiement p\u00e9renne comme une plateforme de production.</p> <p>Si vous souhaitez utiliser Docker Compose en production, merci de lire cet article et de revoir la configuration, qui est uniquement donn\u00e9e dans le projet <code>tock-docker</code> \u00e0 titre d'exemple. En particulier, la configuration des instances MongoDB doit \u00eatre revue attentivement.</p>"},{"location":"fr/admin/installation/#installation-sans-docker","title":"Installation sans Docker","text":"<p>Il est tout \u00e0 fait possible d'installer Tock sans utiliser Docker. En analysant les descripteurs fournis dans <code>tock-docker</code> (ie. les fichiers <code>pom.xml</code>, les <code>Dockerfile</code> et <code>docker-compose.yml</code>) on peut facilement concevoir une installation sans Docker.</p> <p>Hormis la base de donn\u00e9es MongoDB, tous les autres composants peuvent d\u00e9marrer comme des applications Java/JVM classiques, par exemple :</p> <ul> <li>directement en ligne de commande</li> <li>au sein d'un serveur d'applications Java</li> <li>depuis un outil de d\u00e9veloppement int\u00e9gr\u00e9 (IDE)</li> <li>etc.</li> </ul> <p>Pour en savoir plus sur les param\u00e8tres de lancement des diff\u00e9rents composants Tock, vous pouvez vous inspirer des commandes pr\u00e9sentes dans les descripteurs de <code>tock-docker</code> ou encore des configurations fournies pour IntelliJ (voir ci-dessous).</p>"},{"location":"fr/admin/installation/#ligne-de-commande","title":"Ligne de commande","text":"<p>Une technique consiste \u00e0 rassembler les diff\u00e9rentes d\u00e9pendances et archives JAR dans un dossier puis d\u00e9marrer le composant ou l'application avec une commande Java classique.</p> <p>Pour exemple, le descripteur du composant <code>tock-docker-nlp-api</code> (voir <code>pom.xml</code>) avec la commande suivante :</p> <pre><code>java $JAVA_ARGS -Dfile.encoding=UTF-8 -cp '/maven/*' ai.tock.nlp.api.StartNlpServiceKt\n</code></pre>"},{"location":"fr/admin/installation/#jar-executable","title":"JAR ex\u00e9cutable","text":"<p>Ce n'est pas la technique que nous recommandons, mais il est possible d'ex\u00e9cuter un JAR unique contenant toutes les d\u00e9pendances (parfois appel\u00e9 \"fat JAR\"). Voici comment proc\u00e9der pour cr\u00e9er un tel JAR, en reprenant l'exemple du composant Tock NLP-API.</p> <p>Dans le POM du composant (<code>nlp/api/service/pom.xml</code>), ajoutez la d\u00e9claration suivante :</p> <pre><code>    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;phase&gt;package&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;single&lt;/goal&gt;\n                        &lt;/goals&gt;\n                        &lt;configuration&gt;\n                            &lt;archive&gt;\n                                &lt;manifest&gt;\n                                    &lt;mainClass&gt;ai.tock.nlp.api.StartNlpServiceKt&lt;/mainClass&gt;\n                                &lt;/manifest&gt;\n                            &lt;/archive&gt;\n                            &lt;descriptors&gt;\n                                &lt;descriptor&gt;src/main/assembly/jar-with-dependencies.xml&lt;/descriptor&gt;\n                            &lt;/descriptors&gt;\n                        &lt;/configuration&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n</code></pre> <p>Cr\u00e9ez \u00e9galement un descripteur d'archive <code>nlp/api/service/src/main/assembly/jar-with-dependencies.xml</code> avec le contenu suivant :</p> <pre><code>&lt;assembly xmlns=\"http://maven.apache.org/ASSEMBLY/2.0.0\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd\"&gt;\n    &lt;id&gt;jar-with-dependencies&lt;/id&gt;\n    &lt;formats&gt;\n        &lt;format&gt;jar&lt;/format&gt;\n    &lt;/formats&gt;\n    &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;\n    &lt;dependencySets&gt;\n        &lt;dependencySet&gt;\n            &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;\n            &lt;useProjectArtifact&gt;true&lt;/useProjectArtifact&gt;\n            &lt;unpack&gt;true&lt;/unpack&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;/dependencySet&gt;\n    &lt;/dependencySets&gt;\n    &lt;containerDescriptorHandlers&gt;\n        &lt;containerDescriptorHandler&gt;\n            &lt;!-- Merge service implementations from dependencies --&gt;\n            &lt;handlerName&gt;metaInf-services&lt;/handlerName&gt;\n        &lt;/containerDescriptorHandler&gt;\n    &lt;/containerDescriptorHandlers&gt;\n&lt;/assembly&gt;\n</code></pre> <p>Pour finir, construisez l'archive \"jar-with-dependencies\" avec <code>mvn package</code>.</p>"},{"location":"fr/admin/installation/#dans-un-ide","title":"Dans un IDE","text":"<p>Pour le d\u00e9veloppement, il est possible d'ex\u00e9cuter les diff\u00e9rents composants Tock (NLU, Studio, bot...) depuis un IDE comme IntelliJ, Eclipse ou Visual Studio Code par exemple.</p> <p>Outre les images Docker, des configurations pour IntelliJ sont fournies avec les sources de Tock :</p> <ul> <li>Configuration Services Tock Studio complets (Bot + NLP) / <code>BotAdmin</code></li> <li>Configuration Services Tock Studio (NLP uniquement) / <code>Admin</code></li> <li>Configuration Service NLP / <code>NlpService</code></li> <li>Configuration Service d'entit\u00e9s / <code>Duckling</code></li> <li>Configuration Service construction des mod\u00e8les NLP / <code>BuildWorker</code></li> <li>Configuration Service de compilation des scripts / <code>KotlinCompilerServer</code></li> </ul> <p>Enfin pour lancer les interfaces utilisateur (Tock Studio), les commandes sont d\u00e9crites dans le lien suivant :</p> <ul> <li>Instructions Interface Tock Studio compl\u00e8te (Bot + NLP)</li> </ul>"},{"location":"fr/admin/installation/#base-de-donnees-mongodb","title":"Base de donn\u00e9es MongoDB","text":""},{"location":"fr/admin/installation/#architecture-replica-set","title":"Architecture replica set","text":"<p>La base MongoDB doit \u00eatre configur\u00e9e en replica set, car Tock tire parti des change streams.</p> <p>Cela implique qu'au minimum 3 noeuds doivent \u00eatre d\u00e9ploy\u00e9s, ce qui am\u00e9liore la r\u00e9silience.</p> <p>Diff\u00e9rents sc\u00e9narios sont possibles pour la base de donn\u00e9es :</p> <ul> <li>Installer les noeuds MongoDB sur un ou plusieurs serveurs (m\u00e9thode classique)</li> <li>Instancier les noeuds MongoDB avec Docker (pour des tests ou le d\u00e9veloppement en local)</li> <li>Utiliser un service cloud MongoDB en SaaS (Software-as-a-Service), par exemple   MongoDB Atlas disponible sur AWS, Azure et GCP</li> </ul> <p>Un tutoriel d'installation en replica set est disponible sur le site de MongoDB.</p>"},{"location":"fr/admin/installation/#conservation-des-donnees","title":"Conservation des donn\u00e9es","text":"<p>Tock conserve en base diff\u00e9rents types de donn\u00e9es et applique des TTL (Time To Live), afin que certaines expirent et soient purg\u00e9es automatiquement apr\u00e8s un certain temps.</p> <p>En pratique, les variables d'environnement et l'application des TTL ont lieu \u00e0 l'initialisation des composant DAO (Data Access Object), au d\u00e9marrage de Tock.</p> <p>Les TTL de Tock poss\u00e8dent une valeur par d\u00e9faut et sont configurables au moyen de variables d'environnement. Certaines concernent un composant Tock en particulier, d'autres doivent \u00eatre d\u00e9finies sur plusieurs composants.</p> <p>Tock pouvant \u00eatre utilis\u00e9 comme plateforme conversationnelle compl\u00e8te ou uniquement la partie NLU/NLP, on indique les variables sp\u00e9cifiques au conversationnel (not\u00e9es Bot) ou utilisables sur tous les types de plateformes (not\u00e9es *).</p> Plateforme(s) Variable d'environnement Valeur par d\u00e9faut Description Composant(s) concern\u00e9(s) * <code>tock_nlp_classified_sentences_index_ttl_days</code> <code>-1</code> (pas d'expiration) Phrases non valid\u00e9es (Inbox). <code>nlp_api</code>, <code>nlp_admin</code>/<code>bot_admin</code>, <code>worker</code> * <code>tock_nlp_classified_sentences_index_ttl_intent_names</code> Vide (toutes intentions) Phrases non valid\u00e9es (Inbox) &gt;&gt; restriction \u00e0 certaines intentions, s\u00e9par\u00e9es par des virgules.(Exemple ci-dessous). <code>nlp_api</code> * <code>tock_nlp_log_index_ttl_days</code> <code>7</code> Logs NLP : phrase, intentions, scores, d\u00e9tail des entit\u00e9s, etc. <code>nlp_api</code> * <code>tock_nlp_log_stats_index_ttl_days</code> <code>365</code> Statistiques NLP : nombre d'occurrences d'une phrase, scores, etc. <code>nlp_api</code> * <code>tock_user_log_index_ttl_days</code> <code>365</code> Log des actions dans Tock Studio : modifications de Stories, etc. <code>nlp_admin</code>/<code>bot_admin</code> Bot <code>tock_bot_alternative_index_ttl_hours</code> <code>1</code> Index sur les alternatives d'un label (Answers). <code>bot</code>/<code>bot_api</code> Bot <code>tock_bot_dialog_index_ttl_days</code> <code>7</code> Conversations (Analytics &gt; Users/Search). <code>bot</code>/<code>bot_api</code>, <code>nlp_admin</code>/<code>bot_admin</code> Bot <code>tock_bot_dialog_max_validity_in_seconds</code> <code>60 * 60 * 24</code> (24h) Contextes des conversations (intention courante, entit\u00e9s dans le bus, etc.). <code>bot</code>/<code>bot_api</code>, <code>nlp_admin</code>/<code>bot_admin</code> Bot <code>tock_bot_flow_stats_index_ttl_days</code> <code>365</code> Statistiques de navigation (Analytics &gt; Activity/Behavior). <code>bot</code>/<code>bot_api</code>, <code>nlp_admin</code>/<code>bot_admin</code> Bot <code>tock_bot_timeline_index_ttl_days</code> <code>365</code> Profils/historique utilisateurs : pr\u00e9f\u00e9rences, locale, derni\u00e8re connexion, etc. (hors d\u00e9tail des conversations) <code>bot</code>/<code>bot_api</code>, <code>nlp_admin</code>/<code>bot_admin</code> <p>Selon le mode de d\u00e9ploiement utilis\u00e9, ces variables d'environnement peuvent \u00eatre ajout\u00e9es soit directement en ligne de commande, soit dans un descripteur type <code>docker-compose.yml</code>, <code>dockerrun.aws.json</code> ou autre (exemple ci-dessous).</p> <p>Il est possible de supprimer automatiquement les phrases non valid\u00e9es (Inbox) pour certaines intentions uniquement, gr\u00e2ce \u00e0 <code>tock_nlp_classified_sentences_index_ttl_intent_names</code> :</p> <ul> <li>{: data-hl-lines=\"6 7\"} docker-compose.yml</li> </ul> <pre><code>version: \"3\"\nservices:\n  admin_web:\n    image: tock/bot_admin:$TAG\n    environment:\n      - tock_nlp_classified_sentences_index_ttl_days=10\n      - tock_nlp_classified_sentences_index_ttl_intent_names=greetings,unknown\n</code></pre> <ul> <li>{: data-hl-lines=\"8 9\"} dockerrun.aws.json</li> </ul> <pre><code>{\n  \"AWSEBDockerrunVersion\": 2,\n  \"containerDefinitions\": [\n    {\n      \"name\": \"admin_web\",\n      \"image\": \"tock/bot_admin:${TAG}\",\n      \"environment\": [\n        {\n          \"name\": \"tock_nlp_classified_sentences_index_ttl_days\",\n          \"value\": \"10\"\n        },\n        {\n          \"name\": \"tock_nlp_classified_sentences_index_ttl_intent_names\",\n          \"value\": \"greetings,unknown\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <p>{: .tabbed-code}</p> <p>Dans cet exemple, seules les phrases d\u00e9tect\u00e9es comme intentions <code>greetings</code> ou <code>unknown</code> (mais non valid\u00e9es) seront supprim\u00e9es au bout de <code>10</code> jours ; les autres phrases ne seront pas supprim\u00e9es.</p> <p>Seules les phrases valid\u00e9es par un utilisateur dans Tock Studio, int\u00e9grant le mod\u00e8le NLP du bot, n'expirent jamais par d\u00e9faut (m\u00eame s'il reste possible de les supprimer du mod\u00e8le via la vue Search &gt; Status: Included in model) : il est donc important de ne pas valider des phrases comportant des donn\u00e9es personnelles par exemple.</p> <p>La conservation des donn\u00e9es, le chiffrement et l'anonymisation sont essentiels \u00e0 la protection des donn\u00e9es, en particulier si elles sont personnelles. Pour en savoir plus, voir la section S\u00e9curit\u00e9 &gt; Donn\u00e9es.</p>"},{"location":"fr/admin/installation/#composants-applicatifs","title":"Composants applicatifs","text":"<p>Selon les composants applicatifs de Tock, obligatoires ou facultatifs, certains doivent \u00eatre mono-instance et d'autres peuvent \u00eatre d\u00e9ploy\u00e9s en plusieurs instances (voir la section haute disponibilit\u00e9 pour en savoir plus).</p> <p>Pour plus de commodit\u00e9, les composants ci-dessous sont nomm\u00e9 comme les images Docker fournies avec Tock, bien que l'utilisation de Docker ne soit pas obligatoire pour installer Tock.</p>"},{"location":"fr/admin/installation/#exposition-reseau","title":"Exposition r\u00e9seau","text":"<p>Par d\u00e9faut, les composants ou conteneurs de la plateforme Tock ne doivent pas \u00eatre expos\u00e9s \u00e0 l'ext\u00e9rieur du VPN ou VPC. Seul le bot lui-m\u00eame doit \u00eatre accessible des partenaires et canaux externes auxquels on veut s'int\u00e9grer, pour le fonctionnement des WebHooks.</p> Composant / Image Exposition r\u00e9seau Description <code>tock/bot_admin</code> VPN / VPC uniquement Interfaces et outils Tock Studio <code>tock/build_worker</code> VPN / VPC uniquement Reconstruit les mod\u00e8les automatiquement d\u00e8s que n\u00e9cessaire <code>tock/duckling</code> VPN / VPC uniquement Analyse les dates et types primitifs en utilisant Duckling <code>tock/nlp_api</code> VPN / VPC uniquement Analyse les phrases \u00e0 partir des mod\u00e8les construits dans Tock Studio <code>tock/bot_api</code> VPN / VPC uniquement API pour d\u00e9velopper des bots (mode Tock Bot API) <code>tock/kotlin_compiler</code> VPN / VPC uniquement (Facultatif) Compilateur de scripts pour les saisir directement dans l'interface Build de Tock Studio bot (non fourni) Internet / partenaires Le bot lui-m\u00eame, impl\u00e9mentant les parcours programmatiques, accessible des partenaires/canaux externes via des WebHooks <p>Bien s\u00fbr, l'impl\u00e9mentation du bot lui-m\u00eame n'est pas fournie avec Tock (chacun impl\u00e9mente ses fonctionnalit\u00e9s propres pour son besoin).</p>"},{"location":"fr/admin/installation/#proxies-http","title":"Proxies HTTP","text":"<p>Les propri\u00e9t\u00e9s syst\u00e8me Java <code>https.proxyHost</code>, <code>http.proxyHost</code> et <code>http.nonProxyHosts</code> sont la m\u00e9thode recommand\u00e9e pour configurer un proxy.</p>"},{"location":"fr/admin/installation/#packaging-du-bot","title":"Packaging du bot","text":"<p>Un exemple de bot en mode Tock Bot int\u00e9gr\u00e9 est disponible dans <code>docker-compose-bot-open-data.yml</code>.</p> <p>Des exemples et indications pour packager des bots en mode Tock Bot API (WebHooks, WebSockets) seront bient\u00f4t disponibles.</p>"},{"location":"fr/admin/installation/#configurations-minimales","title":"Configurations minimales","text":"<p>L'architecture Tock est compos\u00e9e de plusieurs composants qui peuvent \u00eatre d\u00e9ploy\u00e9s ensemble sur un m\u00eame serveur, ou r\u00e9partis sur plusieurs machines/instances.</p> <p>Le param\u00e8tre principal \u00e0 surveiller est la m\u00e9moire vive disponible.</p>"},{"location":"fr/admin/installation/#construction-des-modeles","title":"Construction des mod\u00e8les","text":"<p>Plus vos mod\u00e8les sont importants, plus il est n\u00e9cessaire d'augmenter la m\u00e9moire pour reconstruire les mod\u00e8les (composant <code>tock/build_worker</code>).</p> <p>Pour donner un ordre de grandeur, un mod\u00e8le de 50000 phrases avec plusieurs intentions, comportant une vingtaine d'entit\u00e9s, n\u00e9cessitera de provisionner environ 8 Go de RAM pour le composant <code>tock/build_worker</code>.</p> <p>Cependant, des mod\u00e8les importants mais contenant peu d'entit\u00e9s fonctionnent facilement avec seulement 1 Go de RAM.</p>"},{"location":"fr/admin/installation/#memoire-jvm-docker","title":"M\u00e9moire JVM &amp; Docker","text":"<p>Pour garantir que les conteneurs/instances Docker ne d\u00e9passent pas la m\u00e9moire disponible, il est recommand\u00e9 de limiter la m\u00e9moire des JVMs en suivant l'exemple suivant :</p> <pre><code>JAVA_ARGS=-Xmx1g -XX:MaxMetaspaceSize=256m\n</code></pre>"},{"location":"fr/admin/installation/#optimisation-machines","title":"Optimisation machines","text":"<p>Il est possible d'optimiser d\u00e9ploiements et infrastructures en prenant en compte diff\u00e9rents \u00e9l\u00e9ments comme :</p> <ul> <li>les besoins des composants respectifs en ressources machines : CPU, m\u00e9moire, disque</li> <li>l'int\u00e9r\u00eat d'avoir une ou plusieurs instances de chaque composant suivant son r\u00f4le</li> <li>les contraintes/objectifs de r\u00e9silience et haute disponibilit\u00e9</li> <li>les mod\u00e8les de co\u00fbts, notamment chez les fournisseurs de clouds publics</li> </ul>"},{"location":"fr/admin/installation/#exemples","title":"Exemples","text":"<p>A titre indicatif, voici quelques exemples de configurations actuellement en production. Il s'agit des composants \"applicatifs\" de l'architecture Tock sans la base de donn\u00e9e MongoDB.</p> <p>Les types d'instances EC2 sont donn\u00e9s \u00e0 titre indicatif. Tock n'a pas de d\u00e9pendance \u00e0 AWS. Pour en savoir plus voir la documentation AWS.</p>"},{"location":"fr/admin/installation/#modeles-de-taille-limitee","title":"Mod\u00e8les de taille limit\u00e9e","text":"Composants Tock Nombre d'instances Nombre de CPU ou vCPU M\u00e9moire RAM Exemple type d'instance EC2 <code>admin-web</code> + <code>build-worker</code> + <code>kotlin-compiler</code> + <code>duckling</code> 1 2 4 Go <code>t3a.medium</code> (usage g\u00e9n\u00e9ral) <code>bot</code> + <code>nlp-api</code> + <code>duckling</code> 3 2 4 Go <code>t3a.medium</code> (usage g\u00e9n\u00e9ral)"},{"location":"fr/admin/installation/#modeles-de-taille-importante","title":"Mod\u00e8les de taille importante","text":"Composants Tock Nombre d'instances Nombre de CPU ou vCPU M\u00e9moire RAM Exemple type d'instance EC2 <code>admin-web</code> + <code>build-worker</code> + <code>kotlin-compiler</code> + <code>duckling</code> 1 2 16 Go <code>r5a.large</code> (m\u00e9moire optimis\u00e9e) <code>bot</code> + <code>nlp-api</code> + <code>duckling</code> 3 2 4 Go <code>t3a.medium</code> (usage g\u00e9n\u00e9ral)"},{"location":"fr/admin/installation/#questions-frequentes","title":"Questions fr\u00e9quentes","text":""},{"location":"fr/admin/installation/#mettre-a-disposition-linterface-dadministration-dans-un-sous-repertoire","title":"Mettre \u00e0 disposition l'interface d'administration dans un sous-repertoire","text":"<p>Par d\u00e9faut l'interface d'administration est servie \u00e0 la racine (Exemple : <code>https://[domain host]</code>) Si vous souhaitez la rendre disponible sur un chemin relatif (<code>https://[domain host]/tock</code>), utilisez dans la configuration de l'image docker <code>tock/bot_admin</code> la variable d'environnement <code>botadminverticle_base_href</code>.</p> <p>Par exemple : <code>botadminverticle_base_href=tock</code></p> <p>Pour <code>tock/nlp_admin</code>, il faut utiliser la propri\u00e9t\u00e9 <code>adminverticle_base_href</code>.</p>"},{"location":"fr/admin/installation/#voir-aussi","title":"Voir aussi...","text":"<p>Pour une utilisation de Tock en production, nous vous recommandons de parcourir \u00e9galement les pages suivantes :</p> <ul> <li>S\u00e9curit\u00e9</li> <li>Supervision</li> <li>Cloud</li> <li>Haute disponibilit\u00e9</li> </ul>"},{"location":"fr/admin/security/","title":"S\u00e9curit\u00e9","text":""},{"location":"fr/admin/security/#utilisateurs-tock-studio","title":"Utilisateurs Tock Studio","text":""},{"location":"fr/admin/security/#authentification","title":"Authentification","text":"<p>Tock supporte plusieurs syst\u00e8mes d'authentification pour l'interface d'administration. Il utilise les librairies vert.x correspondantes.</p> <p>Voici les syst\u00e8mes disponibles par d\u00e9faut (tous impl\u00e9mentations de <code>TockAuthProvider</code>) :</p> <ul> <li> <p>Un mod\u00e8le par \"propri\u00e9t\u00e9s\", utilis\u00e9 par d\u00e9faut.   Le code est disponible dans la classe <code>PropertyBasedAuthProvider</code></p> </li> <li> <p>Un mod\u00e8le OAuth2 g\u00e9n\u00e9rique.</p> </li> <li> <p>Un mod\u00e8le OAuth2 adapt\u00e9 \u00e0 <code>Keycloak</code>.</p> </li> <li> <p>Un mod\u00e8le OAuth2 sp\u00e9cifique pour Github dont un exemple est donn\u00e9 par <code>GithubOAuthProvider</code></p> </li> </ul> <p>Il est \u00e9galement possible d'int\u00e9grer une authentification CAS (SSO), dans le cas d'une installation de type entreprise. Ce mod\u00e8le n\u00e9cessite d'h\u00e9riter d'un mod\u00e8le de base, mais permet de faire correspondre un profil utilisateur selon vos propres contraintes et sp\u00e9cificit\u00e9s.</p> <p>Des d\u00e9tails et exemples de configuration sont donn\u00e9s plus bas dans cette page.</p> <p>Si ces mod\u00e8les ne correspondent pas \u00e0 votre besoin, il est relativement simple d'en d\u00e9velopper d'autres en se basant sur les exemples ci-dessus. N'h\u00e9sitez pas \u00e0 contribuer au projet et \u00e0 nous contacter pour toute question!</p>"},{"location":"fr/admin/security/#roles","title":"R\u00f4les","text":"<p>Tock permet d'affecter plusieurs r\u00f4les ou niveaux d'habilitations aux utilisateurs dans les interfaces Tock Studio. En fonction du syst\u00e8me d'authentification utilis\u00e9 (par propri\u00e9t\u00e9s, 0Auth, etc.) chaque utilisateur se voit assign\u00e9 un ou plusieurs de ces r\u00f4les, lui donnant diff\u00e9rents acc\u00e8s dans l'application.</p> <p>Les r\u00f4les disponibles sont d\u00e9finis dans l'enum <code>TockUserRole</code>:</p> R\u00f4le Description <code>nlpUser</code> NLP platform user, allowed to qualify and search sentences. ~~<code>faqNlpUser</code>~~ ~~FAQ NLP platform user, allowed to qualify and search sentences.~~ (Deprecated: Use the 'nlpUser' role instead) ~~<code>faqBotUser</code>~~ ~~A faq bot user is allowed to manage the FAQ content, and train the FAQ~~ (Deprecated: Use the 'botUser' role instead) <code>botUser</code> Bot platform user, allowed to create and modify stories, rules and answers. <code>admin</code> Allowed to update applications and configurations/connectors, import/export intents, sentences, stories, etc.. <code>technicalAdmin</code> Allowed to access encrypted data, import/export application dumps, etc. <p>La mani\u00e8re de configurer quel utilisateur Tock Studio a quel r\u00f4le d\u00e9pend du mode d'authentification, autrement dit l'impl\u00e9mentation de <code>TockAuthProvider</code> utilis\u00e9e.</p>"},{"location":"fr/admin/security/#implementation-par-proprietes","title":"Impl\u00e9mentation par propri\u00e9t\u00e9s","text":"<p>La configuration par \"propri\u00e9t\u00e9s\" est utilis\u00e9e par d\u00e9faut. Elle ne d\u00e9pend d'aucun syst\u00e8me tiers pour fonctionner.</p> <p>Ce mode consiste a configurer utilisateurs et r\u00f4les par des propri\u00e9t\u00e9s ou variables d'environnement. Selon le mode de d\u00e9ploiement utilis\u00e9, ces variables peuvent \u00eatre d\u00e9finies soit directement en ligne de commande, soit dans un descripteur type <code>docker-compose.yml</code>, <code>dockerrun.aws.json</code> ou autre.</p> <p>Si aucune variable n'est d\u00e9finie (par exemple dans les descripteurs fournis dans le d\u00e9p\u00f4t <code>tock-docker</code>), des valeurs par d\u00e9faut sont utilis\u00e9es.</p> <p>Voici les propri\u00e9t\u00e9s et leurs valeurs par d\u00e9faut :</p> Variable d'environnement Valeur par d\u00e9faut Description <code>tock_users</code> <code>admin@app.com</code> Identifiants (s\u00e9par\u00e9s par des virgules). <code>tock_passwords</code> <code>password</code> Mots de passe (s\u00e9par\u00e9s par des virgules). <code>tock_organizations</code> <code>app</code> Organisations (s\u00e9par\u00e9es par des virgules). <code>tock_roles</code> Vide (i.e., tous les r\u00f4les) R\u00f4les s\u00e9par\u00e9s par des <code>|</code> (puis par des virgules). <p>Pour d\u00e9finir l'identit\u00e9 et les r\u00f4les de plusieurs utilisateurs, on s\u00e9pare les valeurs par des virgules.</p> <p>Attention : chacune de ces propri\u00e9t\u00e9s doit poss\u00e9der le m\u00eame nombre de valeurs (et dans le m\u00eame ordre) pour permettre de corr\u00e9ler ces valeurs (index par index, pour chaque utilisateur).</p> <p>Ci-dessous un exemple au format Docker-Compose :</p> <pre><code>{ \"name\" : \"tock_users\", \"value\" : \"alice@tock.ai,bob@tock.ai\" },\n{ \"name\" : \"tock_passwords\", \"value\" : \"secret1,secret2\" },\n{ \"name\" : \"tock_organizations\", \"value\" : \"tock,tock\" },\n{ \"name\" : \"tock_roles\", \"value\" : \"botUser,nlpUser|botUser|admin|technicalAdmin\" },\n</code></pre> <p>Dans cet exemple, Alice a le r\u00f4le <code>botUser</code>, alors que Bob a tous les r\u00f4les.</p> <p>Pour en savoir plus sur le fonctionnement pr\u00e9cis de cette impl\u00e9mentation, voir la classe <code>PropertyBasedAuthProvider</code>.</p>"},{"location":"fr/admin/security/#implementation-0auth2-generique","title":"Impl\u00e9mentation 0Auth2 g\u00e9n\u00e9rique","text":"<p>Cette impl\u00e9mentation g\u00e9n\u00e9rique est \u00e0 utiliser d\u00e8s que vous souhaitez param\u00e9trer une configuration OAuth2.</p> <p>Voici les propri\u00e9t\u00e9s et leurs valeurs par d\u00e9faut :</p> Variable d'environnement Exemple de valeur Description Exemple <code>tock_oauth2_enabled</code> <code>true</code> Activation de l'authentification OAuth2 <code>tock_oauth2_client_id</code> <code>CLIENT_ID</code> Identifiant pour interroger l'API GitHub <code>tock_oauth2_secret_key</code> <code>SECRET_KEY</code> Mot de passe pour interroger l'API GitHub <code>tock_oauth2_site_url</code> <code>https://provider</code> URL du provider OAuth2 <code>tock_oauth2_access_token_path</code> <code>/oauth2/token</code> Chemin relatif pour r\u00e9cup\u00e9rer l'access token <code>tock_oauth2_authorize_path</code> <code>/oauth2/authorize</code> Chemin relatif pour r\u00e9cup\u00e9rer l'authorize <code>tock_oauth2_userinfo_path</code> <code>/oauth2/userInfo</code> Chemin relatif pour r\u00e9cup\u00e9rer les userinfo <code>tock_oauth2_proxy_host</code> H\u00f4te du proxy (ne pas indiquer si pas de proxy) <code>tock_oauth2_proxy_port</code> Port optionnel du proxy <code>tock_oauth2_user_role_attribute</code> <code>custom:roles</code> Attribut lu dans le token pour le mapping du r\u00f4le <code>tock_custom_roles_mapping</code> Lien entre les profils OAuth et les r\u00f4les Tock <code>tock_custom_namespace_mapping</code> Lien entre les profils OAuth et les namespaces Tock <code>id1=sncf|id2=sncf</code> <code>tock_bot_admin_rest_default_base_url</code> <code>http://localhost:8080</code> Redirection vers l'URL de Tock Studio si besoin <p>Il est n\u00e9cessaire d'indiquer en callback url <code>https://[host admin]/rest/callback</code>.</p>"},{"location":"fr/admin/security/#implementation-0auth2-pour-keycloak","title":"Impl\u00e9mentation 0Auth2 pour Keycloak","text":"<p>Cette impl\u00e9mentation OAuth2 Keycloak est \u00e0 utiliser d\u00e8s que vous souhaitez param\u00e9trer une configuration OAuth2 avec Keycloak.</p> <p>Voici les propri\u00e9t\u00e9s et leurs valeurs propos\u00e9es :</p> <p>Attention, par d\u00e9faut, aucun adapteur n'\u00e9tant activ\u00e9, il faut imp\u00e9rativement mettre la cl\u00e9 tock_keycloak_enabled correspondant \u00e0 notre adaptateur \u00e0 true.</p> Variable d'environnement Exemple de valeur Description <code>tock_keycloak_enabled</code> <code>true</code> Activation de l'authentification 0Auth2 <code>tock_keycloak_client_id</code> <code>CLIENT_ID</code> Client id cr\u00e9e sur Keycloak <code>tock_keycloak_secret_key</code> <code>SECRET_KEY</code> Secret key g\u00e9n\u00e9r\u00e9e par Keycloak <code>tock_keycloak_site_url</code> <code>https://keycloak/realms/myrealm</code> Url du Realm Keycloak <code>tock_keycloak_access_token_path</code> <code>/protocol/openid-connect/token</code> Chemin relatif pour r\u00e9cup\u00e9rer l'access token <code>tock_keycloak_authorize_path</code> <code>/protocol/openid-connect/auth</code> Chemin relatif pour l'authorize <code>tock_keycloak_userinfo_path</code> <code>/protocol/openid-connect/userinfo</code> Chemin relatif pour les userinfo <code>tock_keycloak_proxy_host</code> host du proxy (ne pas indiquer si pas de proxy) <code>tock_keycloak_proxy_port</code> port optionnel du proxy <code>tock_custom_namespace_mapping</code> <code>tock_namespace</code> Attribut lu dans le token pour le namespace <code>tock_keycloak_user_role_attribute</code> <code>tock_roles</code> Attribut lu dans le token pour les roles <p>Il est n\u00e9cessaire d'indiquer en callback url <code>https://[host admin]/rest/callback</code>.</p> <p>Une configuration basique n\u00e9cessite de d\u00e9finir tock_keycloak_client_id et tock_keycloak_secret_key avec les valeurs correspondantes sur Keycloak.</p> <p>Il est \u00e9galement n\u00e9cessaire de passer l'adresse du Realm keycloak via tock_keycloak_site_url.</p> <p>Il n'est en revanche alors pas n\u00e9cessaire de d\u00e9finir tock_keycloak_access_token_path, tock_keycloak_authorize_path et tock_keycloak_userinfo_path puisque les valeurs par d\u00e9faut conviennent pour Keycloak si l'on sp\u00e9cifie bien l'adresse du realm.</p> <p>Si tock_custom_namespace_mapping n'est pas d\u00e9fini ou si l'attribut n'est pas trouv\u00e9, le namespace \"app\" par d\u00e9faut est utilis\u00e9.</p>"},{"location":"fr/admin/security/#implementation-0authgithub","title":"Impl\u00e9mentation 0Auth/GitHub","text":"<p>Cette impl\u00e9mentation assez simpliste est utilis\u00e9e \u00e0 titre d'exemple, ainsi que pour la plateforme publique de d\u00e9mo https://demo.tock.ai.</p> <p>Elle consiste \u00e0 interroger l'API GitHub pour v\u00e9rifier l'identit\u00e9 d'un utilisateur \u00e0 partir de son jeton (<code>access_token</code>).</p> <p>Remarque : aucune autre donn\u00e9e du profil GitHub n'est acc\u00e9d\u00e9e par Tock, \u00e0 part l'identifiant.</p> <p>Dans ce mode, activ\u00e9 par la propri\u00e9t\u00e9 <code>tock_github_oauth_enabled</code>, chaque utilisateur re\u00e7oit automatiquement tous les r\u00f4les Tock Studio et une organisation (ie. namespace) du m\u00eame nom que son identifiant.</p> <p>Voici les propri\u00e9t\u00e9s et leurs valeurs par d\u00e9faut :</p> Variable d'environnement Valeur par d\u00e9faut Description <code>tock_github_oauth_enabled</code> <code>false</code> Activation de l'authentification 0Auth/GitHub. <code>tock_github_oauth_client_id</code> <code>CLIENT_ID</code> Identifiant pour interroger l'API GitHub. <code>tock_github_oauth_secret_key</code> <code>SECRET_KEY</code> Mot de passe pour interroger l'API GitHub. <code>tock_github_api_request_timeout_ms</code> <code>5000</code> Timeout v\u00e9rification de l'identit\u00e9 (API GitHub). <p>Pour en savoir plus sur le fonctionnement pr\u00e9cis de cette impl\u00e9mentation, voir la classe <code>GithubOAuthProvider</code>.</p>"},{"location":"fr/admin/security/#implementation-ssocas","title":"Impl\u00e9mentation SSO/CAS","text":"<p>Cette impl\u00e9mentation a pour vocation de servir de pont entre un environnement entreprise et Tock. Elle est donc en partie sp\u00e9cifique \u00e0 chaque entreprise, dans la mesure ou il est n\u00e9cessaire de faire correspondre un profil utilisateur vers des groupes et r\u00f4les Tock.</p> <p>Elle est compos\u00e9e de :</p> <ul> <li>Une impl\u00e9mentation du m\u00e9canisme d'authentification CAS int\u00e9gr\u00e9e \u00e0 Tock ( bas\u00e9e sur 'PAC4J' )</li> <li>Votre module externalis\u00e9 qui va h\u00e9riter de cette impl\u00e9mentation, avec une (re)d\u00e9finition des r\u00f4les/groupes selon le   profil utilisateur</li> </ul> <p>L'authentification CAS est sp\u00e9cifique \u00e0 l'entreprise, et n\u00e9cessite un module d\u00e9di\u00e9 externe \u00e0 d\u00e9velopper pour Tock</p> <p>Example de module CAS: 'samples/tock-sample-cas-auth-provider'</p> <p>Voici les propri\u00e9t\u00e9s et leurs valeurs par d\u00e9faut :</p> Variable d'environnement Valeur par d\u00e9faut Description <code>tock_cas_auth_enabled</code> <code>false</code> Activation de l'authentification PAC4J/CAS. <code>tock_cas_auth_proxy_host</code> <code>127.0.0.1</code> Host du proxy (ne pas indiquer si pas de proxy) <code>tock_cas_auth_proxy_port</code> <code>3128</code> Port optionnel du proxy <code>tock_cas_join_same_namespace_per_user</code> <code>true</code> Lors de la cr\u00e9ation de l'utilisateur, si le namespace existe d\u00e9j\u00e0 et que d'autres utilisateurs sont d\u00e9j\u00e0 pr\u00e9sent, le nouvel utilisateur rejoint le m\u00eame namespace existant <p>Pour en savoir plus sur le fonctionnement pr\u00e9cis de cette impl\u00e9mentation, voir la classe <code>CASAuthProvider</code>.</p> <p>Note compl\u00e9mentaire:</p> <p>Lorsque l'authentification est de type SSO le bouton de Logout n'est pas disponible</p>"},{"location":"fr/admin/security/#donnees","title":"Donn\u00e9es","text":"<p>Les utilisateurs pouvant transmettre aux bots des donn\u00e9es personnelles \u00e0 travers leurs conversations, il est important de r\u00e9fl\u00e9chir \u00e0 la nature des donn\u00e9es manipul\u00e9es dans Tock Studio ou stock\u00e9es par Tock, et de mettre en oeuvre des m\u00e9canismes de protection appropri\u00e9s (anonymisation, chiffrement, dur\u00e9e de r\u00e9tention, restrictions d'acc\u00e8s bas\u00e9es sur des r\u00f4les, etc.).</p> <p>Voir en particulier la r\u00e9glementation RGPD.</p>"},{"location":"fr/admin/security/#chiffrement-des-donnees","title":"Chiffrement des donn\u00e9es","text":""},{"location":"fr/admin/security/#chiffrement-de-la-base","title":"Chiffrement de la base","text":"<p>Il est recommand\u00e9 de d\u00e9ployer vos bases de donn\u00e9es MongoDB en mode chiffr\u00e9.</p>"},{"location":"fr/admin/security/#chiffrement-applicatif","title":"Chiffrement applicatif","text":"<p>Tock peut r\u00e9aliser un chiffrement applicatif (facultatif) de certains champs en base de donn\u00e9es, ind\u00e9pendamment du chiffrement de la base elle-m\u00eame.</p> <p>C'est le r\u00f4le de la variable d'environnement <code>tock_encrypt_pass</code>, qui permet d'indiquer un mot de passe pour chiffrer et d\u00e9chiffrer ces champs. Par d\u00e9faut en environnement <code>prod</code>, Tock chiffre toutes les donn\u00e9es utilisateurs jug\u00e9es sensibles \u00e0 condition que <code>tock_encrypt_pass</code> soit d\u00e9fini.</p> <p>Pour plus de d\u00e9tails, vous pouvez vous r\u00e9ferrer au code source.</p> <p>Remarque : d\u00e9finir <code>tock_encrypt_pass</code> est requis pour utiliser les fonctions d'anonymisation d'entit\u00e9s NLP dans les interfaces Tock Studio.</p>"},{"location":"fr/admin/security/#anonymisation","title":"Anonymisation","text":"<p>Il est souvent souhaitable que certaines phrases soient anonymis\u00e9es que ce soit dans les logs (journalisation) ou dans l'interface (Tock Studio). Par exemple, des coordonn\u00e9es, num\u00e9ros de cartes de fid\u00e9lit\u00e9, etc. ne devraient \u00eatre lus ni par les utilisateurs de Tock Studio ni par les administrateurs de la plateforme.</p>"},{"location":"fr/admin/security/#par-le-framework","title":"Par le framework","text":"<p>Pour anonymiser ces donn\u00e9es, Tock met \u00e0 disposition dans son framework une solution bas\u00e9e sur des expressions r\u00e9guli\u00e8res (RegExp) dont l'interface de base est <code>StringObfuscator</code>.</p>"},{"location":"fr/admin/security/#par-le-modele-nlp","title":"Par le mod\u00e8le NLP","text":"<p>Tock permet \u00e9galement d'anonymiser dans Tock Studio (vue Inbox notamment.) les valeurs des entit\u00e9s reconnues par le mod\u00e8le NLP.</p> <p>Cette anonymisation par types d'entit\u00e9s se configure dans la vue Language Understanding &gt; Entities. Seuls les utilisateurs ayant un r\u00f4le <code>admin</code> ou <code>technicalAdmin</code> dans Tock Studio peuvent activer/d\u00e9sactiver cette fonctionnalit\u00e9.</p> <p>Pour en savoir plus, voir R\u00f4les.</p> <p>Dans les vues o\u00f9 les phrases sont affich\u00e9es anonymis\u00e9es (Inbox, Search par exemple), un <code>admin</code> ou <code>technicalAdmin</code> peut d\u00e9cider d'afficher quand m\u00eame (pour lui-m\u00eame uniquement) une phrase non anonymis\u00e9e gr\u00e2ce \u00e0 l'action Reveal the sentence (oeil ouvert).</p> <p>Remarque : d\u00e9finir <code>tock_encrypt_pass</code> est requis pour utiliser les fonctions d'anonymisation d'entit\u00e9s NLP dans les interfaces Tock Studio.</p>"},{"location":"fr/admin/security/#stockage-conservation","title":"Stockage &amp; conservation","text":"<p>Tock stocke automatiquement diff\u00e9rents types de donn\u00e9es, allant d'informations peu sensibles (configuration de Stories et r\u00e9ponses du bot, structure des intentions, statistiques de navigation tous utilisateurs confondus, etc.) \u00e0 des donn\u00e9es plus personnelles (d\u00e9tails des conversations, pr\u00e9f\u00e9rences utilisateurs, etc.).</p> <p>En fonction de leur nature et leur utilisation dans le fonctionnement de Tock (NLP, supervision, debug...), ces donn\u00e9es ont des dur\u00e9es de r\u00e9tention sp\u00e9cifiques, et configurables. Chaque utilisateur de Tock d\u00e9cide et configure combien de temps les donn\u00e9es stock\u00e9es sont conserv\u00e9es, en fonction de ses besoins.</p> <p>La section Installation &gt; Conservation des donn\u00e9es d\u00e9crit les diff\u00e9rents types de donn\u00e9es conserv\u00e9es et comment modifier leur dur\u00e9e de r\u00e9tention.</p>"},{"location":"fr/admin/supervision/","title":"Supervision","text":"<p>Ce chapitre pr\u00e9sente quelques aspects supervision et monitoring du fonctionnement de la plateforme  et des bots Tock.</p> <p>A venir : plus de d\u00e9tails sur la mani\u00e8re de monitorer les bots, voire des exemples de dashboards pour quelques  technologies de monitoring classiques. N'h\u00e9sitez pas \u00e0 partager les v\u00f4tres.</p>"},{"location":"fr/admin/supervision/#lignes-de-vie-healthchecks","title":"Lignes de vie (healthchecks)","text":"<p>Les API des diff\u00e9rents composants Tock comportent diff\u00e9rentes sondes ou lignes de vie (healthchecks) permettant  de v\u00e9rifier si tout fonctionne correctement. Ces lignes de vie peuvent \u00eatre utilis\u00e9es par les syst\u00e8mes de supervision automatis\u00e9s.</p>"},{"location":"fr/admin/supervision/#sondes-chemins","title":"Sondes &amp; chemins","text":"<p>Chaque <code>WebVerticle</code> expose 3 sondes renvoyant le code <code>HTTP 200</code> si tout fonctionne.</p> Chemin par d\u00e9faut Description Propri\u00e9t\u00e9 pour modifier le chemin <code>/healthcheck</code> Le composant fonctionne correctement. (Mode d\u00e9taill\u00e9 : voir plus bas) <code>tock_vertx_healthcheck_path</code> <code>/health/readiness</code> Le composant est pr\u00eat \u00e0 traiter des requ\u00eates. <code>tock_vertx_readinesscheck_path</code> <code>/health/liveness</code> Le composant est d\u00e9marr\u00e9. <code>tock_vertx_livenesscheck_path</code> <p>Pour certains composants et images, le ligne de vie ne pouvant pas \u00eatre expos\u00e9e directement \u00e0 la racine, le chemin est modifi\u00e9. En particulier :</p> <ul> <li>Pour <code>tock/admin</code>, la ligne de vie est localis\u00e9e par d\u00e9faut dans <code>/rest/admin/healthcheck</code></li> <li>Pour <code>tock/nlp_api</code>, la ligne de vie est <code>/rest/nlp/healthcheck</code></li> </ul> <p>Chaque chemin par d\u00e9faut peut \u00eatre modifi\u00e9e avec une propri\u00e9t\u00e9 d\u00e9di\u00e9e (voir tableau ci-dessus).</p>"},{"location":"fr/admin/supervision/#mode-detaille","title":"Mode d\u00e9taill\u00e9","text":"<p>La ligne de vie principale <code>/healthcheck</code> peut effectuer une inspection plus d\u00e9taill\u00e9e (ie. g\u00e9n\u00e9ralement v\u00e9rifier  la connexion \u00e0 d'autres composants) si l'on active la propri\u00e9t\u00e9 <code>tock_detailed_healthcheck_enabled</code>. La r\u00e9ponse de la ligne de vie pr\u00e9cise alors les composants v\u00e9rifi\u00e9s.</p> <p>Voici un exemple d'activation dans l'image Docker <code>bot_admin</code> :</p> <ul> <li> <p>{: data-hl-lines=\"6\"} docker-compose.yml <pre><code>    version: '3'\n    services:\n      admin_web:\n        image: tock/bot_admin:$TAG\n        environment:\n        - tock_detailed_healthcheck_enabled=true\n</code></pre></p> </li> <li> <p>{: data-hl-lines=\"8\"} dockerrun.aws.json <pre><code>  {\n    \"AWSEBDockerrunVersion\": 2,\n    \"containerDefinitions\": [\n      {\n        \"name\": \"admin_web\",\n        \"image\": \"tock/bot_admin:${TAG}\",\n        \"environment\": [\n          { \"name\": \"tock_detailed_healthcheck_enabled\", \"value\": \"true\" }\n        ]\n      }\n    ]\n  }\n</code></pre> {: .tabbed-code}</p> </li> </ul> <p>Exemple de r\u00e9ponse de la ligne de vie en mode d\u00e9taill\u00e9 :</p> <pre><code>  {\n    \"results\": [\n      {\n        \"id\": \"duckling_service\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_front_database\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_model_database\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_bot_database\",\n        \"status\": \"OK\"\n      }\n    ]\n  }\n</code></pre> <p>Voir ci-dessous pour une synth\u00e8se des lignes de vie composant par composant.</p>"},{"location":"fr/admin/supervision/#details-par-composants","title":"D\u00e9tails par composants","text":"<p>Le tableau ci-dessous d\u00e9taille le chemin et les v\u00e9rifications effectu\u00e9es par la ligne de vie principale composant  par composant, en mode normal et en mode d\u00e9taill\u00e9 :</p> Composant / image Chemin par d\u00e9faut V\u00e9rification par d\u00e9faut V\u00e9rification d\u00e9taill\u00e9e (<code>tock_detailed_healthcheck_enabled=true</code>) NLP <code>/rest/nlp/healthcheck</code> Duckling / entity providers OK. Bases de donn\u00e9es <code>front</code> et <code>model</code> OK. Duckling / RestEntityProvider <code>/healthcheck</code> Duckling bridge initialis\u00e9. Idem Build Worker <code>/healthcheck</code> Worker pr\u00eat \u00e0 analyser le mod\u00e8le. Bases de donn\u00e9es <code>front</code> et <code>model</code> OK. Bot / Bot Api <code>/healthcheck</code> Bot install\u00e9, connect\u00e9 \u00e0 la base de donn\u00e9es, NLP OK. Idem WebHook (Bot Api) <code>/healthcheck</code> OK Idem Kotlin Compiler <code>/healthcheck</code> OK Idem NLP / Bot Admin <code>/rest/admin/healthcheck</code> OK Duckling / entity providers OK, bases de donn\u00e9es <code>front</code> <code>model</code> et <code>bot</code> OK. <p>Ci-dessous des exemples de r\u00e9ponses de diff\u00e9rents composants en mode d\u00e9taill\u00e9 :</p> <ul> <li> <p>NLP <pre><code>  {\n    \"results\": [\n      {\n        \"id\": \"duckling_service\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_front_database\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_model_database\",\n        \"status\": \"OK\"\n      }\n    ]\n  }\n</code></pre></p> </li> <li> <p>Duckling <pre><code>  {\n    \"results\": [\n      {\n        \"id\": \"duckling_bridge\",\n        \"status\": \"OK\"\n      }\n    ]\n  }\n</code></pre></p> </li> <li> <p>Build Worker <pre><code>  {\n    \"results\": [\n      {\n        \"id\": \"tock_front_database\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_model_database\",\n        \"status\": \"OK\"\n      }\n    ]\n  }\n</code></pre></p> </li> <li> <p>Bot Api <pre><code>  {\n    \"results\": [\n      {\n        \"id\": \"nlp_client\",\n        \"status\": \"OK\"\n      }\n    ]\n  }\n</code></pre></p> </li> <li> <p>Kotlin Compiler <pre><code>  {\n    \"results\": []\n  }\n</code></pre></p> </li> <li> <p>Bot Admin <pre><code>  {\n    \"results\": [\n      {\n        \"id\": \"duckling_service\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_front_database\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_model_database\",\n        \"status\": \"OK\"\n      },\n      {\n        \"id\": \"tock_bot_database\",\n        \"status\": \"OK\"\n      }\n    ]\n  }\n</code></pre> {: .tabbed-code}</p> </li> </ul>"},{"location":"fr/admin/supervision/#supervision-des-lignes-de-vie","title":"Supervision des lignes de vie","text":"<p>Les diff\u00e9rentes sondes et lignes de vie peuvent \u00eatre utilis\u00e9es pour configurer les syst\u00e8mes de supervision et autres  orchestrateurs de conteneurs par exemple, pour mesurer la disponibilit\u00e9 des services, d\u00e9clencher des alertes ou  rem\u00e9dier aux probl\u00e8mes dynamiquement.</p> <p>Selon les outils et technologies utilis\u00e9es, la configuration des lignes de vie peut se faire de diff\u00e9rentes mani\u00e8res. Voici quelques exemples \u00e0 titre indicatif :</p> <ul> <li>Au niveau des r\u00e9partiteurs de charge (load balancers) Cloud ou on-premise, par exemple :<ul> <li>dans la section Health checks au niveau ELB dans AWS</li> <li>avec la directive <code>health_check</code> dans NGINX</li> <li>avec l'<code>option httpchk</code> dans HAProxy</li> </ul> </li> <li>Dans Docker (descripteurs <code>Dockerfile</code>) :<ul> <li>avec l'instruction <code>HEALTHCHECK</code> pour v\u00e9rifier le   statut du composant</li> <li>avec <code>ENTRYPOINT</code> ou <code>CMD</code>    pour attendre que le composant soit pr\u00eat au d\u00e9marrage</li> </ul> </li> <li>Dans Docker Compose (descripteurs <code>docker-compose.yml</code>) :<ul> <li>avec <code>healthcheck</code></li> </ul> </li> <li>Dans Kubernetes :<ul> <li>avec <code>livenessProbe</code> et <code>readinessProbe</code></li> </ul> </li> <li>Etc.</li> </ul>"},{"location":"fr/admin/supervision/#journalisation-logs","title":"Journalisation (logs)","text":""},{"location":"fr/admin/supervision/#logs-applicatifs","title":"Logs applicatifs","text":"<p>Tock utilise SLF4J et Logback pour g\u00e9n\u00e9rer ses logs applicatifs c\u00f4t\u00e9 serveur.</p> <p>Par d\u00e9faut Tock configure automatiquement ses logs et quelques propri\u00e9t\u00e9s permettent de modifier la configuration.</p> <p>Il est possible de configurer finement les logs en fonction des besoins, notamment avec des fichiers de  configuration Logback ou avec Docker Compose.</p>"},{"location":"fr/admin/supervision/#auto-configuration","title":"Auto-configuration","text":"<p>Par d\u00e9faut, en l'absence de configuration sp\u00e9cifique, Tock configure ses logs automatiquement gr\u00e2ce \u00e0 la classe  <code>LogbackConfigurator</code>. Celle-ci configure Logback programmatiquement, avec le comportement suivant :</p> <ul> <li>Niveau de log g\u00e9n\u00e9ral <code>DEBUG</code> si <code>tock_env=dev</code> (par d\u00e9faut), ou <code>INFO</code> pour les autres environnements et la production<ul> <li>Exception pour les logs <code>org.mongodb.driver</code> toujours \u00e0 <code>INFO</code></li> <li>Exception pour les logs <code>io.netty</code> toujours \u00e0 <code>INFO</code></li> <li>Exception pour les logs <code>okhttp3</code> toujours \u00e0 <code>INFO</code></li> <li>Exception pour les logs <code>io.mockk</code> toujours \u00e0 <code>INFO</code></li> </ul> </li> <li>Logs dirig\u00e9s vers la console (sortie standard) par d\u00e9faut, mais possibilit\u00e9 d'\u00e9crire dans des fichiers<ul> <li>En mode logs fichiers, \u00e9criture dans <code>log/logFile.log</code>, archivage d'un fichier chaque jour  (<code>log/logFile.%d{yyyy-MM-dd}.log</code>), maximum <code>30</code> jours ou <code>3GB</code> de logs conserv\u00e9s</li> </ul> </li> </ul> <p>Pour en savoir plus sur la configuration automatiques des logs Tock, se r\u00e9f\u00e9rer \u00e0 l'impl\u00e9mentation  <code>LogbackConfigurator</code>.</p> <p>Des variables d'environnement permettent de configurer ces diff\u00e9rents modes de journalisation.  Elles peuvent \u00eatre d\u00e9finies ind\u00e9pendamment sur chaque composant produisant des logs.</p> Variable d'environnement Valeur par d\u00e9faut Description <code>tock_env</code> <code>dev</code> Environnement (attention : contr\u00f4le d'autres m\u00e9canismes que les logs). <code>tock_logback_enabled</code> <code>true</code> Activation des logs. <code>tock_default_log_level</code> <code>DEBUG</code> si <code>tock_env=dev</code> (autrement <code>INFO</code>) Niveau de log g\u00e9n\u00e9ral (hors exceptions, voir plus haut). <code>tock_retrofit_log_level</code> <code>BASIC</code> si <code>tock_env=dev</code> (autrement <code>NONE</code>) Niveau de logs (requ\u00eates et r\u00e9ponses) pour les services clients applicatifs utilisant Retrofit (TockNlpClient, BotApiClient, et bon nombre de connecteurs...) <code>tock_logback_file_appender</code> <code>false</code> Logs fichiers (voir d\u00e9tails plus haut) \u00e0 la place des logs console (sortie standard). <p>Selon le mode de d\u00e9ploiement utilis\u00e9, ces variables d'environnement peuvent \u00eatre ajout\u00e9es soit  directement en ligne de commande, soit dans un descripteur type <code>docker-compose.yml</code>, <code>dockerrun.aws.json</code> ou autre.</p> <p>Voici un exemple configurant les logs de Tock Studio (<code>admin_web</code>) dans Docker :</p> <ul> <li> <p>{: data-hl-lines=\"6 7\"} docker-compose.yml <pre><code>  version: '3'\n  services:\n    admin_web:\n      image: tock/bot_admin:$TAG\n      environment:\n      - tock_default_log_level=WARN\n      - tock_logback_file_appender=true\n</code></pre></p> </li> <li> <p>{: data-hl-lines=\"8\"} dockerrun.aws.json <pre><code>  {\n    \"AWSEBDockerrunVersion\": 2,\n    \"containerDefinitions\": [\n      {\n        \"name\": \"admin_web\",\n        \"image\": \"tock/bot_admin:${TAG}\",\n        \"environment\": [\n          { \"name\": \"tock_default_log_level\", \"value\": \"WARN\" },\n          { \"name\": \"tock_logback_file_appender\", \"value\": \"true\" }\n        ]\n      }\n    ]\n  }\n</code></pre> {: .tabbed-code}</p> </li> </ul>"},{"location":"fr/admin/supervision/#fichiers-logback","title":"Fichiers Logback","text":"<p>Il est possible de configurer finement les logs Tock en configurant directement Logback. Pour cela, diff\u00e9rentes possibilit\u00e9s existent, notamment des fichiers de configuration en format XML ou Groovy.  Ci-dessous un exemple de configuration :</p> <ul> <li>logback.xml <pre><code>    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n    &lt;configuration debug=\"false\"&gt;\n\n        &lt;logger name=\"ai.tock\" level=\"DEBUG\" /&gt;\n\n        &lt;logger name=\"org.mongodb\" level=\"WARN\" /&gt;\n\n        &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n            &lt;encoder&gt;\n                &lt;pattern&gt;\n                    %d %-5level [%thread] %logger{1}: %msg%n\n                &lt;/pattern&gt;\n            &lt;/encoder&gt;\n        &lt;/appender&gt;\n\n        &lt;root level=\"INFO\"&gt;\n            &lt;appender-ref ref=\"console\" /&gt;\n        &lt;/root&gt;\n\n    &lt;/configuration&gt;\n</code></pre></li> <li>logback.groovy <pre><code>    import ch.qos.logback.classic.encoder.PatternLayoutEncoder\n    import ch.qos.logback.core.ConsoleAppender\n\n    import static ch.qos.logback.classic.Level.DEBUG\n    import static ch.qos.logback.classic.Level.INFO\n    import static ch.qos.logback.classic.Level.WARN\n\n    appender(\"console\", ConsoleAppender) {\n      encoder(PatternLayoutEncoder) {\n        pattern = \"%d %-5level [%thread] %logger{1}: %msg%n\"\n      }\n    }\n    logger(\"ai.tock\", DEBUG)\n    logger(\"org.mongodb\", WARN)\n    root(INFO, [\"console\"])\n</code></pre> {: .tabbed-code}</li> </ul> <p>Dans cet exemple :</p> <ul> <li>Le niveau de log g\u00e9n\u00e9ral est <code>INFO</code>, avec des exceptions :<ul> <li>Exception pour les logs <code>ai.tock</code> toujours \u00e0 <code>DEBUG</code></li> <li>Exception pour les logs <code>org.mongodb</code> toujours \u00e0 <code>WARN</code></li> </ul> </li> <li>Les logs sont dirig\u00e9s vers la console (sortie standard)</li> </ul> <p>De nombreuses possibilit\u00e9s sont offertes pour configurer les logs gr\u00e2ce \u00e0 ces fichiers de configuration : niveaux de logs ajust\u00e9s en fonction des packages/frameworks embarqu\u00e9s, modification du pattern par d\u00e9faut,  journalisation de logs fichiers et archivage auto avec un  <code>RollingFileAppender</code>, redirection des logs  vers un serveur de base de donn\u00e9es ou email, etc. Pour en savoir plus, se r\u00e9f\u00e9rer \u00e0 la documentation Logback.</p> <p>Une fois le fichier de configuration Logback cr\u00e9\u00e9, il faut s'assurer que celui-ci est dans la classpath du  composant Tock et que Logback l'identifie comme la configuration \u00e0 suivre (pour cela on utilise g\u00e9n\u00e9ralement  la propri\u00e9t\u00e9 <code>-Dlogback.configurationFile</code> au d\u00e9marrage du composant Java).</p> <p>Ci-dessous un exemple complet dans Docker Compose avec :</p> <ul> <li>Un fichier <code>logback.xml</code> embarqu\u00e9 par Maven (<code>pom.xml</code>) dans l'image Docker</li> <li>Quelques variables d'environnement d\u00e9finies pour pouvoir rapidement ajuste les principaux niveaux de log  directement dans Docker-Compose (sans avoir \u00e0 modifier le fichier XML ni l'image Docker)'</li> </ul> <p>^ - logback.xml <pre><code>    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n    &lt;configuration debug=\"false\"&gt;\n\n        &lt;!-- Leverage env variables with defaults, for more flexibility --&gt;\n        &lt;variable name=\"tock_default_log_level\" value=\"${tock_default_log_level:-WARN}\" /&gt;\n        &lt;variable name=\"tock_service_log_level\" value=\"${tock_service_log_level:-INFO}\" /&gt;\n        &lt;variable name=\"tock_database_log_level\" value=\"${tock_database_log_level:-WARN}\" /&gt;\n\n        &lt;logger name=\"ai.tock\" level=\"${tock_service_log_level}\" /&gt;\n        &lt;logger name=\"org.mongodb\" level=\"${tock_database_log_level}\" /&gt;\n\n        &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n            &lt;encoder&gt;\n                &lt;pattern&gt;\n                    %d %-5level [%thread] %logger{1}: %msg%n\n                &lt;/pattern&gt;\n            &lt;/encoder&gt;\n        &lt;/appender&gt;\n\n        &lt;root level=\"${tock_default_log_level}\"&gt;\n            &lt;appender-ref ref=\"console\" /&gt;\n        &lt;/root&gt;\n\n    &lt;/configuration&gt;\n</code></pre> - {: data-hl-lines=\"21 22 23 24 29\"} pom.xml <pre><code>    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n    &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n        &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n        &lt;artifactId&gt;tock-docker-bot-admin&lt;/artifactId&gt;\n        &lt;build&gt;\n            &lt;plugins&gt;\n                &lt;plugin&gt;\n                    &lt;groupId&gt;io.fabric8&lt;/groupId&gt;\n                    &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;\n                    &lt;configuration&gt;\n                        &lt;images&gt;\n                            &lt;image&gt;\n                                &lt;name&gt;tock/bot_admin:${project.version}&lt;/name&gt;\n                                &lt;build&gt;\n                                    &lt;assembly&gt;\n                                        &lt;inline&gt;\n                                            &lt;dependencySets&gt;\n                                                ...\n                                            &lt;/dependencySets&gt;\n                                            &lt;files&gt;\n                                                &lt;file&gt;\n                                                    &lt;source&gt;logback.xml&lt;/source&gt;\n                                                    &lt;outputDirectory&gt;.&lt;/outputDirectory&gt;\n                                                &lt;/file&gt;\n                                            &lt;/files&gt;\n                                        &lt;/inline&gt;\n                                    &lt;/assembly&gt;\n                                    &lt;cmd&gt;\n                                        &lt;shell&gt;java $JAVA_ARGS -Dlogback.configurationFile='file:///maven/logback.xml' -Dfile.encoding=UTF-8 -Dtock_nlp_model_refresh_rate=10 -cp '/maven/*' ai.tock.bot.admin.StartBotAdminServerKt&lt;/shell&gt;\n                                    &lt;/cmd&gt;\n                                    ...\n</code></pre> - {: data-hl-lines=\"6 7 8\"} docker-compose.yml <pre><code>    version: '3'\n    services:\n      admin_web:\n        image: tock/bot_admin:$TAG\n        environment:\n        - tock_default_log_level=WARN # Default, see logback.xml\n        - tock_service_log_level=INFO # Default, see logback.xml\n        - tock_database_log_level=WARN # Default, see logback.xml\n</code></pre> {: .tabbed-code}</p> <p>Le code complet de cet exemple appliqu\u00e9 \u00e0 tous les modules Tock est disponible dans le d\u00e9p\u00f4t <code>tock-docker</code>  sur la branche <code>logbackxml</code>.</p>"},{"location":"fr/admin/supervision/#docker-compose","title":"Docker Compose","text":"<p>Pour les utilisateurs de Docker Compose, un m\u00e9canisme permet de configurer les logs directement dans les  descripteurs en YAML. Voir le d\u00e9pot <code>tock-docker</code> pour un  exemple d'impl\u00e9mentation de Tock dans Docker Compose.</p> <p>Chaque composant applicatif peut avoir sa propre configuration :</p> <ul> <li>docker-compose.yml <pre><code>logging:\n  driver: \"json-file\"\n  options:\n    max-size: \"10m\"\n    max-file: \"5\"\n</code></pre> {: .tabbed-code}</li> </ul> <p>L'exemple ci-dessus configure une rotation automatique des fichiers de logs, de mani\u00e8re \u00e0 avoir maximum  <code>5</code> fichiers de logs de maximum <code>10 Mo</code> chacun (le plus ancien \u00e9tant supprim\u00e9 pour en cr\u00e9er un nouveau si besoin).</p> <p>Pour en savoir plus, voir la documentation Docker Compose de ce m\u00e9canisme.</p>"},{"location":"fr/admin/supervision/#chiffrement-et-anonymisation","title":"Chiffrement et anonymisation","text":"<p>Voir la page s\u00e9curit\u00e9 concernant les possibilit\u00e9s de chiffrement et anonymisation des logs.</p>"},{"location":"fr/admin/synchronization/","title":"Documentation de la Fonctionnalit\u00e9 de Synchronisation Multilingue","text":"<p>Cette documentation pr\u00e9sente en d\u00e9tail notre fonctionnalit\u00e9 de synchronisation multilingue d\u00e9sormais accessible via les param\u00e8tres de votre application. Elle se pr\u00e9sente comme suit :</p> <p></p> <p>Cette fonctionnalit\u00e9 demande \u00e0 l'utilisateur de sp\u00e9cifier une source et une cible, chacune associ\u00e9e \u00e0 un namespace et une application, pour synchroniser les donn\u00e9es entre diff\u00e9rents bots. Elle facilite le d\u00e9veloppement, les tests et la maintenance de vos chatbots, que ce soit en mode monolingue ou multilingue.</p>"},{"location":"fr/admin/synchronization/#activation","title":"Activation","text":"<p>Vous devez demander \u00e0 votre administrateur de passer la propri\u00e9t\u00e9 <code>tock_namespace_open_access</code>\u00e0 <code>true</code> sur tock studio pour pouvoir acc\u00e9der \u00e0 cette fonctionnalit\u00e9.</p>"},{"location":"fr/admin/synchronization/#fonctionnalites-cles","title":"Fonctionnalit\u00e9s Cl\u00e9s :","text":"<p>La fonction de synchronisation offre plusieurs fonctionnalit\u00e9s essentielles :</p> <ul> <li>Copie de Stories et d'Intentions : Vous pouvez synchroniser des \"stories\" et leurs intentions entre un bot Source et un bot Target, que ce soit en environnement de d\u00e9veloppement ou de production. Cela facilite les tests et les am\u00e9liorations sans affecter directement la version en production.</li> </ul> <p>ATTENTION: Il est important de noter que lors de la synchronisation, les \"stories\" du bot de target qui ne se trouvent pas dans le bot de source seront supprim\u00e9es, et le reste sera \u00e9cras\u00e9 par les \"stories\" du bot source.</p> <ul> <li>\u00c9crasement de l'Entra\u00eenement : L\u2019entra\u00eenement du bot Source \u00e9crase celui du bot Target.</li> </ul> <p>INFO: Seules les informations pr\u00e9existantes dans le bot Source sont affect\u00e9es, pr\u00e9servant ainsi les informations sp\u00e9cifiques au bot Target qui ne sont pas d\u00e9riv\u00e9es du bot Source.</p> <ul> <li>Copie des phrases non entra\u00een\u00e9es (Copy inbox messages) : lorsque cette fonctionnalit\u00e9 est activ\u00e9e, les phrases non entrain\u00e9es sont aussi rapatri\u00e9es. Le cas d'utilisation typique de cette fonctionnalit\u00e9 est de permettre de copier un bot en production poss\u00e9dant des phrases non entrain\u00e9es vers un bot de pre-prod afin d'entra\u00eener ces phrases sur des intentions nouvellement cr\u00e9\u00e9es.</li> </ul>"},{"location":"fr/admin/synchronization/#interets-de-la-fonctionnalite-avec-exemples-dutilisation","title":"Int\u00e9r\u00eats de la Fonctionnalit\u00e9 avec Exemples d'Utilisation :","text":"<p>La synchronisation offre des avantages significatifs :</p> <ul> <li>Am\u00e9lioration Efficace : La synchronisation permet d'am\u00e9liorer un chatbot en production sans perturber la version en cours. Par exemple, si vous avez un chatbot de service client en production (bot Target) et que vous souhaitez ajouter de nouvelles fonctionnalit\u00e9s d\u00e9velopp\u00e9es dans l'environnement de d\u00e9veloppement (bot Source).</li> </ul> <p>Exemple d'Utilisation : Vous pouvez int\u00e9grer de nouvelles \"stories,\" intentions et donn\u00e9es d'entra\u00eenement du bot d'origine dans le bot de destination sans perturber le service client actuel. Cela permet d'\u00e9tendre les capacit\u00e9s du chatbot en production tout en maintenant la continuit\u00e9 du service.</p> <ul> <li>Enrichissement de l'Entra\u00eenement : La copie de l'entra\u00eenement du bot d'origine dans le bot de destination permet d'enrichir les capacit\u00e9s du bot de destination.</li> </ul> <p>Exemple d'Utilisation : Si le bot de destination avait appris que \"hello\" est li\u00e9 \u00e0 l'intention \"greetings,\" mais que le bot d'origine a \u00e9t\u00e9 entra\u00een\u00e9 avec \"hello\" associ\u00e9 \u00e0 l'intention \"test,\" la synchronisation mettra \u00e0 jour le bot de destination pour inclure cette nouvelle compr\u00e9hension, tout en conservant l'entra\u00eenement pr\u00e9c\u00e9dent. Cela permet d'am\u00e9liorer la pr\u00e9cision et la compr\u00e9hension du bot de destination sans perdre les connaissances pr\u00e9existantes.</p>"},{"location":"fr/admin/synchronization/#conclusion","title":"Conclusion :","text":"<p>La fonction de synchronisation multilingue am\u00e9liore la gestion des chatbots en permettant une synchronisation efficace entre diff\u00e9rents bots, qu'ils soient en d\u00e9veloppement ou en production. Elle facilite l'am\u00e9lioration, l'ajout de nouvelles \"stories\" et intentions, et l'enrichissement de l'entra\u00eenement du bot de destination, tout en pr\u00e9servant son entit\u00e9 pr\u00e9c\u00e9dente. Bien que des limitations subsistent, l'\u00e9quipe continue de travailler pour am\u00e9liorer cette fonctionnalit\u00e9 et offrir une solution polyvalente pour la gestion des chatbots.</p>"},{"location":"fr/dev/api/","title":"Les APIs Tock","text":"<p>Cette section de la documentation Tock pr\u00e9sente sommairement les diff\u00e9rentes API fournies avec Tock.</p>"},{"location":"fr/dev/api/#tock-web-connector-api","title":"Tock Web Connector API","text":"<p>Le connecteur Web de Tock permet de dialoguer avec un bot \u00e0 travers une API REST.</p> <p>La documentation de cette API est disponible dans /api/web-connector. </p>"},{"location":"fr/dev/api/#tock-nlu-api","title":"Tock NLU API","text":"<p>L'API NLU / NLP de Tock (reconnaissance du langage naturel) permet d'interroger programmatiquement le  mod\u00e8le conversationnel et d'analyser une phrase.</p> <p>La documentation de l'API Tock NLU est disponible dans /api.</p> <p>Vous pouvez retrouver cette documentation sur la plateforme de d\u00e9monstration Tock, \u00e0 l'adresse https://demo.tock.ai/doc/.</p> <p>Si vous avez d\u00e9ploy\u00e9 une plateforme Tock en local avec les images docker  fournies, vous pouvez retrouver cette documentation en ligne \u00e0 l'adresse http://localhost/doc/index.html.</p>"},{"location":"fr/dev/api/#tock-studio-admin-api","title":"Tock Studio / Admin API","text":"<p>De m\u00eame, la documentation de l'API Tock Studio est disponible dans /api/admin. </p> <p>Vous pouvez retrouver cette documentation sur la plateforme de d\u00e9monstration Tock, \u00e0 l'adresse https://demo.tock.ai/doc/admin.html.</p> <p>Si vous avez d\u00e9ploy\u00e9 une plateforme Tock en local avec les images docker  fournies, vous pouvez retrouver cette documentation en ligne \u00e0 l'adresse http://localhost/doc/admin.html.</p>"},{"location":"fr/dev/api/#tock-bot-definition-api","title":"Tock Bot Definition API","text":"<p>Cette API permet de cr\u00e9er des bots et des parcours (stories) avec n'importe quel langage.  Un bot Tock peut \u00eatre compos\u00e9 de parcours configur\u00e9s dans Tock Studio, compl\u00e9t\u00e9s par des parcours   d\u00e9velopp\u00e9s dans un langage de programmation pour impl\u00e9menter des r\u00e8gles complexes, interagir avec    d'autres APIs, etc.</p> <p>Cette API est utilis\u00e9e par les clients Kotlin, Javascript/Nodejs et Python disponibles en modes WebHook et WebSocket.</p> <p>L'API est toutefois encore en d\u00e9veloppement (b\u00e9ta) et sa documentation arrivera bient\u00f4t.</p> <p>Pour d\u00e9velopper en mode Bot API, voir cette page.</p>"},{"location":"fr/dev/bot-api/","title":"D\u00e9velopper en mode Tock Bot API","text":"<p>Le mode Bot API de Tock permet de d\u00e9velopper des bots en se connectant \u00e0 une plateforme Tock Studio en  utilisant l'API REST conversationnelle de Tock.</p> <p>C'est donc le mode de d\u00e9veloppement Tock recommand\u00e9 pour d\u00e9marrer, ainsi que dans des scenarios ou l'acc\u00e8s partag\u00e9 \u00e0 la  base de donn\u00e9es serait un probl\u00e8me.</p> <p>Seul le mode Bot API est disponible sur la plateforme de d\u00e9monstration publique Tock.</p> <p>Cette page pr\u00e9sente le d\u00e9veloppement de bots Tock en mode Bot API en Kotlin.  Des clients sont aussi disponibles pour Javascript/Node et Python. Il est possible de d\u00e9velopper des parcours Tock dans n'importe quel langage via la Bot API.</p> <p> </p> <p>Une autre section pr\u00e9sente le mode Bot Framework disponible pour Kotlin uniquement,  plus int\u00e9gr\u00e9 mais aussi plus coupl\u00e9 \u00e0 la plateforme Tock.</p>"},{"location":"fr/dev/bot-api/#se-connecter-sur-la-plateforme-de-demonstration","title":"Se connecter sur la plateforme de d\u00e9monstration","text":"<p>Plut\u00f4t que d\u00e9ployer se propre plateforme Tock, il est possible de tester les modes WebSocket ou Webhook directement sur la plateforme de d\u00e9monstration Tock. </p>"},{"location":"fr/dev/bot-api/#developper-en-kotlin","title":"D\u00e9velopper en Kotlin","text":""},{"location":"fr/dev/bot-api/#activer-le-mode-websocket","title":"Activer le mode WebSocket","text":"<p>C'est le mode \u00e0 privil\u00e9gier au d\u00e9marrage car le plus simple \u00e0 mettre en oeuvre.</p> <p>Pour utiliser le client websocket, il faut ajouter la d\u00e9pendance <code>tock-bot-api-websocket</code> \u00e0 votre application/projet Kotlin.</p> <p>Par exemple dans un projet Maven :</p> <pre><code>        &lt;dependency&gt;\n            &lt;groupId&gt;ai.tock&lt;/groupId&gt;\n            &lt;artifactId&gt;tock-bot-api-websocket&lt;/artifactId&gt;\n            &lt;version&gt;24.9.4&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre> <p>Ou dans un projet Gradle :</p> <pre><code>      compile 'ai.tock:tock-bot-api-websocket:24.9.4'\n</code></pre>"},{"location":"fr/dev/bot-api/#activer-le-mode-webhook","title":"Activer le mode WebHook","text":"<p>De mani\u00e8re alternative, vous pouvez choisir d'utiliser le client WebHook, il faut ajouter la d\u00e9pendance <code>tock-bot-api-webhook</code> \u00e0 votre application/projet Kotlin.</p> <p>Par exemple dans un projet Maven :</p> <pre><code>        &lt;dependency&gt;\n            &lt;groupId&gt;ai.tock&lt;/groupId&gt;\n            &lt;artifactId&gt;tock-bot-api-webhook&lt;/artifactId&gt;\n            &lt;version&gt;24.9.4&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre> <p>Ou dans un projet Gradle :</p> <pre><code>      compile 'ai.tock:tock-bot-api-webhook:24.9.4'\n</code></pre> <p>Dans ce cas, contrairement au mode WebSocket, il faut que l'application/bot d\u00e9marr\u00e9e soit joignable par la   plateforme Tock via une URL publique (vous pouvez utilisez par exemple ngrok). </p> <p>Cette URL doit \u00eatre indiqu\u00e9e dans le champ webhook url dans la vue Configuration &gt; Bot Configurations   de l'interface Tock Studio.</p>"},{"location":"fr/dev/bot-api/#parametrer-la-cle-dapi","title":"Param\u00e9trer la cl\u00e9 d'API","text":"<p>Dans Tock Studio, apr\u00e8s avoir configur\u00e9 un bot, allez dans Configuration &gt; Bot Configurations et copiez  la cl\u00e9 d'API du bot auquel vous souhaitez vous connecter.</p> <p>Vous pourrez saisir/coller cette clef dans le code Kotlin (voir ci-dessous).</p>"},{"location":"fr/dev/bot-api/#creer-des-parcours-en-kotlin","title":"Cr\u00e9er des parcours en Kotlin","text":"<p>Pour le moment, les composants suivants sont support\u00e9s pour les r\u00e9ponses :</p> <ul> <li>Texte avec Boutons (Quick Reply)</li> <li>Format \"carte\"</li> <li>Format \"carousel\"</li> <li>Formats sp\u00e9cifiques aux diff\u00e9rents canaux int\u00e9gr\u00e9s</li> </ul> <p>Voici un exemple de bot simple avec quelques parcours d\u00e9clar\u00e9s : </p> <pre><code>fun main() {\n    startWithDemo(\n        newBot(\n            \"PUT-YOUR-TOCK-APP-API-KEY-HERE\", // R\u00e9cup\u00e9rer la cl\u00e9 d'API \u00e0 partir de l'onglet \"Bot Configurations\" dans Tock Studio\n             newStory(\"greetings\") { // Intention 'greetings'\n                 end(\"Bonjour!\") // R\u00e9ponse texte simple\n             },\n             newStory(\"location\") { // Intention 'location'\n                 end(\n                     // R\u00e9ponse avec une carte - pouvant inclure du texte, un fichier (par exemple une image) et des suggestions d'action utilisateur\n                     newCard(\n                         \"Le titre de la carte\",\n                         \"Un sous-titre\",\n                         newAttachment(\"https://url-image.png\"),\n                         newAction(\"Action 1\"),\n                         newAction(\"Action 2\", \"http://redirection\") \n                     )\n                 )\n             },\n             newStory(\"goodbye\") { // Intention 'goodbye'\n                 end {\n                     // R\u00e9ponse sp\u00e9cifique au format Messenger \n                     buttonsTemplate(\"Etes-vous s\u00fbr(e) de vouloir partir ?\", nlpQuickReply(\"Je reste\"))\n                 } \n             },\n             // R\u00e9ponse fournie pas le bot en cas d'incompr\u00e9hension\n             unknownStory {\n                 end(\"Je n'ai pas compris. Mais j'apprends tous les jours :)\")\n             }\n        )\n    )\n}\n</code></pre> <p>Le code source complet de l'exemple est disponible.</p>"},{"location":"fr/dev/bot-api/#developper-en-javascript","title":"D\u00e9velopper en Javascript","text":"<p>Un client est fourni pour d\u00e9velopper des parcours en Javascript avec Nodejs. Pour en savoir plus, voir la documentation sur le d\u00e9p\u00f4t <code>tock-node</code>.</p>"},{"location":"fr/dev/bot-api/#developper-en-python","title":"D\u00e9velopper en Python","text":"<p>Un client est fourni pour d\u00e9velopper des parcours en Python. Pour en savoir plus, voir la documentation sur le d\u00e9p\u00f4t <code>tock-py</code>.</p>"},{"location":"fr/dev/bot-api/#developper-via-lapi","title":"D\u00e9velopper via l'API","text":"<p>Il est possible de d\u00e9velopper des parcours Tock dans n'importe quel langage, en s'interfa\u00e7ant directement avec  l'API.</p>"},{"location":"fr/dev/bot-api/#installer-bot-api-cote-serveur","title":"Installer Bot API c\u00f4t\u00e9 serveur","text":"<p>Pour utiliser le mode Bot API de Tock, un module sp\u00e9cifique doit \u00eatre d\u00e9ploy\u00e9 avec la plateforme. G\u00e9n\u00e9ralement appel\u00e9  <code>bot-api</code> dans les descripteurs Docker Compose par exemple, ce service a pour r\u00f4le :</p> <ul> <li>D'exposer la Bot API aux clients potentiels quelque soit leur langage de programmation</li> <li>D'accepter des connexions en WebSocket et/ou de se connecter au webhook configur\u00e9</li> </ul> <p>Le guide D\u00e9ployer Tock avec Docker ou encore le chapitre  Installation montrent comment d\u00e9ployer ce module si n\u00e9cessaire.</p> <p>La seule modification n\u00e9cessaire par rapport au code d'exemple pour la platforme de d\u00e9monstration est de remplacer la m\u00e9thode <code>startWithDemo</code> par <code>start</code> en pr\u00e9cisant si besoin l'adresse de du serveur <code>bot-api</code>.</p>"},{"location":"fr/dev/connectors/","title":"Les connecteurs Tock","text":"<p>La page Bot multicanal de la documentation utilisateur pr\u00e9sente la notion de connecteur Tock, ainsi que la liste des connecteurs d\u00e9j\u00e0 disponibles.</p> <p>Cette page n'ajoute donc que des \u00e9l\u00e9ments propres au d\u00e9veloppement avec les connecteurs Tock ou le d\u00e9veloppement de  nouveaux connecteurs.</p>"},{"location":"fr/dev/connectors/#connecteurs-fournis-avec-tock","title":"Connecteurs fournis avec Tock","text":"<p>Pour en savoir plus sur les connecteurs fournis avec la distribution Tock,  vous pouvez aussi vous rendre dans le dossier de chaque connecteur. La page Bot multicanal liste tous les connecteurs disponibles.</p> <p>Par exemple, le dossier  connector-messenger  contient les sources et le README du connecteur Tock pour Messenger.</p>"},{"location":"fr/dev/connectors/#kits-bases-sur-le-connecteur-web","title":"Kits bas\u00e9s sur le connecteur Web","text":"<p>Les composants utilisant le connecteur Web pour int\u00e9grer des bots Tock \u00e0 d'autres canaux  sont fournis sur leur propre d\u00e9p\u00f4t GitHub \u00e0 c\u00f4t\u00e9 du d\u00e9p\u00f4t principal Tock. La page Bot multicanal liste tous les kits disponibles.</p> <p>Par exemple, le d\u00e9p\u00f4t  <code>tock-react-kit</code>  contient les sources et le README du kit pour React.</p>"},{"location":"fr/dev/connectors/#developper-son-propre-connecteur","title":"D\u00e9velopper son propre connecteur","text":"<p>Il est possible de cr\u00e9er son propre connecteur Tock, par exemple pour interfacer un bot Tock avec un canal propre \u00e0  l'organisation (souvent un site Web ou une application mobile sp\u00e9cifiques), ou bien quand un canal grand public  s'ouvre aux bots conversationnels et que le connecteur Tock n'existe pas encore.</p> <p>Un exemple de connecteur sp\u00e9cifique est disponible dans le projet d'exemple Bot Open Data. </p> <p>Pour d\u00e9finir son propre connecteur, quatres \u00e9tapes sont n\u00e9cessaires :</p> <p>1) Impl\u00e9menter l'interface <code>Connector</code> </p> <p>Voici un exemple d'impl\u00e9mentation :</p> <pre><code>val testConnectorType = ConnectorType(\"test\")\n\nclass TestConnector(val applicationId: String, val path: String) : Connector {\n\n    override val connectorType: ConnectorType = testConnectorType\n\n    override fun register(controller: ConnectorController) {\n        controller.registerServices(path) { router -&gt;\n            //main API\n            router.post(\"$path/message\").blockingHandler { context -&gt;\n                //ConnectorRequest est mon objet m\u00e9tier pass\u00e9 par l'appli front\n                val message: ConnectorRequest = mapper.readValue(context.bodyAsString)\n\n                //transformation de l'objet m\u00e9tier en Event tock\n                val event = readUserMessage(message)\n                // on passe l'\u00e9v\u00e8nement au framework\n                val callback = TestConnectorCallback(applicationId, message.userId, context, controller)\n                controller.handle(event, ConnectorData(callback))\n            }\n\n        }\n\n    }\n\n    override fun send(event: Event, callback: ConnectorCallback, delayInMs: Long) {\n        callback as TestConnectorCallback\n        if (event is Action) {\n            //on enregistre l'action\n            callback.actions.add(event)\n            //si c'est la derni\u00e8re action \u00e0 envoyer, on envoie la r\u00e9ponse\n            if (event.metadata.lastAnswer) {\n                callback.sendAnswer()\n            }\n        } else {\n            logger.trace { \"unsupported event: $event\" }\n        }\n    }    \n}\n\n// pour r\u00e9cup\u00e9rer toutes les actions avant envoi\nclass TestConnectorCallback(\n        override val applicationId: String,\n        val userId: String,\n        val context: RoutingContext,\n        val controller: ConnectorController,\n        val actions: MutableList&lt;Action&gt; = CopyOnWriteArrayList()): ConnectorCallbackBase(applicationId, testConnectorType) {\n\n    internal fun sendAnswer() {\n            //on transforme la liste des r\u00e9ponses Tock en r\u00e9ponse m\u00e9tier\n            val response = mapper.writeValueAsString(actions.map{...})\n            //puis on envoie la r\u00e9ponse\n            context.response().end(response)\n    }\n\n}         \n</code></pre> <p>2) Impl\u00e9menter l'interface <code>ConnectorProvider</code></p> <p>Voici un exemple d'impl\u00e9mentation :</p> <pre><code>object TestConnectorProvider : ConnectorProvider {\n\n    override val connectorType: ConnectorType = testConnectorType\n\n    override fun connector(connectorConfiguration: ConnectorConfiguration): Connector {\n        return TestConnector(\n                connectorConfiguration.connectorId,\n                connectorConfiguration.path\n        )\n    }\n}\n\nclass TestConnectorProviderService: ConnectorProvider by TestConnectorProvider\n</code></pre> <p>3) Rendre disponible ce connecteur via un Service Loader :</p> <p>Pour cela, placez un fichier <code>META-INF/services/ai.tock.bot.connector.ConnectorProvider</code> dans le classpath,  contenant le nom de la classe :</p> <p><code>mypackage.TestConnectorProviderService</code></p> <p>4) Rajouter toutes les classes et fichiers cr\u00e9\u00e9s dans le classpath de l'admin et du bot.</p> <p>Le nouveau connecteur doit alors \u00eatre disponible dans l'interface Bot Configurations de Tock Studio.</p>"},{"location":"fr/dev/examples-code/","title":"Exemples de code Tock","text":""},{"location":"fr/dev/examples-code/#les-exemples-dans-bot-samples","title":"Les exemples dans Bot Samples","text":"<p>Le d\u00e9p\u00f4t tock-bot-samples contient des exemples de code, notamment ceux utilis\u00e9s dans  la documentation Tock pour programmer des parcours en modes WebHook ou WebSocket.</p>"},{"location":"fr/dev/examples-code/#le-bot-open-data","title":"Le bot Open Data","text":"<p>Le d\u00e9p\u00f4t tock-bot-open-data contient un  exemple d'impl\u00e9mentation de bot bas\u00e9 sur les API Open Data de la SNCF.</p> <p>Ce bot utilise le framework Kotlin pour Tock (et pas le mode Bot API via Webhook ou WebSocket).  Il impl\u00e9mente \u00e9galement une internationalisation avec deux langues propos\u00e9es : Fran\u00e7ais et Anglais.</p>"},{"location":"fr/dev/examples-code/#deployer-le-bot-avec-docker","title":"D\u00e9ployer le bot avec Docker","text":"<p>Pour d\u00e9ployer le bot avec Docker / Docker Compose,  suivez les instructions du d\u00e9p\u00f4t tock-docker.</p>"},{"location":"fr/dev/examples-code/#deployer-le-bot-dans-son-ide","title":"D\u00e9ployer le bot dans son IDE","text":"<p>Si vous pr\u00e9f\u00e9rez d\u00e9ployer une plateforme Tock sans le Bot Open Data, et ex\u00e9cuter celui-ci dans votre IDE (vous  permettant par exemple de faire du debug pas-\u00e0-pas), suivez ces instructions : </p> <ul> <li> <p>D\u00e9ployez une stack Tock NLU gr\u00e2ce au descripteur <code>docker-compose.yml</code> comme expliqu\u00e9 ici</p> </li> <li> <p>Demandez votre propre clef SNCF Open Data (gratuite) et configurez la variable d'environnement (voir OpenDataConfiguration)</p> </li> <li> <p>Configurez un connecteur : Messenger, Google Assistant ou autre (voir canaux et connecteurs)</p> </li> <li> <p>D\u00e9marrez le lanceur <code>OpenDataBot</code> dans votre IDE, IntelliJ ou autre. Le bot est op\u00e9rationnel, parlez-lui ! :)</p> </li> </ul>"},{"location":"fr/dev/i18n/","title":"D\u00e9velopper un bot multilingue (i18n)","text":"<p>La page Bot multilingue de la documentation utilisateur pr\u00e9sente les bases de l'internationalisation (i18n) pour construire des bots avec Tock : pr\u00e9-requis, Locale, etc.</p> <p>Cette page vient compl\u00e9ter cette documentation avec des \u00e9l\u00e9ments propres au d\u00e9veloppement. </p>"},{"location":"fr/dev/i18n/#pre-requis","title":"Pr\u00e9-requis","text":"<p>Pour activer l'internationalisation dans Tock, programmatiquement ou pas, voir Bot multilingue.</p>"},{"location":"fr/dev/i18n/#principes","title":"Principes","text":"<p>Le code ne change pas une fois l'internationalisation activ\u00e9e. Par exemple : </p> <pre><code>     send(\"Arrival at {0}\", time)\n</code></pre> <p>est un code valide que le module soit activ\u00e9 ou non. </p> <p>Par contre, \u00e0 l'ex\u00e9cution, le comportement diff\u00e8re significativement.</p> <p>Si l'internationalisation est activ\u00e9e, les op\u00e9rations suivantes vont \u00eatre effectu\u00e9es :</p> <ol> <li> <p>Une cl\u00e9 va \u00eatre g\u00e9n\u00e9r\u00e9e \u00e0 partir du texte pass\u00e9 en param\u00e8tre, en fonction du namespace (l'organisation du cr\u00e9ateur du bot)  et de la story dans laquelle est demand\u00e9 ce libell\u00e9. Dans le cas ci-dessus, cela devrait ressembler \u00e0 <code>app_arrivals_Arrival at {0}</code> o\u00f9 app est le namespace et  arrivals l'intention principale de la story.</p> </li> <li> <p>Tock v\u00e9rifie ensuite si cette cl\u00e9 est d\u00e9j\u00e0 pr\u00e9sente en base. </p> <ul> <li>Si c'est le cas, il utilise le libell\u00e9 pr\u00e9sent en base pour la langue demand\u00e9e afin de trouver la traduction la plus appropri\u00e9e (le connecteur ou le type d'interface peuvent \u00e9galement \u00eatre pris en compte)</li> <li>Sinon, une cl\u00e9 est cr\u00e9\u00e9e en base avec le libell\u00e9 par d\u00e9faut (\"Arrival at {0}\" dans notre exemple) utilis\u00e9e pour la langue courante</li> <li>Si le texte pass\u00e9 en param\u00e8tre est un objet <code>I18nLabelValue</code> dont le champ <code>defaultI18n</code> contient une valeur pour la langue courante, celle-ci sera utilis\u00e9e</li> </ul> </li> <li> <p>Il est ensuite possible de consulter et de modifier ce libell\u00e9 dans l'interface d'administration :   </p> </li> </ol> <p></p>"},{"location":"fr/dev/i18n/#format-des-messages","title":"Format des messages","text":"<p>Le format support\u00e9 est celui du support i18n de java, en particulier celui de la classe MessageFormat en java. Cela inclut le support de ChoiceFormat :</p> <pre><code>    send(\"There {0,choice,0#are no files|1#is one file|1&lt;are {0,number,integer} files}.\", 2)  \n</code></pre> <p>Par ailleurs, Tock met \u00e0 disposition une extension by pour les dates qui permet d'indiquer un format dans les param\u00e8tres :</p> <pre><code>    send(\"Departure at {0}\", departureDateTime by timeFormat) \n</code></pre>"},{"location":"fr/dev/i18n/#locale-utilisateur","title":"Locale utilisateur","text":"<p>Voir Bot multilingue.</p>"},{"location":"fr/dev/i18n/#points-dattention","title":"Points d'attention","text":"<p>Le module d'internationalisation de Tock est efficace, mais certaines pratiques, pourtant intuitives en Kotlin,  sont \u00e0 bannir sous peine de mauvaises surprises.</p> <p>Par exemple, ce code fonctionne parfaitement bien avec le module i18n d\u00e9sactiv\u00e9.</p> <pre><code>    send(\"There are $nb files\") //DANGER!! \n</code></pre> <p>mais pose probl\u00e8me si il est activ\u00e9. En effet, un nouveau libell\u00e9 sera cr\u00e9\u00e9 pour chaque valeur diff\u00e9rente de la variable nb !</p> <p>S'il est n\u00e9cessaire d'envoyer des r\u00e9ponses \"\u00e0 ne pas traduire\", utilisez  les m\u00e9thodes BotBus.sendRaw, BotBus.endRaw ou String.raw</p> <pre><code>    send(\"There are $nb files\".raw) //CORRECT \n</code></pre> <pre><code>    send(\"There are {0} files\", nb) //FORMAT A SUIVRE \n</code></pre> <ul> <li>Le risque de collision entre deux libell\u00e9s est faible puisque l'intention principale de la story fait partie de la cl\u00e9.  Si vous souhaitez cependant \u00e9viter tout risque, vous pouvez utiliser la m\u00e9thode i18nKey :</li> </ul> <pre><code>    send(i18nKey(\"my_unique_key\", \"There are {0} files\", nb)) \n</code></pre>"},{"location":"fr/dev/i18n/#specification-des-localisations-programmatiquement","title":"Sp\u00e9cification des localisations programmatiquement","text":"<p>Il est possible de d\u00e9finir des valeurs par d\u00e9faut pour plusieurs localisations dans le code d'un bot :</p> <pre><code>    send(i18nKey(\"departure\", \"Departure at {0}\", setOf(I18nLocalizedLabel(Locale.FRENCH, textChat, \"D\u00e9part \u00e0 {0}\")), nb))\n</code></pre> <p>Par d\u00e9faut, ces valeurs par d\u00e9faut ne seront utilis\u00e9es que lorsque la cl\u00e9 est utilis\u00e9e pour la premi\u00e8re fois. Pour \u00e9craser les valeurs existantes (y compris celles d\u00e9finies via TOCK Studio) lorsque le param\u00e8tre <code>defaultI18n</code> est chang\u00e9, mettez la valeur de configuration <code>tock_i18n_reset_value_on_default_change</code> \u00e0 <code>true</code> (soit en variable d'environnement, soit en propri\u00e9t\u00e9 syst\u00e8me).</p>"},{"location":"fr/dev/i18n/#tester-linternationalisation","title":"Tester l'internationalisation","text":"<p>Un exemple de dispositif de test est disponible dans le code source du bot d'exemple Il est n\u00e9cessaire d'\u00e9tendre l'extension de test pour ensuite indiquer la correspondance des libell\u00e9s \u00e0 tester.</p> <p>Il ne reste plus qu'\u00e0 indiquer la locale souhait\u00e9e : </p> <pre><code>    @Test\n    fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context`() {\n        ext.newRequest(\"Recherche\", search, locale = Locale.FRENCH) {\n            destination = lille\n            origin = paris\n\n            run()\n\n            firstAnswer.assertText(\"Quand souhaitez-vous partir?\")\n        }\n    }\n</code></pre>"},{"location":"fr/dev/modes/","title":"D\u00e9velopper des bots avec Tock","text":"<p>Tock Studio permet de construire des parcours conversationnels (ou stories) incluant du texte, des boutons, images,  caroussels, etc. Pour aller plus loin il est possible de programmer des parcours des parcours  en Kotlin, Javascript, Python  ou d'autres langages.</p> <p> </p> <p>Deux modes / frameworks / architectures sont propos\u00e9s :</p>"},{"location":"fr/dev/modes/#le-mode-bot-api","title":"Le mode Bot API","text":"<p>Le mode Tock Bot API (recommand\u00e9 pour la plupart des cas) permet de d\u00e9velopper en Kotlin  ou d'autres langages avec les clients fournis pour Javascript/Nodejs et  Python ou n'importe quel langage gr\u00e2ce \u00e0 l'API de Tock :</p> <p></p> <p>Ce mode est le seul disponible sur la plateforme de d\u00e9monstration Tock.  C'est aussi le seul mode permettant de d\u00e9velopper dans n'importe quel langage de programmation, via l'API.</p> <p>Pour en savoir plus, voir la page Bot API.</p>"},{"location":"fr/dev/modes/#le-mode-bot-integre","title":"Le mode Bot int\u00e9gr\u00e9","text":"<p>Dans ce mode, vous pouvez acc\u00e9der \u00e0 toutes les fonctionnalit\u00e9s et possibilit\u00e9s du framework Tock pour d\u00e9velopper un bot. </p> <p>C'est le mode de d\u00e9veloppement historique de Tock, et actuellement la plupart des bots publi\u00e9s par les concepteurs de Tock. sont d\u00e9velopp\u00e9s de cette mani\u00e8re. </p> <p>La mise en place de la solution est plus complexe que le mode Bot API et n\u00e9cessite notamment que le composant bot  acc\u00e8de directement \u00e0 la base de donn\u00e9es MongoDB. Il est donc n\u00e9cessaire pour utiliser ce mode :</p> <ul> <li>D'installer une plateforme (g\u00e9n\u00e9ralement avec Docker) sur son poste ou sur un serveur</li> <li>De partager la connexion \u00e0 la base MongoDB entre les poste de d\u00e9veloppement et les autres composants  de la plateforme Tock utilis\u00e9e</li> <li>De ma\u00eetriser le langage de programmation Kotlin</li> </ul> <p></p> <p>Pour en savoir plus, voir la page Bot int\u00e9gr\u00e9.</p>"},{"location":"fr/dev/test/","title":"Utiliser le framework de test","text":"<p>Tock met \u00e0 disposition des extensions pour tester le bot unitairement.</p> <p>Pour les utiliser, il est n\u00e9cessaire d'ajouter la librairie bot-test \u00e0 votre projet.</p> <p>Avec Maven :</p> <pre><code>        &lt;dependency&gt;\n            &lt;groupId&gt;ai.tock&lt;/groupId&gt;\n            &lt;artifactId&gt;bot-test&lt;/artifactId&gt;\n            &lt;version&gt;24.9.4&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre> <p>ou Gradle :</p> <pre><code>      testCompile 'ai.tock:bot-test:24.9.4'\n</code></pre> <p>L'ensemble de ce framework est document\u00e9 au format KDoc ici.</p>"},{"location":"fr/dev/test/#ecrire-un-test-simple","title":"Ecrire un test simple","text":"<p>L'ensemble des exemples suivants utilisent JUnit5.  Une extension d\u00e9di\u00e9e \u00e0 Tock et JUnit5 est disponible.</p> <pre><code>    @RegisterExtension\n    @JvmField\n    val ext = TockJUnit5Extension(bot)\n</code></pre> <p>Afin de tester la story greetings du bot Open Data, il suffit d'utiliser la m\u00e9thode ext.send()  qui permet d'obtenir un mock du bus conversationnel. Le test unitaire s'\u00e9crit alors ainsi :   </p> <pre><code>    @Test\n    fun `greetings story displays welcome message WHEN locale is fr`() {\n        ext.send(locale = Locale.FRENCH) {\n            firstAnswer.assertText(\"Bienvenue chez le Bot Open Data Sncf! :)\")\n            secondAnswer.assertText(\"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\")\n        }\n    }\n</code></pre> <p>Comme le connector par d\u00e9faut est celui de Messenger, il est possible de tester de la m\u00eame mani\u00e8re le message sp\u00e9cifique \u00e0 Messenger : </p> <pre><code>    lastAnswer.assertMessage(\n                buttonsTemplate(\n                    \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :)\",\n                    postbackButton(\"Itin\u00e9raires\", search),\n                    postbackButton(\"D\u00e9parts\", Departures),\n                    postbackButton(\"Arriv\u00e9es\", Arrivals)\n                )\n            )\n</code></pre> <p>Pour tester le message sp\u00e9cifique \u00e0 Google Assistant (ou tout autre connecteur),  il est n\u00e9cessaire de sp\u00e9cifier le connecteur que l'on souhaite tester :</p> <pre><code>    ext.send(connectorType = gaConnectorType, locale = Locale.FRENCH) {\n            firstAnswer.assertText(\"Bienvenue chez le Bot Open Data Sncf! :)\")\n            secondAnswer.assertText(\"Il s'agit d'un bot de d\u00e9monstration du framework Tock : https://github.com/theopenconversationkit/tock\")\n            lastAnswer.assertMessage(\n                gaMessage(\n                    \"Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d'une gare et constatez le r\u00e9sultat! :)\",\n                    \"Itin\u00e9raires\",\n                    \"D\u00e9parts\",\n                    \"Arriv\u00e9es\"\n                )\n            )\n        }\n</code></pre>"},{"location":"fr/dev/test/#tester-une-story-specifique","title":"Tester une Story sp\u00e9cifique","text":"<p>Dans les exemples pr\u00e9c\u00e9dents, il n'\u00e9tait pas n\u00e9cessaire d'indiquer la story \u00e0 tester (greetings \u00e9tant la story par d\u00e9faut). Supposons que nous souhaitons la story search, nous devons pr\u00e9ciser la story \u00e0 tester de la mani\u00e8re suivante  : </p> <pre><code>    @Test\n    fun `search story asks for destination WHEN there is no destination in context`() {\n        ext.send(intent = search, locale = Locale.FRENCH) {\n            firstAnswer.assertText(\"Pour quelle destination?\")\n        }\n    }\n</code></pre>"},{"location":"fr/dev/test/#tester-un-dialogue","title":"Tester un dialogue","text":"<p>Il est possible de simuler un dialogue complet. Par exemple, on simule ici que l'utilisateur indique la destination, puis l'origine :</p> <pre><code>    @Test\n    fun `search story asks for origin WHEN there is a destination but no origin in context`() {\n        ext.send(\"Je voudrais rechercher un itin\u00e9raire\", search, locale = Locale.FRENCH) {\n            firstAnswer.assertText(\"Pour quelle destination?\")\n        }\n        ext.send(\"Lille\", indicate_location, locationEntity setTo lille) {\n            firstBusAnswer.assertText(\"Pour quelle origine?\")\n        }\n        ext.send(\"Paris\", indicate_location, locationEntity setTo paris) {\n            firstBusAnswer.assertText(\"Quand souhaitez-vous partir?\")\n        }\n    }\n</code></pre> <p>Le texte en premier param\u00e8tre de la m\u00e9thode send est simplement indicatif, pour aider \u00e0 la compr\u00e9hension des tests. Les param\u00e8tres suivants permettent de d\u00e9finir comment le NLP va analyser la phrase. Par exemple : </p> <pre><code>    private val lille = PlaceValue(\n        SncfPlace(\n            \"stop_area\",\n            90,\n            \"Lille Europe\",\n            \"Lille Europe (Lille)\",\n            \"stop_area:OCE:SA:87223263\",\n            Coordinates(50.638861, 3.075774)\n        )\n    )\n\n    ext.send(\"Lille\", indicate_location, locationEntity setTo lille)\n</code></pre> <p>permet d'indiquer que la phrase \"Lille\" est cat\u00e9goris\u00e9e comme une intention indicate_location et avec une valeur  pour l'entit\u00e9 location qui va \u00eatre la localisation lille</p> <p>Enfin il est possible de modifier toutes les valeurs du bus mock\u00e9 \u00e0 l'initialisation. Dans l'exemple suivant, on simule l'intention secondaire indicate_location afin d'indiquer l'origine : </p> <pre><code>    @Test\n    fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context`() {\n        ext.newRequest(\"Recherche\", search, locale = Locale.FRENCH) {\n            destination = lille\n            origin = paris\n\n            run()\n\n            firstAnswer.assertText(\"Quand souhaitez-vous partir?\")\n        }\n    }\n</code></pre> <p>Les variables origin et destination sont mises \u00e0 jour, puis un appel au bus est simul\u00e9 avec la fonction run(). </p>"},{"location":"fr/dev/advanced/bot-api/","title":"BotApi","text":"<p>Le client <code>botApiClient</code>envoie au bot des <code>RequestData</code> et re\u00e7oit des <code>ResponseData</code>. La d\u00e9finition du bot est d\u00e9finit par sa <code>BotConfiguration</code> qui construit des Story via sa <code>ClientConfiguration</code></p>"},{"location":"fr/dev/advanced/bot-api/#les-echanges-avec-le-botapi","title":"Les \u00e9changes avec le botApi","text":""},{"location":"fr/dev/advanced/bot-api/#botapidefinition","title":"BotApiDefinition","text":"<p>H\u00e9rite d'un <code>BotDefinitionBase</code> et impl\u00e9mente un <code>BotDefinition</code> D\u00e9finit le bot dans le mode Api.</p> <ul> <li>Soit : <pre><code>classDiagram\nBotDefinitionBase &lt;|.. BotDefinition\nBotApiDefinition &lt;|-- BotDefinitionBase\nBotDefinition : &lt;&lt;interface&gt;&gt;\nBotApiDefinition : findIntent(String,String)</code></pre></li> </ul>"},{"location":"fr/dev/advanced/bot-api/#botconfiguration","title":"BotConfiguration","text":"<p>Contient les informations pr\u00e9sentes sur la configuration du bot (exemple son apikey, so nom, le mod\u00e8le de nlp, les localisations support\u00e9s, l'url du webhook)</p>"},{"location":"fr/dev/advanced/bot-api/#une-nouvelle-story-definition-et-son-handler","title":"Une nouvelle story definition et son handler","text":"<pre><code>classDiagram\nStoryDefinition &lt;|.. StoryDefinitionBase\nStoryDefinitionBase ..&gt; SimpleStoryHandlerBase\nSimpleStoryHandlerBase ..|&gt; StoryDefinition\nSimpleStoryDefinition ..&gt; StoryHandlerDefinition\nStoryHandlerDefinition &lt;|.. StoryHandlerDefinitionBase~T~\nSimpleStoryHandlerBase ..&gt; SimpleStoryHandlerDefinition : create\nSimpleStoryHandlerDefinition ..|&gt; StoryHandlerDefinition\nFallbackStoryDefinition --|&gt; SimpleStoryDefinition\nFallbackStoryDefinition ..&gt; FallbackStoryHandler : create\nFallbackStoryHandler --|&gt; SimpleStoryHandlerBase\nSimpleStoryHandlerBase ..&gt; StoryDefinition\nStoryHandlerBase~T~ &lt;|-- SimpleStoryHandlerBase\nStoryDefinition ..&gt; StoryHandler\nFallbackStoryDefinition ..&gt; StoryHandler\nStoryHandler &lt;|.. StoryHandlerBase~T~\nStoryDefinition : &lt;&lt;interface&gt;&gt;\nStoryHandler : &lt;&lt;interface&gt;&gt;</code></pre>"},{"location":"fr/dev/advanced/collections/","title":"Les collections Tock","text":""},{"location":"fr/dev/advanced/collections/#tock_bot-et-tock_bot_test","title":"tock_bot et tock_bot_test","text":"collection description classe action_nlp_stats ? statistiques d'actions pr\u00e9enregistr\u00e9es ? NlpStatsCol archived_entity_values ? valeur d'entit\u00e9s conserv\u00e9es ? ArchivedEntityValuesCol bot Identit\u00e9 des bots BotConfiguration bot_configuration Configuration des bots avec par exemple les configurations des connecteurs, les urls associ\u00e9es etc. BotApplicationConfiguration connector_message Stocke par exemple les quickreplies/categories \u00e9chang\u00e9s depuis le connecteur ConnectorMessageCol dialog Contient les informations g\u00e9n\u00e9rales de thread de dialogue avec le bot : les emetteurs/recepteurs, l'\u00e9tat de la conversation dans le thread, les stories d\u00e9clench\u00e9es et leurs contenus avec les actions du bot et les actions utilisateurs. DialogCol dialog_snapshot Contient un snapshot des threads avec l'identifiant des stories et entities sauvegard\u00e9es et d\u00e9clench\u00e9s SnapshotCol dialog_text Contient les \u00e9changes textuels envoy\u00e9s par les utilisateurs DialogTextCol feature Contient les configurations pour par exemple d\u00e9sactiver/activer un bot ou les features dans <code>Stories &amp; Answers/Rules/Application Features</code> Feature flow_state Concerne les informations d'analytics : d\u00e9finit les diff\u00e9rents \u00e9tats atteignable, le storyType (ex: builtin) DialogFlowStateCol flow_transition Concerne les informations d'analytics : D\u00e9finit les transitions entres les intentions DialogFlowStateTransitionCol flow_transition_stats Concerne les informations d'analytics : Liste les utterances pour pouvoir \u00eatre comptabilis\u00e9es DialogFlowStateTransitionStatCol i18n_alternative_index D\u00e9finit les alternatives dans les diff\u00e9rentes langues pour un label i18n ? I18nAlternativeIndex i18n_label Definit les labels i18n pour les r\u00e9ponses du bot I18nLabel i18n_label_stat Statistiques d'utilisation des labels I18nLabelStat story_configuration Configuration des stories, le nom de l'intention, la classe type de handler, la d\u00e9finition des steps, les children StoryDefinitionConfiguration story_configuration_history Historique de configuration des stories ? StoryDefinitionConfigurationHistoryCol test_plan Plan de test, d\u00e9finit via une copie d'un Dialog et dispose du type du connecteur cible TestPlan test_plan_execution Statistiques de test plan ex\u00e9cut\u00e9s : indique le nombre d'erreur, le temps d'ex\u00e9cution, le status (exemple COMPLETE) TestPlanExecution user_lock ? Gestion de l'\u00e9tat du lock utilisateur UserLock user_timeline Informations utilisateur par rapport \u00e0 <code>Analytics/users</code> UserTimelineCol"},{"location":"fr/dev/advanced/collections/#tock_front","title":"tock_front","text":"<p>Li\u00e9e aux informations modifiables dans le front</p> collection description classe DTO application_definition Configuration de l'application : le nom, les langues, le type de nlp ApplicationDefinition classified_sentence Informations d'une Sentence d\u00e9clar\u00e9e dans Tock et la classification NLP, son \u00e9tat (\u00e0 review, unknown) ClassifiedSentenceCol dictionary_data Dictionnaire de donn\u00e9es li\u00e9es aux entit\u00e9s custom d\u00e9finies, peut contenir des valeurs pr\u00e9-d\u00e9finies  exemple : d'export <code>{\"namespace\":\"app\",\"entityName\":\"test\",\"values\":[{\"value\":\"donn\u00e9esA\",\"labels\":{\"fr\":[\"label1\",\"label2\"]}}],\"onlyValues\":false,\"minDistance\":0.5,\"textSearch\":false}</code>  Configurable dans <code>Language Understanding/Entities</code> DictionaryData entity_test_error ? Li\u00e9 aux tests sur entit\u00e9s EntityTestError entity_type_definition Configuration des classes d'entit\u00e9s exemple : duckling EntityTypeDefinition intent_definition D\u00e9finition des intentions avec les informations tels que les entit\u00e9s, les sharedIntents, \u00e0 quelle application elles sont li\u00e9es IntentDefinition intent_test_error ? Li\u00e9 aux tests sur les intentions IntentTestError model_build ? Li\u00e9 \u00e0 <code>Trigger Build</code> options avanc\u00e9es dans `Settings//Edit/Advanced Options ModelBuild model_build_trigger ? Li\u00e9 \u00e0 <code>Trigger Build</code> options avanc\u00e9es dans `Settings//Edit/Advanced Options ModelBuildTrigger parse_request_log Log de parsing de requ\u00eate avec les informations sp\u00e9cifiques de classification NLP ParseRequestLog parse_request_log_intent_stats Log de parsing de requ\u00eate avec les informations sp\u00e9cifiques de classification NLP entre plusieurs intentions ParseRequestLogIntentStat parse_request_log_stats Stats de requ\u00eates par rapport au texte exprimant le nombre de fois qu'il a \u00e9t\u00e9 appel\u00e9, l'intentProbability et l'entitiesProbability ParseRequestLogStat test_build ? build pour le botApi ? TestBuild user_action_log Logs d'actions utilisateur dans l'interface (exemple : m\u00e0j d'une configuration, cr\u00e9ation/m\u00e0j d'une intent) UserActionLog user_namespace D\u00e9finition des diff\u00e9rents utilisateurs de l'interface UserNamespace"},{"location":"fr/dev/advanced/collections/#tock_model","title":"tock_model","text":"<p>Probablement pour le t\u00e9l\u00e9chargement et l'export de donn\u00e9es depuis Tock.</p> collection description classe fs_entity.chunks Morceaux de donn\u00e9es des entit\u00e9s d\u00e9finit dans NlpEngineModelMongoDAO fs_entity.files Diff\u00e9rents fichiers selon les bots pour les entit\u00e9s d\u00e9finit dans NlpEngineModelMongoDAO fs_intent.chunks Morceaux de donn\u00e9es des intentions d\u00e9finit dans NlpEngineModelMongoDAO fs_intent.files Diff\u00e9rents fichiers selon les bots pour les intentions d\u00e9finit dans NlpEngineModelMongoDAO nlp_application_configuration Contient la configuration pr\u00e9sente dans les options avanc\u00e9es dans <code>Settings/&lt;Application&gt;/Edit/Advanced Options</code> NlpApplicationConfigurationCol"},{"location":"fr/user/concepts/","title":"Concepts conversationnels pour Tock","text":"<p>Cette page pr\u00e9sente et vulgarise les principaux concepts et la terminologie conversationnelle utilis\u00e9e  dans Tock et sa documentation.</p> <p>Un tableau propose \u00e9galement des \u00e9quivalences et termes similaires dans d'autres solutions conversationnelles.</p>"},{"location":"fr/user/concepts/#notions-de-base","title":"Notions de base","text":""},{"location":"fr/user/concepts/#application","title":"Application","text":"<p>En mode pur NLP (reconnaissance du langage), une application correspond \u00e0 un corpus de phrases qualifi\u00e9es dont Tock va  tirer un ensemble de mod\u00e8les statistiques (lui permettant d'analyser et d'interpr\u00eater les phrases utilisateurs).</p> <p>En mode conversationnel, l'application inclue \u00e9galement diff\u00e9rents param\u00e8tres d\u00e9finissant les r\u00e9ponses et le  comportement du bot. Autrement dit, une application correspond g\u00e9n\u00e9ralement \u00e0 un bot.</p> <p>Voir Tock Studio &gt; Settings &gt; Applications.</p>"},{"location":"fr/user/concepts/#configuration","title":"Configuration","text":"<p>Dans une application Tock en mode NLP, une configuration regroupe un ou plusieurs connecteurs pour diff\u00e9rents  canaux (voir ci-dessous).</p> <p>En mode conversationnel, une configuration correspond \u00e0 un ensemble de r\u00e9ponses et comportements du bot  sur ces canaux. Par exemple, pour un m\u00eame sc\u00e9nario (story) de l'application il est possible de param\u00e9trer des r\u00e9ponses  diff\u00e9rentes (answers, story rules, etc.) selon plusieurs configurations.</p> <p>Voir Tock Studio &gt; Settings &gt; Configurations.</p>"},{"location":"fr/user/concepts/#connecteur","title":"Connecteur","text":"<p>Un connecteur permet \u00e0 Tock de \"connecter\" un bot \u00e0 un canal externe comme Messenger, Alexa, un site Web, etc. Sa configuration d\u00e9taill\u00e9e d\u00e9pend du canal concern\u00e9.</p> <p>Tock permet de mutualiser tr\u00e8s facilement le code d'un bot pour qu'il r\u00e9ponde sur plusieurs canaux gr\u00e2ce \u00e0 ses  connecteurs. Il est toutefois possible d'ajuster finement r\u00e9ponses et comportements en fonction du connecteur, si besoin. </p> <p>Voir Tock Studio &gt; Settings &gt; Configurations et la page Bot Multicanal pour en savoir plus sur les connecteurs disponibles.</p>"},{"location":"fr/user/concepts/#namespace","title":"Namespace","text":"<p>Le namespace permet d'identifier le groupe organisationnel d'un objet.</p> <p>Le namespace appara\u00eet en g\u00e9n\u00e9ral comme un pr\u00e9fixe suivi de <code>:</code> dans une cha\u00eene de caract\u00e8res. Par exemple, une entit\u00e9 typ\u00e9e <code>duckling:datetime</code> est de type <code>datetime</code> dans le namespace <code>duckling</code> (elle vient du module Duckling).</p> <p>Si vous utilisez la plateforme de d\u00e9monstration, votre namespace est votre identifiant GitHub.</p> <p>Si la plupart des objets et param\u00e8tres d\u00e9pendent d'une application appartenant elle-m\u00eame \u00e0 un namespace, certains objets comme les r\u00e9ponses (answers) sont directement rattach\u00e9s au namespace : ils sont donc partag\u00e9s entre les applications de ce namespace.</p> <p>Voir Tock Studio &gt; Settings &gt; Namespaces.</p>"},{"location":"fr/user/concepts/#intentions","title":"Intentions","text":"<p>Pour pouvoir d\u00e9finir des actions suite \u00e0 une demande utilisateur,  il est n\u00e9cessaire au pr\u00e9alable de classifier ou cat\u00e9goriser cette demande. </p> <p>Ce qu'on appelle une intention est justement cette classification.</p> <p>Par exemple, les phrases \"Quel temps fait-il?\", \"Il fait beau demain ?\", \"J'esp\u00e8re qu'il ne va pas pleuvoir \u00e0 Paris ?\" peuvent toutes \u00eatre cat\u00e9goris\u00e9es avec l'intention \"m\u00e9t\u00e9o\".</p> <p>A partir des phrases classifi\u00e9es manuellement par un utilisateur,  Tock va automatiquement construire un mod\u00e8le statistique qui va lui permettre, pour une nouvelle phrase, de d\u00e9terminer quelle est l'intention la plus probable.</p> <p>Pour reprendre l'exemple ci-dessus, avec un mod\u00e8le constitu\u00e9 des trois phrases d'exemple,  il est probable qu'une nouvelle phrase du type \"Quel temps fera t'il demain ?\" sera reconnue automatiquement par Tock comme correspondant \u00e0 l'intention \"m\u00e9t\u00e9o\".</p> <p>Voir Tock Studio &gt; Language Understanding.</p>"},{"location":"fr/user/concepts/#entites","title":"Entit\u00e9s","text":"<p>Une fois l'intention d\u00e9termin\u00e9e, il est souvent utile d'identifier le sens de certains mots de la phrase.</p> <p>Dans la phrase \"Il fait beau demain ?\", le mot \"demain\" a une signification qu'il faudra utiliser pour r\u00e9pondre de mani\u00e8re pertinente \u00e0 la question. </p> <p>On appelle entit\u00e9s ces mots significatifs de la phrase. </p> <p>Une entit\u00e9 \u00e0 un type et un role. Par exemple, dans la phrase \"Je pars \u00e0 11h et j'arrive \u00e0 18h\",  les mots \"\u00e0 11h\" et \"\u00e0 18h\" sont tous les deux des entit\u00e9s de type 'datetime'  mais \"11h\" aura un r\u00f4le depart l\u00e0 ou \"18h\" aura un r\u00f4le arriv\u00e9e. Dans les cas o\u00f9 le r\u00f4le n'apporte pas d'information suppl\u00e9mentaire, il est souvent \u00e9gal au type.</p> <p>On distingue deux \u00e9tapes dans la prise en compte d'une entit\u00e9 :</p> <ul> <li>L'identification : quels sont les mots de la phrase qui constituent l'entit\u00e9</li> <li>La valorisation : quelle est la valeur de cette entit\u00e9. Par exemple comment traduire \"\u00e0 11h\" en date syst\u00e8me.</li> </ul> <p>Tock par d\u00e9faut identifie l'entit\u00e9, mais ne la valorise pas, sauf pour certains types. Par d\u00e9faut, les entit\u00e9s de namespace \"duckling\" seront automatiquement valoris\u00e9es.</p> <p>Voir Tock Studio &gt; Language Understanding.</p>"},{"location":"fr/user/concepts/#scenario-ou-story","title":"Sc\u00e9nario (ou Story)","text":"<p>Un sc\u00e9nario ou story est un regroupement fonctionnel qui permet de r\u00e9pondre aux questions  sur un sujet bien d\u00e9limit\u00e9.</p> <p>Il est en g\u00e9n\u00e9ral initi\u00e9 par une intention principale et peut aussi utiliser, de mani\u00e8re optionelle, une arborescence d'intentions dites \"secondaires\".</p> <p>Pour reprendre l'exemple de la m\u00e9t\u00e9o, \u00e0 quelqu'un demandant \"Quel temps fait-il ?\",  il peut \u00eatre utile de poser la question de l'endroit o\u00f9 il se trouve.  Cette question sera prise en compte dans la story \"m\u00e9t\u00e9o\" puisqu'elle n'est qu'une extension de la question initiale.</p> <p>La Story est l'unit\u00e9 principale du framework conversationnel de Tock.</p> <p>Voir Tock Studio &gt; Stories &amp; Answers.</p>"},{"location":"fr/user/concepts/#termes-correspondances","title":"Termes &amp; correspondances","text":"<p>Les tableaux ci-dessous proposent des correspondances entre les termes utilis\u00e9s dans Tock et d'autres  solutions conversationnelles :</p> Tock DialogFlow Alexa Watson Intent Intent Intent Intent Entity Entity Entity / Slot Value Entity Sentence Query Utterance / Slot Message Story Context Dialog / Node Builtin Story Fulfillment Request Handler Webhook Connector Integration Integration / Channel Configuration Application Project / Agent Skill Skill / Assistant Tock RASA DYDU (Do You Dream Up) Clevy Intent Intent Reword Question Entity Entity Group Sentence User input Sentence Reformulation Story Story Knowledge Knowledge Builtin Story Connector Channel Channel integration Configuration Space Application Domain Bot <p>La documentation des connecteurs Tock donne \u00e9galement la correspondance avec d'autres termes propres \u00e0  tel ou tel canal.</p>"},{"location":"fr/user/concepts/#continuer","title":"Continuer...","text":"<p>Vous pouvez maintenant entamer le chapitre suivant : Interfaces Tock Studio. </p>"},{"location":"fr/user/guides/","title":"Guides utilisateur","text":"<p>Pour apprendre plus sur les fonctionnalit\u00e9s Tock Studio voici les tutoriels pas \u00e0 pas pour : </p> <ul> <li>Construire un mod\u00e8le conversationnel</li> <li>Cr\u00e9er un bot multicanal (connecteurs)</li> <li>Cr\u00e9er un bot multilingue (internationalisation)</li> </ul>"},{"location":"fr/user/studio/","title":"Les interfaces Tock Studio","text":"<p>Tock Studio regroupe l'ensemble des interfaces utilisateur, techniques et m\u00e9tier, permettant  de concevoir les mod\u00e8les conversationnels, cr\u00e9er des parcours et des r\u00e9ponses, suivre les conversations,   analyser les tendances, etc.</p> <p>Dans cette section, vous trouverez la description de chaque vue et interface.  Pour des th\u00e8mes ou fonctionnalit\u00e9s particuli\u00e8res, voir aussi les guides utilisateur.</p> <ul> <li> <p>Interfaces de Tock Studio :</p> <ul> <li>Interface g\u00e9n\u00e9rale</li> <li>Le menu Language Understanding</li> <li>Le menu Stories &amp; Answers</li> <li>Le menu Gen AI</li> <li>Le menu Test</li> <li>Le menu Analytics</li> <li>Le menu Model Quality</li> <li>Le menu Settings</li> </ul> </li> <li> <p>Guides utilisateur :</p> <ul> <li>Construire un mod\u00e8le conversationnel</li> <li>Cr\u00e9er un bot multicanal (connecteurs)</li> <li>Cr\u00e9er un bot multilingue (internationalisation)</li> </ul> </li> </ul> <p>Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement. </p>"},{"location":"fr/user/guides/build-model/","title":"Construire les mod\u00e8les conversationnels","text":"<p>La documentation Tock Studio peut \u00eatre parcourue \u00e9cran par \u00e9cran, notamment les menus Language Understanding et Model Quality pour la gestion des mod\u00e8les conversationnels. N'h\u00e9sitez pas \u00e0 vous y r\u00e9f\u00e9rer si vous  avez une question sur un onglet / une option en particulier.</p> <p>Cette page pr\u00e9sente la construction des mod\u00e8les en se focalisant plus sur l'usage et l'apprentissage,  s'autorisant \u00e0 passer d'un \u00e9cran \u00e0 un autre sans d\u00e9tailler exhaustivement chaque fonctionnalit\u00e9 de la plateforme.</p> <p>Notez qu'il est possible de d\u00e9ployer la plateforme Tock NLU seule, dans ce cas les interfaces graphiques Tock  se limitent aux menus Settings, Language Understanding et Model Quality. Cette page peut donc servir de tutoriel pour une utilisation  de Tock restreinte au Language Understanding, par exemple pour un usage comme l'Internet des objets.</p>"},{"location":"fr/user/guides/build-model/#rendez-vous-dans-la-section-language-understanding","title":"Rendez-vous dans la section Language Understanding","text":"<p>Le menu Language Understanding renvoie sur l'onglet Inbox par d\u00e9faut. Au d\u00e9part vous n'avez pas de phrases si personne n'a encore parl\u00e9 au bot :</p> <p></p>"},{"location":"fr/user/guides/build-model/#ajoutez-et-qualifiez-des-phrases","title":"Ajoutez et qualifiez des phrases","text":""},{"location":"fr/user/guides/build-model/#ajoutez-une-phrase","title":"Ajoutez une phrase","text":"<ul> <li>Rendez-vous dans l'\u00e9cran New Sentence</li> <li>Saisissez une phrase</li> </ul>"},{"location":"fr/user/guides/build-model/#creez-une-nouvelle-intention","title":"Cr\u00e9ez une nouvelle intention","text":"<ul> <li>Attribuez \u00e0 la phrase une nouvelle intention en s\u00e9lectionnant Create a New Intent dans la liste de s\u00e9lection Intent.</li> </ul>"},{"location":"fr/user/guides/build-model/#specifiez-des-entites","title":"Sp\u00e9cifiez des entit\u00e9s","text":"<p>Selon ce \u00e0 quoi est destin\u00e9e l'intention, vous pouvez sp\u00e9cifier les entit\u00e9s que vous souhaitez que votre mod\u00e8le reconnaisse dans la phrase :</p> <ul> <li>S\u00e9lectionnez une portion de phrase correspondant \u00e0 l'entit\u00e9 (ie. un groupe de mots \u00e0 s\u00e9lectionner avec la souris)</li> <li>Cliquez sur Add Entity qui vient d'appara\u00eetre</li> </ul> <p></p> <ul> <li>Choisissez un type d'entit\u00e9 existant ou cr\u00e9ez-en un nouveau</li> <li>Donnez un r\u00f4le \u00e0 cette entit\u00e9</li> </ul> <p>Exemple : dans la phrase \"je veux aller de Paris \u00e0 New York\", probablement que Paris et New York sont deux entit\u00e9s  du m\u00eame type (localit\u00e9) mais n'ont pas le m\u00eame r\u00f4le dans l'intention (origine et destination).</p> <p>Il est bien s\u00fbr possible d'avoir plusieurs occurrences du m\u00eame role, ou d'un r\u00f4le diff\u00e9rent dans la m\u00eame phrase.</p> <p></p>"},{"location":"fr/user/guides/build-model/#tirez-parti-des-entites-predefinies","title":"Tirez parti des entit\u00e9s pr\u00e9d\u00e9finies","text":"<p>Par d\u00e9faut, Tock propose un certain nombre de types d'entit\u00e9s pr\u00e9d\u00e9finies, notamment les types support\u00e9s par la biblioth\u00e8que Duckling : montants, dates, etc. Si vous s\u00e9lectionnez ces types d'entit\u00e9s,  celles-ci seront automatiquement reconnues et valoris\u00e9es.</p> <p></p>"},{"location":"fr/user/guides/build-model/#validez-la-phrase","title":"Validez la phrase","text":"<p>Lorsque l'intention et les entit\u00e9s sont correctes, terminez la qualification de la phrase en cliquant sur Validate. </p>"},{"location":"fr/user/guides/build-model/#qualifiez-dautres-phrases","title":"Qualifiez d'autres phrases","text":"<p>Apr\u00e8s deux ou trois phrases pour une intention donn\u00e9e, il est courant que le mod\u00e8le commence \u00e0 reconna\u00eetre  les phrases suivantes et d\u00e9tectent bien l'intention (avec un score grandissant, du moment que les  phrases sont relativement proches / en rapport avec l'intention bien s\u00fbr) :</p> <p></p> <p>Si une phrase n'est pas bien qualifi\u00e9e, changez l'intention / les entit\u00e9s puis faites Validate pour appliquer  la correction. Si la phrase \u00e9tait bien qualifi\u00e9e, faites directement Validate.</p> <p>Dans les deux cas, vous alimentez ainsi le mod\u00e8le, qui se reconstruit, et devient plus pertinent pour les  pharses suivantes.</p> <p>Vous \u00eates en train de construire votre mod\u00e8le conversationnel !</p> <p>C'est le d\u00e9but de l'apprentissage pour votre bot ou votre application conversationnelle.</p> <p>La qualification de phrases, leur nombre mais aussi leur vari\u00e9t\u00e9 (notamment dans le temps, car les utilisateurs d'aujourd'hui ne sont  pas exactement les utilisateurs de demain) sont la base d'un mod\u00e8le pertinent et d'une bonne exp\u00e9rience conversationnelle  pour les utilisateurs. </p>"},{"location":"fr/user/guides/build-model/#parcourez-les-phrases-du-modele","title":"Parcourez les phrases du mod\u00e8le","text":"<p>L'onglet Search permet de parcourir l'ensemble des phrases du mod\u00e8le en utilisant un certain nombre de crit\u00e8res. Le plus utilis\u00e9 est la recherche texte simple pour lequel il est \u00e9galement possible d'utiliser des expressions r\u00e9guli\u00e8res.</p> <p></p> <p>Chaque phrase \u00e0 un \u00e9tat Status qui peut \u00e9voluer au cours du temps :</p> <ul> <li>Inbox : La phrase n'a pas encore \u00e9t\u00e9 qualifi\u00e9e et ne fait pas partie du mod\u00e8le</li> <li>Validated : La phrase a \u00e9t\u00e9 valid\u00e9e mais n'est pas encore pris en compte dans les mod\u00e8les de NLP (cela peut prendre du temps dans le cas de mod\u00e8les de taille importante)</li> <li>Included in model : La phrase a \u00e9t\u00e9 valid\u00e9e et a \u00e9t\u00e9 prise en compte dans les mod\u00e8les de NLP</li> </ul> <p>Cet \u00e9cran permet donc de consulter les phrases faisant d\u00e9j\u00e0 partie du mod\u00e8le (autrement dit d\u00e9j\u00e0 qualifi\u00e9s),  et de faire \u00e9voluer les qualifications de phrases au cours du temps. Il est notamment possible   de re-qualifier tout un groupe de phrases.</p> <p>Par exemple, vous pourrez cr\u00e9er une nouvelle intention plus tard et d\u00e9cider que toutes les phrases remplissant  un certain crit\u00e8re (mot-clef ou autre) devront dor\u00e9navant \u00eatre qualifi\u00e9es dans cette nouvelle intention.</p>"},{"location":"fr/user/guides/build-model/#modifiez-les-caracteristiques-avancees-de-lapplication","title":"Modifiez les caract\u00e9ristiques avanc\u00e9es de l'application","text":"<p>Le menu Applications donne acc\u00e8s \u00e0 la liste des applications/bots disponibles sur la plateforme :</p> <p></p> <p>Avec le bouton de modification, plusieurs options sont disponibles, en particulier :</p>"},{"location":"fr/user/guides/build-model/#la-selection-du-moteur-nlu","title":"La s\u00e9lection du moteur NLU","text":"<p>Vous avez la possibilit\u00e9 de s\u00e9lectionner la biblioth\u00e8que NLU utilis\u00e9e par ce bot  (\u00e0 condition que plusieurs moteurs soient pr\u00e9sents dans l'installation de la plateforme).</p>"},{"location":"fr/user/guides/build-model/#lactivation-des-modeles-dentites","title":"L'activation des mod\u00e8les d'entit\u00e9s","text":"<p>Cette option permet de r\u00e9utiliser des mod\u00e8les d'entit\u00e9s pr\u00e9-construits dans vos nouvelles intentions.  Par exemple, si vous cr\u00e9ez une intention avec une entit\u00e9 <code>duckling:datetime</code>,  les dates seront automatiquement reconnues pour cette intention dans tous les nouvelles phrases attribu\u00e9es \u00e0 cette  intention.</p> <p>En interne, un arbitrage est effectu\u00e9 entre les informations provenant des mod\u00e8les d'entit\u00e9s pr\u00e9-construits et les  informations tir\u00e9es de votre propre mod\u00e8le.</p> <p>Cette option est activ\u00e9e par d\u00e9faut. Il peut \u00eatre utile de la d\u00e9sactiver pour les mod\u00e8les de taille tr\u00e8s importante,  pour lesquels la d\u00e9tection native sera sup\u00e9rieure dans quasiment tous les cas \u00e0 celle des mod\u00e8les d'entit\u00e9s. </p>"},{"location":"fr/user/guides/build-model/#lactivation-des-sous-entites","title":"L'activation des sous-entit\u00e9s","text":"<p>Si vous activez cette option, vous pourrez qualifier plusieurs niveaux d'entit\u00e9s :</p> <p></p> <p>Le nombre de niveaux n'est pas limit\u00e9, mais il est conseill\u00e9 de ne pas en sp\u00e9cifier plus de 3 ou 4.</p>"},{"location":"fr/user/guides/build-model/#valeurs-predefinies-dentites","title":"Valeurs pr\u00e9definies d'entit\u00e9s","text":"<p>Une entit\u00e9 donn\u00e9e peut avoir des valeurs pr\u00e9d\u00e9finies. Pour cela vous devez aller dans l'onglet Entities,  selectionnez une entit\u00e9. L'ic\u00f4ne \u00e0 cot\u00e9 de l'ic\u00f4ne de suppression montre les types d'entit\u00e9s que vous pouvez modifier :</p> <p></p> <p>Dans l'exemple ci-dessus, deux labels sont d\u00e9finis pour la valeur de semaine :</p> <ul> <li>Semaine</li> <li>hebdomadaire</li> </ul>"},{"location":"fr/user/guides/build-model/#continuer","title":"Continuer...","text":"<p>Pour en savoir plus sur la gestion des entit\u00e9s, notamment dans des intentions cr\u00e9\u00e9es programmatiquement,  out tout simplement pour continuer de parcourir le manuel utilisateur Tock,  vous pouvez vous rendre dans le chapitre D\u00e9veloppement.</p>"},{"location":"fr/user/guides/canaux/","title":"Construire un bot multicanal avec Tock","text":""},{"location":"fr/user/guides/canaux/#notion-de-connecteur","title":"Notion de connecteur","text":"<p>Un connecteur Tock permet d'int\u00e9grer un bot \u00e0 un canal de communication (textuel ou vocal) externe. Mis \u00e0 part le type connecteur de test (utilis\u00e9 en interne par l'interface Tock Studio), les connecteurs  sont associ\u00e9s \u00e0 des canaux externes \u00e0 la plateforme Tock.</p> <p>Tout l'int\u00e9r\u00eat des connecteurs Tock r\u00e9side dans la possibilit\u00e9 de d\u00e9velopper des assistants conversationnels  ind\u00e9pendamment du ou des canaux utilis\u00e9s pour lui parler. Il est ainsi possible de cr\u00e9er un bot pour un canal, puis le rendre multicanal par la suite en ajoutant des connecteurs.</p> <p>Le connecteur Web a la particularit\u00e9 d'exposer une API g\u00e9n\u00e9rique pour interagir avec un bot Tock. En cons\u00e9quence, il permet encore davantage d'int\u00e9grations c\u00f4t\u00e9 \"frontend\", utilisant cette API comme passerelle.</p> <p>Cette page liste en fait :</p> <ul> <li> <p>Les connecteurs fournis avec la distribution Tock : </p> </li> <li> <p>Les kits utilisant le connecteur Web pour int\u00e9grer d'autres canaux : </p> </li> <li> <p>Les int\u00e9grations possibles pour le traitement de la voix : </p> </li> </ul>"},{"location":"fr/user/guides/canaux/#connecteurs-fournis-avec-tock","title":"Connecteurs fournis avec Tock","text":"<p>Tock fournit de nombreux connecteurs pour diff\u00e9rents types de canaux (voir ci-dessous). De nouveaux connecteurs sont  r\u00e9guli\u00e8rement ajout\u00e9s \u00e0 la plateforme, en fonction des besoins projets mais aussi du calendrier d'ouverture aux bots  des canaux grand public.</p> <p>Exemples : arriv\u00e9e de Google Home en France en 2017, Alexa en 2018, ouverture des API WhatsApp puis Business Chat en 2019, etc. </p> <p>Pour en savoir plus sur les bots r\u00e9f\u00e9renc\u00e9s utilisant tel ou tel connecteur en production,  n'h\u00e9sitez pas \u00e0 consulter la page vitrine Tock.</p>"},{"location":"fr/user/guides/canaux/#messenger","title":"Messenger","text":"<ul> <li>Canal : Facebook Messenger</li> <li>Type : texte (+ voix via l'upload de messages vocaux)</li> <li>Status : connecteur Tock utilis\u00e9 en production depuis 2016</li> </ul> <p>Le guide Connecter son bot \u00e0 Messenger explique comment int\u00e9grer un bot  Tock avec une page Facebook / Messenger.</p> <p>Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier  connector-messenger sur GitHub,  o\u00f9 vous retrouverez les sources et le README du connecteur.</p>"},{"location":"fr/user/guides/canaux/#slack","title":"Slack","text":"<ul> <li>Canal : Slack</li> <li>Type : texte</li> <li>Status : connecteur Tock utilis\u00e9 hors production</li> </ul> <p>Le guide Connecter son bot \u00e0 Slack explique comment int\u00e9grer un bot  Tock avec une cha\u00eene Slack.</p> <p>Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier  connector-slack sur GitHub,  o\u00f9 vous retrouverez les sources et le README du connecteur.</p>"},{"location":"fr/user/guides/canaux/#google-assistant-home","title":"Google Assistant / Home","text":"<ul> <li>Canal : Google Assistant / Google Home</li> <li>Type : texte + voix</li> <li>Status : connecteur Tock utilis\u00e9 en production depuis 2017</li> </ul> <p>Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier  connector-ga sur GitHub.</p>"},{"location":"fr/user/guides/canaux/#alexa-echo","title":"Alexa / Echo","text":"<ul> <li>Canal : Amazon Alexa / Amazon Echo</li> <li>Type : voix</li> <li>Status : connecteur Tock utilis\u00e9 en production depuis 2018</li> </ul> <p>Remarque importante : dans le cas d'Alexa, le mod\u00e8le NLP est forc\u00e9ment construit et h\u00e9berg\u00e9 chez Amazon.  Seul la partie framework conversationel de Tock peut \u00eatre utilis\u00e9e.</p> <p>Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier  connector-alexa sur GitHub.</p>"},{"location":"fr/user/guides/canaux/#rocketchat","title":"Rocket.Chat","text":"<ul> <li>Canal : Rocket.Chat</li> <li>Type : texte</li> <li>Status : \u00e0 pr\u00e9ciser</li> </ul> <p>Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier  connector-rocketchat sur GitHub.</p>"},{"location":"fr/user/guides/canaux/#whatsapp","title":"WhatsApp","text":"<ul> <li>Canal : WhatsApp from Facebook</li> <li>Type : texte</li> <li>Status : connecteur Tock utilis\u00e9 en production depuis 2019</li> </ul> <p>Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier  connector-whatsapp sur GitHub.</p>"},{"location":"fr/user/guides/canaux/#teams","title":"Teams","text":"<ul> <li>Canal : Microsoft Teams</li> <li>Type : texte + voix</li> <li>Status : connecteur Tock utilis\u00e9 en production depuis 2019</li> </ul> <p>Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier  connector-teams sur GitHub.</p>"},{"location":"fr/user/guides/canaux/#business-chat","title":"Business Chat","text":"<ul> <li>Canal : Apple Business Chat (Messages)</li> <li>Type : texte</li> <li>Status : connecteur Tock utilis\u00e9 en production depuis 2019</li> </ul> <p>Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier  connector-businesschat sur GitHub.</p>"},{"location":"fr/user/guides/canaux/#twitter","title":"Twitter","text":"<ul> <li>Canal : Twitter (messages priv\u00e9s)</li> <li>Type : texte</li> <li>Status : connecteur Tock utilis\u00e9 en production depuis 2019</li> </ul> <p>Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier  connector-twitter sur GitHub.</p>"},{"location":"fr/user/guides/canaux/#allo-media","title":"Allo-Media","text":"<ul> <li>Canal : Allo-Media (t\u00e9l\u00e9phonie)</li> <li>Type : voix</li> <li>Status : connecteur Tock utilis\u00e9 en production depuis 2020</li> </ul> <p>Ce connecteur a \u00e9t\u00e9 d\u00e9velopp\u00e9 pour le bot AlloCovid. Pour en savoir plus, voir la classe AlloMediaConnector avec les sources du bot sur GitHub.</p>"},{"location":"fr/user/guides/canaux/#google-chat","title":"Google Chat","text":"<ul> <li>Canal : Google Chat (anciennement Google Hangouts)</li> <li>Type : texte</li> <li>Status : connecteur Tock utilis\u00e9 hors production</li> </ul> <p>Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier  connector-google-chat sur GitHub.</p>"},{"location":"fr/user/guides/canaux/#web-generique","title":"Web (g\u00e9n\u00e9rique)","text":"<p>Ce connecteur g\u00e9n\u00e9rique permet d'int\u00e9grer un bot Tock \u00e0 n'importe quel site Web ou application : portail, application Web ou mobile, client REST, etc.</p> <p>Le connecteur expose une API REST vers le bot, facilement int\u00e9grable depuis n'importe quelle application Web ou mobile, ou langage de programmation.</p> <p>Plusieurs kits et composants bas\u00e9s sur le connecteur Web sont d\u00e9j\u00e0 disponibles pour int\u00e9grer des bots Tock \u00e0  diff\u00e9rents sites et applications, comme des sites Web avec React,  des applications mobiles natives avec Flutter ou encore des  intranets SharePoint.</p> <ul> <li>Canal : Web (g\u00e9n\u00e9rique pour tous sites &amp; applications Web)</li> <li>Type : texte</li> <li>Status : connecteur Tock utilis\u00e9 en production depuis 2020</li> </ul> <p>Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-web sur GitHub. Il contient exemples et documentation format Swagger de l'API REST.</p>"},{"location":"fr/user/guides/canaux/#test-generique","title":"Test (g\u00e9n\u00e9rique)","text":"<p>Ce connecteur est interne \u00e0 Tock, il sert \u00e0 dialoguer avec un bot directement dans l'interface  Tock Studio (vue Test &gt; Test the bot) en \u00e9mulant d'autres connecteurs.</p>"},{"location":"fr/user/guides/canaux/#integrations-via-le-connecteur-web","title":"Int\u00e9grations via le connecteur Web","text":"<p>Le connecteur Web expose une API g\u00e9n\u00e9rique pour interagir avec un bot Tock. En cons\u00e9quence, il permet encore davantage d'int\u00e9grations c\u00f4t\u00e9 \"frontend\", utilisant cette API comme passerelle.</p>"},{"location":"fr/user/guides/canaux/#react","title":"React","text":"<p>Ce composant React int\u00e8gre un bot Tock et en assure le rendu graphique dans une application Web. L'application Web communique avec le bot via un connecteur Web.</p> <ul> <li>Int\u00e9gration : React (JavaScript / JSX)</li> <li>Type : applications Web</li> <li>Status : utilis\u00e9 en production depuis 2020</li> </ul> <p>Pour en savoir plus, voir les sources et le README dans le d\u00e9p\u00f4t  <code>tock-react-kit</code> sur GitHub.</p>"},{"location":"fr/user/guides/canaux/#flutter-beta","title":"Flutter (beta)","text":"<p>Ce composant Flutter int\u00e8gre un bot Tock et en assure le rendu graphique dans une application mobile ou Web. L'application communique avec le bot via un connecteur Web.</p> <ul> <li>Int\u00e9gration : Flutter (Dart)</li> <li>Type : applications mobiles natives et Web</li> <li>Status : beta, en d\u00e9veloppement</li> </ul> <p>Pour en savoir plus, voir les sources et le README dans le d\u00e9p\u00f4t  <code>tock-flutter-kit</code> sur GitHub.</p>"},{"location":"fr/user/guides/canaux/#sharepoint-beta","title":"SharePoint (beta)","text":"<p>Ce composant WebPart permet d'int\u00e9grer un bot Tock dans un site SharePoint. Il embarque le tock-react-kit pour communiquer avec le bot  via un connecteur Web et g\u00e9rer le rendu graphique du bot dans la page SharePoint.</p> <ul> <li>Int\u00e9gration : Microsoft SharePoint</li> <li>Type : sites Web &amp; intranets</li> <li>Status : beta, en d\u00e9veloppement</li> </ul> <p>Pour en savoir plus, voir les sources et le README dans le d\u00e9p\u00f4t  <code>tock-sharepoint</code> sur GitHub.</p>"},{"location":"fr/user/guides/canaux/#technologies-vocales","title":"Technologies vocales","text":"<p>Les bots Tock traitent des phrases en format texte par d\u00e9faut (chatbots). N\u00e9anmoins, on peut  int\u00e9grer des technologies vocales aux \"bornes\" du bot afin d'obtenir des conversations vocales (voicebots et callbots) :</p> <ul> <li>Traduction de la voix en texte (Speech-To-Text) en amont du traitement par le bot (ie. avant l'\u00e9tape NLU)</li> <li>Traduction du texte en voix (Text-To-Speech) en aval du traitement par le bot (ie. synth\u00e8se vocale de la r\u00e9ponse du bot)</li> </ul> <p>Certains connecteurs fournis avec Tock permettent d'int\u00e9grer un bot \u00e0 un canal externe  g\u00e9rant les aspects vocaux STT et TTS.</p> <p>En outre, d'autres technologies vocales ont pu \u00eatre int\u00e9gr\u00e9es \u00e0 Tock ces derni\u00e8res ann\u00e9es. Elles sont mentionn\u00e9es \u00e0 titre indicatif, m\u00eame quand il n'est pas fourni de connecteur pr\u00eat \u00e0 l'emploi.</p>"},{"location":"fr/user/guides/canaux/#google-android","title":"Google / Android","text":"<p>Les fonctions Speech-To-Text et Text-To-Speech de Google sont utilis\u00e9es \u00e0 travers le  connecteur Google Assistant / Home, \u00e9galement par les fonctions  vocales de l'application Microsoft Teams pour Android compatible avec le connecteur Teams, ainsi qu'au sein de la plateforme Android  notamment pour des d\u00e9veloppements mobiles natifs.</p> <p> </p> <ul> <li>Technologie : STT &amp; TTS Google / Android</li> <li>Status : utilis\u00e9 avec Tock en production  (via connecteurs Google Assistant / Home,  Microsoft Teams  et en natif Android pour les bots int\u00e9gr\u00e9s on-app)</li> </ul>"},{"location":"fr/user/guides/canaux/#apple-ios","title":"Apple / iOS","text":"<p>Les fonctions Speech-To-Text et Text-To-Speech d'Apple sont utilis\u00e9es \u00e0 travers le  connecteur Business Chat, ainsi qu'au sein d'iOS pour des d\u00e9veloppements mobiles natifs.</p> <p> </p> <ul> <li>Technologie : STT &amp; TTS Apple / iOS</li> <li>Status : utilis\u00e9 avec Tock en production (via connecteur Business Chat  et en natif iOS pour les bots int\u00e9gr\u00e9s on-app)</li> </ul>"},{"location":"fr/user/guides/canaux/#amazon-alexa","title":"Amazon / Alexa","text":"<p>Les fonctions Speech-To-Text et Text-To-Speech d'Alexa (Amazon) sont utilis\u00e9es \u00e0 travers le  connecteur Alexa / Echo.</p> <p></p> <ul> <li>Technologie : STT &amp; TTS Amazon / Alexa</li> <li>Status : utilis\u00e9 avec Tock en production (via connecteur Alexa)</li> </ul>"},{"location":"fr/user/guides/canaux/#allo-media-voxygen","title":"Allo-Media &amp; Voxygen","text":"<p>La soci\u00e9t\u00e9 Allo-Media propose une plateforme IA bas\u00e9e sur les appels t\u00e9l\u00e9phoniques.</p> <p>Voxygen propose des services de synth\u00e8se vocale.</p> <p>A l'occasion du d\u00e9veloppement du bot AlloCovid, un connecteur Allo-Media a \u00e9t\u00e9 d\u00e9velopp\u00e9 pour int\u00e9grer le bot (Tock) aux services Allo-Media :  Speech-To-Text et Text-To-Speech avec Voxygen.</p> <p> </p> <ul> <li>Technologie : Allo-Media &amp; Voxygen</li> <li>Status : utilis\u00e9 avec Tock en production (via connecteur Allo-Media)</li> </ul>"},{"location":"fr/user/guides/canaux/#nuance","title":"Nuance","text":"<p>Nuance propose des solutions de reconnaissance vocale &amp; IA.</p> <p>Pour des exp\u00e9rimentations de commande vocale en 2016, Nuance avait \u00e9t\u00e9 int\u00e9gr\u00e9 \u00e0 Tock pour ses fonctions Speech-To-Text.  M\u00eame si cette int\u00e9gration n'a pas \u00e9t\u00e9 maintenue depuis, cela fonctionnait apr\u00e8s quelques jours de mise en place.</p> <p></p> <ul> <li>Technologie : Nuance</li> <li>Status : utilis\u00e9 avec Tock en 2016</li> </ul>"},{"location":"fr/user/guides/canaux/#architecture-de-connecteurs-gouvernance-des-donnees","title":"Architecture de connecteurs &amp; gouvernance des donn\u00e9es","text":"<p>Dans une optique de gouvernance des mod\u00e8les et donn\u00e9es conversationnelles, l'architecture en connecteurs  Tock pr\u00e9sente plusieurs avantages :</p> <ul> <li>Le mod\u00e8le est construit dans Tock, il n'est pas partag\u00e9 via les connecteurs</li> <li>Le choix des connecteurs d'un bot permet de maitriser la propagation (ou non) des conversations</li> </ul> <p>Par exemple, pour un bot interne \u00e0 une entreprise, on peut choisir de n'utiliser que des connecteurs  vers des canaux propres (site Web, etc.) ou internes \u00e0 l'entreprise (applications d'entreprise, espace pro sur  un t\u00e9l\u00e9phone Android, etc.). </p> <ul> <li>M\u00eame si un bot est connect\u00e9 \u00e0 plusieurs canaux/partenaires externes, seule la plateforme Tock poss\u00e8de l'ensemble des conversations sur tous ces canaux.</li> </ul>"},{"location":"fr/user/guides/canaux/#developper-son-propre-connecteur","title":"D\u00e9velopper son propre connecteur","text":"<p>Il est possible de cr\u00e9er son propre connecteur Tock, par exemple pour interfacer un bot Tock avec un canal propre \u00e0  l'organisation (souvent un site Web ou une application mobile sp\u00e9cifiques), ou bien quand un canal grand public  s'ouvre aux bots conversationnels et que le connecteur Tock n'existe pas encore.</p> <p>La section Bot Framework du manuel d\u00e9veloppeur Tock donne des indications pour  impl\u00e9menter son propre connecteur.</p>"},{"location":"fr/user/guides/i18n/","title":"Construire un bot multilingue avec Tock","text":"<p>L'interface Tock Studio permet de traduire et moduler les r\u00e9ponses d'un bot en fonction de la  langue mais aussi du canal utilis\u00e9s.</p>"},{"location":"fr/user/guides/i18n/#pre-requis","title":"Pr\u00e9-requis","text":"<p>Tock met \u00e0 disposition un framework complet d'internationalisation. Il est activ\u00e9 par d\u00e9faut en mode Bot API  (par exemple sur la plateforme de d\u00e9monstration).</p> <p>Dans le mode Bot int\u00e9gr\u00e9 (voir le manuel d\u00e9veloppeur), l'internationalisation  est d\u00e9sactiv\u00e9e par d\u00e9faut. Pour l'activer, il est alors n\u00e9cessaire de configurer la plateforme \u00e0 son d\u00e9marrage :</p> <ul> <li>Soit via le code de d\u00e9marrage du bot (d\u00e9veloppeur) : <pre><code>    Translator.enabled = true\n</code></pre></li> <li>Soit avec une propri\u00e9t\u00e9 Syst\u00e8me (administrateur) en passant <code>-Dtock_i18n_enabled=true</code> au d\u00e9marrage de la JVM</li> </ul>"},{"location":"fr/user/guides/i18n/#activer-plusieurs-langues-pour-un-bot","title":"Activer plusieurs langues pour un bot","text":"<p>Il est possible d'ajouter et de g\u00e9rer les langues actives pour un bot dans la section NLU Applications (dans Tock Studio). Voir Le menu Settings.</p> <p>A tout moment dans Tock Studio, il est possible de changer la langue s\u00e9lectionn\u00e9e dans la banni\u00e8re en haut de page,  notamment pour dialoguer avec un bot dans l'interface Test the bot. Voir Interface g\u00e9n\u00e9rale.</p>"},{"location":"fr/user/guides/i18n/#langue-et-locale-utilisateur","title":"Langue et locale utilisateur","text":"<p>Quand c'est possible, la locale de l'utilisateur (langue / r\u00e9gion) est import\u00e9e de celle de son compte. </p> <p>Par exemple, si le compte d'un utilisateur Messenger est configur\u00e9 en Fran\u00e7ais, le Fran\u00e7ais sera automatiquement  s\u00e9lectionn\u00e9 par Tock.</p> <p>S'il n'y a pas d'indication de locale, c'est la locale par d\u00e9faut de Tock qui est utilis\u00e9e.</p> <p>Un d\u00e9veloppeur peut modifier la locale de l'utilisateur dans le code du bot lui-m\u00eame : </p> <pre><code>    userPreferences.locale = Locale.FRENCH\n</code></pre> <p>Enfin, la locale par d\u00e9faut peut \u00eatre modifi\u00e9e par un administrateur de la plateforme, en passant la propri\u00e9t\u00e9 Syst\u00e8me <code>-Dtock_default_locale=fr</code> au d\u00e9marrage de la JVM.</p>"},{"location":"fr/user/guides/i18n/#traduire-et-faire-varier-les-reponses-du-bot","title":"Traduire et faire varier les r\u00e9ponses du bot","text":"<p>Dans Tock Studio, la section Stories &amp; Answers &gt; Answers permet de g\u00e9rer les libell\u00e9s des r\u00e9ponses du bot.  Voir Le menu Stories &amp; Answers.</p> <p>Chaque libell\u00e9 a une valeur par d\u00e9faut pour chaque langue du bot.  Il est possible de concevoir et configurer diff\u00e9rentes variantes :</p> <ul> <li>En fonction de la langue</li> <li>En fonction du canal / connecteur <p>Par exemple, certains canaux requi\u00e8rent des libell\u00e9s sp\u00e9cifiques, soit parce que le propri\u00e9taire du canal l'exige  (sur Alexa le vouvoiement est requis), soit parce que l'exp\u00e9rience utilisateur diff\u00e8re des autres canaux (par exemple  en vocal on \u00e9vitera de trop longues phrases).</p> </li> <li>Al\u00e9atoirement (pour que le bot ne r\u00e9ponde pas toujours la m\u00eame chose)</li> </ul>"},{"location":"fr/user/guides/i18n/#traduire-massivement-les-modeles-et-reponses","title":"Traduire massivement les mod\u00e8les et r\u00e9ponses","text":"<p>Des fonctionnalit\u00e9s sont \u00e0 l'\u00e9tude pour permettre la traduction plus ou moins automatis\u00e9e de nombreuses phrases  utilisateur (corpus / mod\u00e8le conversationnel) et r\u00e9ponses (libell\u00e9s / i18n). A suivre...</p> <p>Pour le moment, pour envisager une traduction de masse, on peut par exemple :</p> <ol> <li>Exporter les donn\u00e9es en JSON ou CSV avec Tock Studio</li> <li>Traduire les phrases/r\u00e9ponses en dehors de Tock (API SaaS, agence...)</li> <li>Importer les traductions avec Tock Studio</li> </ol> <p>Remarque : au moment de l'import seuls les libell\u00e9s marqu\u00e9s valid\u00e9s sont pris en compte. </p>"},{"location":"fr/user/guides/i18n/#developper-avec-linternationalisation","title":"D\u00e9velopper avec l'internationalisation","text":"<p>Le manuel d\u00e9veloppeur Tock donne plus de d\u00e9tails sur le d\u00e9veloppement des bots multilingues.</p>"},{"location":"fr/user/guides/intents-restrictions/","title":"Intents restrictions","text":""},{"location":"fr/user/guides/intents-restrictions/#title-restriction-dintentions","title":"title: Restriction d\u2019intentions","text":""},{"location":"fr/user/guides/intents-restrictions/#restreindre-la-portee-des-intentions","title":"Restreindre la port\u00e9e des intentions","text":"<p>Dans certains cas, la d\u00e9tection d\u2019intention peut s\u2019av\u00e9rer complexe, en particulier lorsque l'entra\u00eenement d\u2019une partie du mod\u00e8le est rendu impossible du fait du champ des possibles. C\u2019est par exemple le cas si l\u2019on souhaite r\u00e9cup\u00e9rer le nom de famille d\u2019un utilisateur au cours d\u2019une conversation. Il n\u2019est \u00e9videmment pas envisageable d'entra\u00eener une intention pour d\u00e9tecter tous les noms propres existant.</p> <p>La restriction d\u2019intentions permet de limiter le choix des intentions \u00e9ligibles au sortir d\u2019une story, qu'elle soit configur\u00e9e via le studio ou programmatique. Plusieurs intentions peuvent \u00eatre d\u00e9finies affect\u00e9es chacune d\u2019une pond\u00e9ration qui d\u00e9termine leur pr\u00e9pond\u00e9rance les unes par rapport aux autres.</p> <p>La restriction d\u2019intention n\u2019est effective que pour la prochaine action.</p>"},{"location":"fr/user/guides/intents-restrictions/#story-programmatique","title":"Story programmatique","text":"<p>L\u2019objet nextIntentsQualifiers est une propri\u00e9t\u00e9 du ClientBus utilisable dans une story programmatique:</p> <pre><code>nextIntentsQualifiers =  listOf(\n    NlpIntentQualifier(\"ask_last_name\",10.0),\n    NlpIntentQualifier(\"cancel\",0.0)\n)\n</code></pre> <p>les intentions \u00e9ligibles apr\u00e8s cette story sont donc \u2018ask_last_name\u2019 et \u2018cancel\u2019, cette derni\u00e8re \u00e9tant moins susceptible d\u2019\u00eatre d\u00e9clench\u00e9e du fait de sa moindre pond\u00e9ration</p>"},{"location":"fr/user/guides/intents-restrictions/#story-configuree","title":"Story configur\u00e9e","text":"<p>La restriction d\u2019intentions peut \u00eatre effectu\u00e9e au sein du studio lors de l\u2019\u00e9dition d\u2019un story .</p> <p>Attention : Si vous d\u00e9finissez des quick replies et une liste d\u2019intentions restreintes, les intentions associ\u00e9es aux quick replies seront ajout\u00e9es \u00e0 la liste des intentions restreintes. Ce m\u00e9canisme permet d\u2019\u00e9viter des conflits o\u00f9 les intentions restreintes d\u00e9finies contrediraient les quick replies d\u00e9finies dans la story.</p> <p>Les pond\u00e9rations peuvent prendre dans les valeurs suivantes : * unlikely : * likely : 0.5 * very likely : 0.9</p> <p></p>"},{"location":"fr/user/studio/analytics/","title":"Le menu Analytics","text":"<p>Ce menu contient une s\u00e9rie d'onglets permettant de visualiser et d'analyser les cas d'utilisation du bot, des configurations, des stories et des intentions.</p> <p>Le menu Monitoring permet de suivre et observer les utilisateurs connect\u00e9s ainsi que les conversations.</p>"},{"location":"fr/user/studio/analytics/#longlet-activity","title":"L'onglet Activity","text":"<p>Cet \u00e9cran permet de suivre diff\u00e9rents indicateurs dans le temps :</p> <ul> <li>Nombre de messages re\u00e7us par le bot</li> <li>Messages par Story,</li> <li>Messages par Configuration,</li> <li>Messages par Connecteur,</li> <li>Etc.</li> </ul> <p>Un calendrier permet de d\u00e9finir la p\u00e9riode de temps \u00e0 visualiser.</p> <p>Chaque indicateur peut \u00eatre vu de plusieurs mani\u00e8res :</p> <ul> <li>Histogramme</li> <li>Diagramme camembert (sur la p\u00e9riode s\u00e9lectionn\u00e9e)</li> <li>Tableau triable</li> <li>Export CSV</li> </ul> <p>L'onglet Preferences permet de composer son propre tableau de bord, choisir ses indicateurs et les options de pr\u00e9sentations.</p>"},{"location":"fr/user/studio/analytics/#longlet-behavior","title":"L'onglet Behavior","text":"<p>Cet \u00e9cran pr\u00e9sente d'autres indicateurs pour un p\u00e9riode d\u00e9finie, sans pour autant repr\u00e9senter leur \u00e9volution :</p> <ul> <li>Type de messages re\u00e7us par le bot</li> <li>Canaux les plus utilis\u00e9s</li> <li>Fr\u00e9quentation horaire</li> <li>Fr\u00e9quentation par jour de la semaine</li> <li>Etc.</li> </ul> <p>Un calendrier permet de d\u00e9finir la p\u00e9riode de temps \u00e0 visualiser.</p> <p>Chaque indicateur peut \u00eatre vu de plusieurs mani\u00e8res :</p> <ul> <li>Diagramme camembert (sur la p\u00e9riode s\u00e9lectionn\u00e9e)</li> <li>Tableau triable</li> <li>Export CSV</li> </ul> <p>L'onglet Preferences permet de composer son propre tableau de bord, choisir ses indicateurs et les options de pr\u00e9sentations.</p>"},{"location":"fr/user/studio/analytics/#longlet-flow","title":"L'onglet Flow","text":"<p>Cet \u00e9cran permet d'analyser le flot des intentions et des conversations :</p> <ul> <li> <p>Flot des conversations (Dynamic / User Flow) : analyse dynamique des parcours r\u00e9ellement effectu\u00e9s par les utilisateurs</p> </li> <li> <p>Flot des intentions (Static / Available Stories) : analyse statique des parcours et arbres de d\u00e9cisions propos\u00e9s par le bot</p> </li> </ul> <p>En d\u00e9veloppant l'interface (fl\u00e8che \u00e0 droite du cadre), de nombreux filtres apparaissent : focalisation sur une intention, transitions  entrantes/sortantes, toutes les transitions ou seulement les plus repr\u00e9sentatives en termes de trafic, etc.</p>"},{"location":"fr/user/studio/analytics/#longlet-users","title":"L'onglet Users","text":"<p>Cet onglet vous permet de voir les derniers utilisateurs connect\u00e9s au bot :</p> <ul> <li>Nombre d'utilisateurs connect\u00e9s</li> <li>Date du dernier \u00e9change avec un utilisateur</li> <li>Dernier message envoy\u00e9</li> <li>Etc.</li> </ul> <p>En cliquant sur Display dialog, vous pouvez voir la conversation de cet utilisateur. </p> <p></p>"},{"location":"fr/user/studio/analytics/#longlet-search","title":"L'onglet Search","text":"<p>A l'instar de la vue Users, cette \u00e9cran permet d'observer les derni\u00e8res conversations.</p> <p>Il est possible de les filtrer par connecteur, intention, etc.</p>"},{"location":"fr/user/studio/analytics/#longlet-preferences","title":"L'onglet Preferences","text":"<p>Cet \u00e9cran permet de configurer les tableaux de bords des vues Activity et Behavior, \u00e0 la fois  les indicateurs/graphes \u00e0 afficher mais \u00e9galement diff\u00e9rentes options de pr\u00e9sentations : diagrammes en 3D, lissage des courbes, etc.</p> <p>Une action permet \u00e0 l'utilisateur de sauvegarder ses pr\u00e9f\u00e9rences.</p>"},{"location":"fr/user/studio/analytics/#continuer","title":"Continuer...","text":"<p>Rendez-vous dans Menu Model Quality pour la suite du manuel utilisateur. </p> <p>Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement. </p>"},{"location":"fr/user/studio/configuration/","title":"Le menu Settings","text":"<p>Le menu Settings permet de cr\u00e9er et param\u00e9trer les applications conversationnelles Tock (c'est-\u00e0-dire les mod\u00e8les / bots pouvant co-exister sur une plateforme). Plusieurs fonctions d'administration et de configuration des  bots sont \u00e9galement disponibles via ce menu : importer/exporter une configuration, param\u00e9trer la langue, les connecteurs, etc.</p>"},{"location":"fr/user/studio/configuration/#longlet-applications","title":"L'onglet Applications","text":"<p>Cet \u00e9cran permet de cr\u00e9er, modifier, supprimer des applications conversationnelles Tock.</p> <p></p> <p>Lors de la premi\u00e8re connexion \u00e0 la plateforme de d\u00e9monstration, un assistant simplifi\u00e9 permet de cr\u00e9er la premi\u00e8re application (le premier bot). Par la suite, vous pouvez passer par  cet \u00e9cran pour ajouter d'autres applications.</p>"},{"location":"fr/user/studio/configuration/#creer-une-application","title":"Cr\u00e9er une application","text":"<p>Pour ajouter une application, cliquez sur Create New Application :</p> <ul> <li> <p>Saisissez un nom / identifiant pour l'application</p> </li> <li> <p>Choisissez si le mod\u00e8le pourra inclure des entit\u00e9s voire des sous-entit\u00e9s (cf Concepts pour en savoir plus)</p> </li> <li> <p>S\u00e9lectionnez une ou plusieurs langues (voir Construire un bot multilingue pour en savoir plus)</p> </li> <li> <p>S\u00e9lectionnez un moteur NLU (Apache OpenNLP ou Stanford CoreNLP,  voir Installation pour en savoir plus)</p> </li> </ul>"},{"location":"fr/user/studio/configuration/#modifier-importer-et-exporter-une-application","title":"Modifier, importer et exporter une application","text":"<p>Pour chaque application d\u00e9j\u00e0 cr\u00e9\u00e9e, vous pouvez par la suite :</p> <ul> <li> <p>Download an application dump : t\u00e9l\u00e9charger sa configuration au format JSON : langue, mod\u00e8le intentions/entit\u00e9s, etc.</p> </li> <li> <p>Download a sentences dump : t\u00e9l\u00e9charger ses phrases qualifi\u00e9es au format JSON</p> </li> <li> <p>Edit : modifier la configuration de l'application</p> <ul> <li>Un formulaire permet de modifier la configuraion initiale</li> <li>Une section Advanced options ajoute d'autres param\u00e8tres pour les utilisateurs avertis :<ul> <li>Upload dump : charger une configuration ou des phrases qualifi\u00e9es \u00e0 partir d'un fichier au format JSON. Seules les nouvelles intentions/phrases seront ajout\u00e9es, cette fonction ne modifie pas / ne supprime pas  les intentions/phrases existantes</li> <li>Trigger build : d\u00e9clencher/forcer la reconstruction du mod\u00e8le</li> <li>NLU Engine configuration : param\u00e9trer finement le moteur NLU sous-jacent (les param\u00e8tres d\u00e9pendant du moteur utilis\u00e9, Apache OpenNLP ou Stanford CoreNLP)</li> <li>Alexa Export : exporter le mod\u00e8le Tock dans un format utilisable par Alexa</li> </ul> </li> </ul> </li> </ul> <p></p> <p>La fonction Upload dump (voir ci-dessus) est \u00e9galement accessible directement en bas d'\u00e9cran, permettant :</p> <ul> <li>Soit de modifier une application (si l'<code>application name</code> existe)</li> <li>Soit d'en cr\u00e9er/importer une nouvelle</li> </ul>"},{"location":"fr/user/studio/configuration/#longlet-configurations","title":"L'onglet Configurations","text":"<p>Cet \u00e9cran permet d'acc\u00e9der aux connecteurs d'un bot, d'en ajouter, modifier ou supprimer. C'est aussi l\u00e0 que vous trouvez  les informations pour se connecter programmatiquement.</p>"},{"location":"fr/user/studio/configuration/#se-connecter-programmatiquement-au-bot","title":"Se connecter programmatiquement au bot","text":"<p>Le param\u00e9trage pour se connecter au bot programmatiquement (ie. via un programme / langage de programmation)  se trouve dans cet \u00e9cran :</p> <ul> <li> <p>L'API Key peut \u00eatre copi\u00e9e et embarqu\u00e9e dans le code client de la Bot API pour connecter des parcours programm\u00e9s  en Kotlin ou dans un autre langage de programmation comme Javascript/Nodejs ou Python</p> </li> <li> <p>Une adresse / URL peut \u00eatre configur\u00e9e pour utiliser le mode WebHook de Bot API</p> </li> </ul> <p>Pour en savoir plus sur ces param\u00e8tres et le d\u00e9veloppement de parcours, voir Bot API.</p>"},{"location":"fr/user/studio/configuration/#gerer-les-connecteurs","title":"G\u00e9rer les connecteurs","text":"<p>La liste des connecteurs du bot est affich\u00e9e sous la clef d'API. Pour ajouter un connecteur au bot, cliquez sur Create a new Configuration.</p> <p>Tous les connecteurs poss\u00e8dent la configuration suivante :</p> <ul> <li>Configuration name : le nom/identifiant du bot</li> <li>Connector type : le type de canal (par exemple Messenger, Slack, etc.)</li> <li>Connector identifier : un identifiant pour le connecteur, unique pour le bot</li> <li>Relative REST path : un chemin relatif unique pour la plateforme, pour communiquer avec le bot sur ce canal.</li> </ul> <p>Par d\u00e9faut, le chemin est de la forme <code>/io/{organisation}/{application}/{canal}</code> ce qui le rend unique sur la plateforme  (\u00e0 moins que deux connecteurs du m\u00eame type soient d\u00e9clar\u00e9s pour le m\u00eame bot). </p> <p>Chaque connecteur poss\u00e8de \u00e9galement une configuration suppl\u00e9mentaire sp\u00e9cifique \u00e0 ce type de connecteur. Ces param\u00e8tres  sont dans Connector Custom Configuration. Ces param\u00e8tres sp\u00e9cifiques sont document\u00e9s avec chaque type de connecteur/canal,  voir Les connecteurs.</p>"},{"location":"fr/user/studio/configuration/#connecteurs-de-test","title":"Connecteurs de test","text":"<p>Pour chaque connecteur ajout\u00e9 au bot, un connecteur de test est aussi cr\u00e9\u00e9 et configur\u00e9. Il sert \u00e0 \"simuler\" le connecteur lorsqu'on teste le bot directement dans l'interface Tock Studio (menu Test &gt; Test the bot).</p> <p>Par d\u00e9faut, les connecteurs de test ne sont pas affich\u00e9s dans l'\u00e9cran Bot Configurations. Cliquez sur Display test  configurations pour les voir et \u00e9ventuellement les modifier.</p> <p>En particulier, si vous obtenez des messages d'erreur de connexion dans la page Test the bot, n'h\u00e9sitez pas \u00e0  v\u00e9rfier la configuration de test notamment l'adresse Application base url (pour une plateforme d\u00e9ploy\u00e9e avec Docker  Compose par d\u00e9faut, ce devrait \u00eatre <code>http://bot_api:8080</code> avec le nom du conteneur et le port d\u00e9clar\u00e9s  dans le descripteur <code>docker-compose-bot.yml</code>).</p>"},{"location":"fr/user/studio/configuration/#longlet-namespaces","title":"L'onglet Namespaces","text":"<p>Cet \u00e9cran permet de g\u00e9rer un ou plusieurs espaces de nommage ou namespaces. Chaque application, chaque bot est cr\u00e9\u00e9  au sein d'un namespace. Il est possible de g\u00e9rer plusieurs namespaces, et de partager certains d'entre eux avec  une \u00e9quipe ou d'autres utilisateurs Tock Studio. Pour cela, il suffit d'\u00e9diter le namespace et d'ajouter d'autres  utilisateurs (en leur donnant plus ou moins de droits sur le namespace).</p>"},{"location":"fr/user/studio/configuration/#longlet-log","title":"L'onglet Log","text":"<p>Cette vue permet de suivre les principales modifications de configuration applicative effectu\u00e9es  par les utilisateurs via Tock Studio: cr\u00e9ation d'applications, modifications des connecteurs, imports, etc.</p>"},{"location":"fr/user/studio/configuration/#continuer","title":"Continuer...","text":"<p>Rendez-vous dans Menu FAQ Training pour la suite du manuel utilisateur. </p> <p>Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement. </p>"},{"location":"fr/user/studio/custom-metrics/","title":"Le menu Custom Metrics","text":"<p>Le menu Custom Metrics permet de cr\u00e9er et visualiser des statistiques de consultation et d'usage des stories Tock. Il est destin\u00e9 \u00e0 un public m\u00e9tier qui souhaite monitorer la performance des stories (faqs, sc\u00e9narios...) au sein d'une application Tock.</p> <p>Pour acc\u00e9der \u00e0 cette page il faut b\u00e9n\u00e9ficier du r\u00f4le botUser.</p>"},{"location":"fr/user/studio/custom-metrics/#onglet-metrics","title":"Onglet Metrics","text":"<p>Cette page permet d'afficher un certain nombre de statistiques orient\u00e9es m\u00e9tiers (\u00e0 la diff\u00e9rence du menu Analytics dont les statistiques portent sur des crit\u00e8res techniques).</p> <p>Les statistiques sont affich\u00e9es pour une p\u00e9riode donn\u00e9e, sp\u00e9cifiable \u00e0 l'aide du champ propos\u00e9 en d\u00e9but de page. Sur sa droite, un ensemble de raccourcis permettent de d\u00e9finir cette p\u00e9riode en un clic (3 derniers jours, 7 derniers jours, 30 derniers jours et 3 derniers mois).</p> <p>Viennent ensuite, pour la p\u00e9riode choisie, les statistiques suivantes :</p> <ul> <li>Nombre de messages utilisateurs</li> <li>Nombre de r\u00e9ponses apport\u00e9es par le bot</li> <li>Nombre de questions non comprises par le bot</li> <li>Taux de r\u00e9ponse du bot</li> </ul> <p></p> <p>Pour pouvoir obtenir des statistiques fiables et correctement ventil\u00e9es, il est n\u00e9cessaire de cr\u00e9er une story de type unknown (cf. section Cr\u00e9er une story Unknown).</p>"},{"location":"fr/user/studio/custom-metrics/#section-number-of-user-messages","title":"Section Number of user messages","text":"<p>Ce graphique affiche le nombre de messages utilisateurs par jour pour la p\u00e9riode demand\u00e9e</p>"},{"location":"fr/user/studio/custom-metrics/#section-distribution-of-stories","title":"Section Distribution of stories","text":"<p>Ce graphique affiche la r\u00e9partition des stories d\u00e9clench\u00e9es \u00e0 la suite des questions utilisateurs. Le survol des entr\u00e9es du graphique permet d'obtenir le nombre de fois ou la story a \u00e9t\u00e9 d\u00e9clench\u00e9e ainsi que le la part prise par cette story dans le nombre total des stories d\u00e9clench\u00e9es pour la p\u00e9riode demand\u00e9e.</p> <p>Si le nombre de stories \u00e0 afficher d\u00e9passe un certain seuil, une cat\u00e9gorie Other stories sera affich\u00e9e r\u00e9unissant les stories ayant enregistr\u00e9 les plus faibles taux de d\u00e9clenchement.</p> <p>Un clic sur n'importe laquelle des entr\u00e9es du graphique permet d'ouvrir une fen\u00eatre affichant ces m\u00eames statistiques sous forme de liste d\u00e9taill\u00e9e (et d'afficher \u00e9ventuellement le d\u00e9tail des Other stories)</p> <p>A la droite du titre de section, un menu d\u00e9roulant permet de filtrer les stories affich\u00e9es par type et/ou cat\u00e9gorie. Il permet \u00e9galement d'afficher les stories metrics qui ne sont pas list\u00e9es par d\u00e9faut.</p>"},{"location":"fr/user/studio/custom-metrics/#section-indicators","title":"Section Indicators","text":"<p>Les indicateurs, associ\u00e9s \u00e0 des metrics stories, permettent d'enregistrer des retours des utilisateurs, g\u00e9n\u00e9ralement dans le cadre d'une story de satisfaction ou d'un sondage. Pour plus d'informations sur la cr\u00e9ation d'indicateurs et leur assignation \u00e0 des metrics stories, r\u00e9f\u00e9rez vous aux sections Indicators et Metrics Stories</p> <p>Une liste d\u00e9roulante \u00e0 la droite du titre de section permet de s\u00e9lectionner la dimension d'indicateurs \u00e0 afficher. Une dimension est une r\u00e9union d'indicateurs (cf. Onglet Indicators).</p> <p>Pour chaque indicateur de la dimension choisie, un graphique affiche la r\u00e9partition des r\u00e9ponses apport\u00e9es par les utilisateurs. La section grise No answer given correspond au nombre de fois o\u00f9 un utilisateur n'a pas r\u00e9pondu \u00e0 la question pos\u00e9e. Le survol des portions du graphique permet d'afficher le nombre de r\u00e9ponses fournies pour chaque option d'indicateur ainsi que le pourcentage repr\u00e9sent\u00e9 de l'ensemble des fois o\u00f9 la question correspondante \u00e0 \u00e9t\u00e9 pos\u00e9e.</p> <p>Pour chaque graphique, un bouton Detail by story est propos\u00e9. Detail by story affiche une fen\u00eatre r\u00e9unissant les graphiques des r\u00e9ponses apport\u00e9es \u00e0 cet indicateur par story.</p>"},{"location":"fr/user/studio/custom-metrics/#onglet-indicators-indicators-tab","title":"Onglet Indicators {#indicators-tab}","text":"<p>Les Indicators servent \u00e0 mesurer la satisfaction utilisateur ou \u00e0 r\u00e9aliser des sondages.</p> <p>Un indicateur correspond g\u00e9n\u00e9ralement \u00e0 une question qui sera pos\u00e9e aux utilisateurs apr\u00e8s l'ex\u00e9cution d'une story. Il r\u00e9unit une ou plusieurs valeurs correspondant aux r\u00e9ponses possibles \u00e0 cette question.</p> <p>Une fois d\u00e9finis, les indicateurs pourront \u00eatre associ\u00e9s \u00e0 des Actions de Metric story. La Metric story pourra \u00e0 son tour \u00eatre d\u00e9finie comme story de satisfaction de vos Faqs ou autres types de stories. Pour plus d'informations sur la d\u00e9finition de Metric story, r\u00e9f\u00e9rez vous \u00e0 la section Metrics Stories.</p> <p>Cette page liste l'ensemble des indicateurs existants.</p> <p>Un indicateur se compose des \u00e9l\u00e9ments suivants :</p> <ul> <li>Son label</li> <li>La dimension \u00e0 laquelle il appartient</li> <li>Ses valeurs possibles</li> </ul> <p>Un indicateur doit n\u00e9cessairement appartenir \u00e0 au moins une dimension mais un m\u00eame indicateur peut appartenir \u00e0 plusieurs dimensions diff\u00e9rentes. Les dimensions sont de simples regroupements d'indicateurs facilitant leur manipulation et leur consultation.</p> <p>Les actions suivantes sont disponibles pour chaque indicateur :</p> <ul> <li>Edit : permet de modifier les attributs de l'indicateur (label, description, dimensions, valeurs)</li> <li>Delete : permet de supprimer l'indicateur. A noter que la suppression d'un indicateur interdira la consultation des statistiques enregistr\u00e9es pour cet indicateur.</li> </ul>"},{"location":"fr/user/studio/custom-metrics/#creation-dun-indicateur","title":"Cr\u00e9ation d'un indicateur","text":"<p>Vous pouvez cr\u00e9er un nouvel indicateur en cliquant sur le bouton + New Indicator en haut \u00e0 droite de la page. Cela ouvre un panneau dans lequel vous pouvez d\u00e9finir :</p> <ul> <li>Le label de l'indicateur</li> <li>Une description (optionnelle)</li> <li>Une ou plusieurs dimensions auxquelles l'indicateur sera rattach\u00e9</li> <li>Une ou plusieurs valeurs qu'est susceptible de porter l'indicateur</li> </ul> <p>Par exemple, nous pouvons imaginer un indicateur \"Satisfaction\" qui porte les valeurs \"Satisfait\" et \"Non satisfait\".</p> <p>A noter que le nom de l'indicateur et ses valeurs ne seront pas directement affich\u00e9s aux utilisateurs. Les phrases de questions et r\u00e9ponses seront d\u00e9finies au niveau des actions de la Metric story que vous serez amen\u00e9s \u00e0 cr\u00e9er \u00e0 l'\u00e9tape suivante. Vous pouvez donc choisir un label et des valeurs simples qui faciliterons leur manipulation.</p> <p>A titre d'exemple, nous pouvons imaginer une dimension qui r\u00e9unit les indicateurs et valeurs suivantes :</p> <ul> <li>DIMENSION : Satisfaction</li> <li>INDICATEUR : Satisfaction globale<ul> <li>VALEUR : Satisfait</li> <li>VALEUR : Non satisfait</li> </ul> </li> <li>INDICATEUR : Motif d'insatisfaction<ul> <li>VALEUR : Question non comprise</li> <li>VALEUR : R\u00e9ponse incorrecte</li> </ul> </li> <li>INDICATEUR : Action insatisfaction<ul> <li>VALEUR : Rediriger vers un humain</li> <li>VALEUR : Reformuler ma question</li> </ul> </li> </ul> <p>Sur la base de cet ensemble d'indicateurs, nous pourrons configurer une Metric story posant un ensemble de questions aux utilisateurs et enregistrant leurs r\u00e9ponses dans l'objectif d'am\u00e9liorer notre Bot (cf. Metrics Stories).</p>"},{"location":"fr/user/studio/custom-metrics/#filtres","title":"Filtres","text":"<p>Il est possible de rechercher des indicateurs en saisissant du texte dans le champ Search.</p> <p>Il est \u00e9galement possible de filtrer la liste des indicateurs en s\u00e9lectionnant une ou plusieurs dimensions dans la liste d\u00e9roulante.</p>"},{"location":"fr/user/studio/custom-metrics/#creer-une-story-unknown-create-unknown-story","title":"Cr\u00e9er une Story Unknown {#create-unknown-story}","text":"<p>De fa\u00e7on \u00e0 distinguer explicitement les questions utilisateurs non comprises par le bot, il est n\u00e9cessaire de cr\u00e9er une story unknown. Cette story sera retourn\u00e9e par le bot dans les cas o\u00f9 il n'a pas identifi\u00e9 d'intent correspondant aux questions utilisateurs. La story unknown permet en outre de pr\u00e9voir un message \u00e0 afficher \u00e0 l'utilisateur dans le cas o\u00f9 sa question n'a pas \u00e9t\u00e9 comprise.</p> <p>Pour cr\u00e9er une story unknown, rendez vous sur Stories &amp; Answers dans le menu principal et acc\u00e9dez \u00e0 l'onglet New story. Dans le champ propos\u00e9, donnez un nom \u00e0 votre story unknown (par exemple <code>story unknown</code>) et cliquez sur le bouton add. Sur la page qui appara\u00eet, cliquez sur le bouton Edit story.</p> <p></p> <p>Une fen\u00eatre s'ouvre. Dans le champ Intent saisissez la cha\u00eene de caract\u00e8res <code>unknown</code> et cliquez sur Save. Dans la section Answers saisissez la r\u00e9ponse \u00e0 retourner aux utilisateurs lorsque leur question n'a pas \u00e9t\u00e9 comprise, puis cliquez sur Create story.</p>"},{"location":"fr/user/studio/custom-metrics/#metrics-stories-metrics-stories","title":"Metrics Stories {#metrics-stories}","text":"<p>Une fois d\u00e9finis, les indicateurs doivent \u00eatre associ\u00e9s aux actions d'une story pour pouvoir \u00eatre d\u00e9clench\u00e9s par les utilisateurs et ainsi donner lieu \u00e0 l'enregistrement d'un hit.</p>"},{"location":"fr/user/studio/custom-metrics/#creation-dune-metrics-story-de-satisfaction","title":"Cr\u00e9ation d'une Metrics Story de satisfaction","text":"<p>Depuis le menu principal, acc\u00e9dez \u00e0 Stories &amp; Answers puis \u00e0 l'onglet New story. Dans le champ propos\u00e9, saisissez le nom de votre story de satisfaction (par exemple <code>Story satisfaction</code>) puis validez. Dans le champ Answer, saisissez une invite utilisateur (par exemple <code>Etes-vous satisfait de la r\u00e9ponse apport\u00e9e ?</code>)</p> <p>Dans la section Actions, ajoutez une premi\u00e8re action \u00e0 l'aide du bouton + Add action :</p> <p>D\u00e9finissez la User phrase de l'action (par exemple <code>Oui</code>). Indiquez un nom d'Intent pour l'action (par exemple <code>satisfaction_ok</code>). Une fen\u00eatre s'affiche pour valider la cr\u00e9ation de l'intent. Validez en cliquant sur le bouton Create. Saisissez une r\u00e9ponse \u00e0 l'aide du champ Answer de l'action (par exemple <code>Je suis ravi d'avoir pu vous aider</code>). Dans la liste Indicators, s\u00e9lectionnez la valeur de l'indicateur pr\u00e9vu \u00e0 cet effet (dans notre exemple, <code>Satisfaction globale : Satisfait</code>).</p> <p></p> <p>R\u00e9p\u00e9tez l'op\u00e9ration pour l'action \"Non satisfait\" :</p> <p>Dans la section Actions, ajoutez une deuxi\u00e8me action \u00e0 l'aide du bouton + Add action. D\u00e9finissez la User phrase de l'action (par exemple <code>Non</code>). Indiquez un nom d'Intent pour l'action (par exemple <code>satisfaction_nok</code>). Saississez une r\u00e9ponse \u00e0 l'aide du champ Answer (par exemple <code>Pouvez-vous pr\u00e9ciser le probl\u00e8me rencontr\u00e9 ?</code>). Dans la liste Indicators, s\u00e9lectionnez la valeur de l'indicateur pr\u00e9vu \u00e0 cet effet (dans notre exemple, <code>Satisfaction globale : Non satisfait</code>).</p> <p></p> <p>Vous allez maintenant pouvoir d\u00e9finir les Actions \u00e0 proposer aux utilisateurs qui ont r\u00e9pondu <code>Non</code> \u00e0 la question initiale :</p> <p>A l'aide de la souris, survolez la deuxi\u00e8me action cr\u00e9\u00e9e portant la user phrase <code>Non</code>. Un menu contextuel appara\u00eet en partie basse de l'action. Cliquez sur Add action. D\u00e9pliez l'action \u00e0 l'aide du chevron apparu \u00e0 gauche de celle-ci.</p> <p>D\u00e9finissez la User phrase de l'action (par exemple <code>Ma question a \u00e9t\u00e9 mal comprise</code>). Indiquez un nom d'Intent pour l'action (par exemple <code>satisfaction_questionmalcomprise</code>). Saisissez une r\u00e9ponse \u00e0 l'aide du champ Answer (par exemple <code>Merci pour votre aide. Souhaitez-vous essayer de reformuler votre question ou \u00eatre mis en relation avec un conseiller ?</code>). Dans la liste Indicators, s\u00e9lectionnez la valeur de l'indicateur pr\u00e9vu \u00e0 cet effet (dans notre exemple, <code>Satisfaction globale : question non comprise</code>).</p> <p></p> <p>Poursuivez les op\u00e9rations d\u00e9crites ci-dessus jusqu'\u00e0 avoir enti\u00e8rement d\u00e9fini votre story de satisfaction en fonction des indicateurs voulus.</p> <p>Maintenant que vous avez assign\u00e9 au moins un indicateur \u00e0 une action, vous avez la possibilit\u00e9 de marquer cette story comme Metric story gr\u00e2ce au commutateur situ\u00e9 en haut \u00e0 droite de la section Actions.</p> <p></p> <p>Vous pouvez d\u00e9sormais valider la cr\u00e9ation de la Metric story en cliquant sur le bouton Create story en bas de page.</p> <p>Une story marqu\u00e9e comme Metric story permet d'enregistrer la satisfaction pour la story pr\u00e9c\u00e9demment d\u00e9clench\u00e9e par l'utilisateur. Une Metric story doit donc \u00eatre d\u00e9finie comme story de redirection de stories m\u00e9tier. Les indicateurs enregistr\u00e9s suite aux r\u00e9ponses des utilisateurs feront donc r\u00e9f\u00e9rence \u00e0 la story qui a \u00e9t\u00e9 ex\u00e9cut\u00e9e juste avant le d\u00e9clenchement de la Metric story. Si des indicateurs sont associ\u00e9s aux actions d'une story non marqu\u00e9e comme Metric story, les statistiques enregistr\u00e9es ne porteront que sur la story portant ces actions.</p>"},{"location":"fr/user/studio/custom-metrics/#definition-dune-metric-story-comme-story-de-redirection","title":"D\u00e9finition d'une Metric Story comme story de redirection","text":"<p>Pour d\u00e9finir une Metric Story comme story de redirection de l'ensemble vos Faqs, rendez-vous, \u00e0 l'aide du menu principal, sur l'entr\u00e9e Faq Management. Cliquez sur l'ic\u00f4ne <code>Faq parameters</code> en haut \u00e0 droite de la page.</p> <p></p> <p>Activez la case \u00e0 cocher Ask for satisfaction after answering on FAQ question puis s\u00e9lectionnez la Metric story pr\u00e9c\u00e9demment cr\u00e9\u00e9e.</p> <p></p> <p>Cliquez sur le bouton Save.</p> <p>D\u00e9sormais, apr\u00e8s chaque ex\u00e9cution d'une story de type Faq, la story \"Story satisfaction\" sera d\u00e9clench\u00e9e et permettra de demander aux utilisateurs un retour d'exp\u00e9rience.</p> <p>Pour un r\u00e9glage plus fin des stories donnant lieu \u00e0 une redirection, rendez-vous sur Stories &amp; Answers, onglet Rules</p>"},{"location":"fr/user/studio/faq-management/","title":"Le menu FAQ Management","text":"<p>Le menu FAQ Management permet de cr\u00e9er, modifier et enrichir les mod\u00e8les conversationnels avec des questions de type Foire Aux Questions (Questions/R\u00e9ponses avec simple texte). Il est destin\u00e9 \u00e0 un public m\u00e9tier non familier avec les concepts conversationnels (intentions, entit\u00e9s...).</p> <p>Pour acc\u00e9der \u00e0 cette page il faut b\u00e9n\u00e9ficier du r\u00f4le botUser ( plus de d\u00e9tails sur les r\u00f4les dans securit\u00e9 ).</p>"},{"location":"fr/user/studio/faq-management/#liste-des-faq","title":"Liste des FAQ","text":"<p>Cette page liste l'ensemble des FAQ existantes (avec pagination)</p> <p></p> <p>Pour chaque FAQ vous pouvez retrouver les \u00e9l\u00e9ments suivants :</p> <ul> <li>Son nom</li> <li>Le nombre de questions associ\u00e9es</li> <li>Un exemple de question</li> <li>Un extrait de la r\u00e9ponse retourn\u00e9e</li> <li>Un ensemble de tags</li> </ul> <p>Les actions suivantes sont disponibles pour chaque FAQ :</p> <ul> <li>Enable/Disable : permet de d\u00e9sactiver une FAQ. Une fois d\u00e9sactiv\u00e9e, le bot n'enverra plus la r\u00e9ponse associ\u00e9e mais la r\u00e9ponse par d\u00e9faut unknown</li> <li>Edit : permet de modifier les \u00e9l\u00e9ments de la FAQ (nom, description, tags, questions, r\u00e9ponse)</li> <li>Download : permet de t\u00e9l\u00e9charger la description de la FAQ au format JSON</li> <li>Delete : permet de supprimer la FAQ. A noter que l'intention sous-jacente sera elle aussi supprim\u00e9e. Les questions seront toutefois remis\u00e9es dans l'Inbox.</li> </ul>"},{"location":"fr/user/studio/faq-management/#creation-dune-nouvelle-faq","title":"Cr\u00e9ation d'une nouvelle FAQ","text":"<p>Vous pouvez cr\u00e9er de nouvelles questions de FAQ en cliquant sur le bouton + New FAQ. Cela ouvre un panneau compos\u00e9 de 3 onglets.</p> <p>Une Story Simple est automatiquement cr\u00e9\u00e9e \u00e0 la cr\u00e9ation d'une FAQ et lui est associ\u00e9e.</p>"},{"location":"fr/user/studio/faq-management/#onglet-info","title":"Onglet INFO","text":"<p>Vous pouvez dans cet onglet :</p> <ul> <li>D\u00e9finir le nom de la FAQ</li> <li>Donner une description pour expliquer \u00e0 quoi elle r\u00e9pond</li> <li>Ajouter des tags afin de pouvoir regrouper des FAQ par th\u00e9matique</li> </ul> <p>Le nom de la faq est utilis\u00e9 pour g\u00e9n\u00e9rer l'intention sous-jacente qui y sera associ\u00e9e</p>"},{"location":"fr/user/studio/faq-management/#onglet-question","title":"Onglet QUESTION","text":"<p>Dans cet onglet vous pouvez ajouter autant de questions que n\u00e9cessaire afin d'alimenter le mod\u00e8le. Ces questions seront associ\u00e9e \u00e0 l'intention sous-jacente \u00e0 la FAQ. Il est conseill\u00e9 d'avoir un minimum de 10 questions avec des formulations vari\u00e9es afin que le mod\u00e8le puisse avoir un taux de reconnaissance minimal.</p>"},{"location":"fr/user/studio/faq-management/#onglet-answer","title":"Onglet ANSWER","text":"<p>Dans cet onglet vous allez pouvoir d\u00e9finir la r\u00e9ponse qui devra \u00eatre envoy\u00e9e \u00e0 l'utilisateur lorsque sa question est y fait r\u00e9f\u00e9rence. La r\u00e9ponse est limit\u00e9e \u00e0 un format texte pouvant contenir du markdown sous r\u00e9serve que l'interface de restitution le prenne en charge.</p>"},{"location":"fr/user/studio/faq-management/#filtres","title":"Filtres","text":"<p>Il est possible de rechercher des phrases \u00e0 qualifier en saisissant du texte dans le champ Search.</p> <p>Il est \u00e9galement possible de filtrer la liste des FAQ en s\u00e9lectionnant un ou plusieurs tags dans la liste d\u00e9roulante.</p> <p>Vous pouvez enfin filtrer les FAQ en limitant l'affichage \u00e0 celles qui sont actives/inactives/toutes en utilisant la case \u00e0 cocher Active.</p>"},{"location":"fr/user/studio/faq-management/#configuration","title":"Configuration","text":"<p>Il est possible de configurer une Story par d\u00e9faut qui sera ex\u00e9cut\u00e9e \u00e0 la suite de l'envoi de la r\u00e9ponse de la FAQ afin de collecter la satisfaction de l'utilisateur sur la qualit\u00e9 de la r\u00e9ponse apport\u00e9e.</p> <p>Une Rule de type Ending est automatiquement cr\u00e9\u00e9e et associ\u00e9e \u00e0 la Story associ\u00e9e \u00e0 la FAQ</p> <p></p> <p>Cocher la case Ask for satisfaction after answering on FAQ question pour activer cette fonctionnalit\u00e9. Choisir une Story dans la liste d\u00e9roulante Select story.</p> <p>Une Rule de type Activation sera automatiquement cr\u00e9\u00e9e pour chaque FAQ</p>"},{"location":"fr/user/studio/faq-management/#continuer","title":"Continuer...","text":"<p>Rendez-vous dans Guides utilisateur pour la suite du manuel utilisateur.</p> <p>Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement.</p>"},{"location":"fr/user/studio/faq-training/","title":"Le menu FAQ Training","text":"<p>Le menu FAQ Training permet d'enrichir les mod\u00e8les conversationnels en associant les phrases utilisateur avec des questions de FAQ. Il est destin\u00e9 \u00e0 un public m\u00e9tier non familier avec les concepts conversationnels (intentions, entit\u00e9s...).</p> <p>Pour acc\u00e9der \u00e0 cette page il faut b\u00e9n\u00e9ficier du r\u00f4le nlpUser. ( plus de d\u00e9tails sur les r\u00f4les dans securit\u00e9 ).</p> <p>Cete page liste l'ensemble des phrases re\u00e7ues par le mod\u00e8le NLU avec les faq/scores d\u00e9tect\u00e9s.</p> <p>Ces phrases peuvent provenir de v\u00e9ritables utilisateurs quels que soient les canaux, d'une saisie dans l'onglet Try it  ou encore d'une conversation via la page Test the bot dans Tock Studio.</p>"},{"location":"fr/user/studio/faq-training/#qualification-des-phrases","title":"Qualification des phrases","text":"<p>Les actions suivantes sont disponibles pour qualifier les phrases :</p> <ul> <li>Create New FAQ : cr\u00e9er une nouvelle question de FAQ en ajoutant automatiquement la phrase s\u00e9lectionn\u00e9e dans la liste des questions associ\u00e9es</li> <li>Validate : confirmer la faq d\u00e9tect\u00e9e par le mod\u00e8le et enregistrer la phrase dans ce dernier (provoquant in fine une reconstruction du mod\u00e8le)</li> <li>Unknown : qualifier la phrase en intention inconnue (r\u00e9ponse par d\u00e9faut) </li> <li>Delete : supprimer la phrase (action irr\u00e9versible)</li> <li>Details: afficher le d\u00e9tail du dialogue dans lequel la phrase a \u00e9t\u00e9 d\u00e9tect\u00e9e</li> </ul> <p></p>"},{"location":"fr/user/studio/faq-training/#filtres","title":"Filtres","text":"<p>Il est possible de rechercher des phrases \u00e0 qualifier en saisissant du texte dans le champ Search.</p> <p>Il est possible d'afficher les phrases associ\u00e9es \u00e0 l'intention unknown en activant le bouton Unknown.</p>"},{"location":"fr/user/studio/faq-training/#continuer","title":"Continuer...","text":"<p>Rendez-vous dans Menu FAQ Management pour la suite du manuel utilisateur. </p> <p>Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement. </p>"},{"location":"fr/user/studio/general/","title":"L'interface Tock Studio","text":"<p>Cette page pr\u00e9sente les caract\u00e9ristiques g\u00e9n\u00e9rales de Tock Studio.</p> <p>Les pages suivantes couvrent les diff\u00e9rents menus de l'application et diff\u00e9rentes fonctionnalit\u00e9s.</p>"},{"location":"fr/user/studio/general/#connexion-a-lapplication","title":"Connexion \u00e0 l'application","text":"<p>Un navigateur standard suffit pour acc\u00e9der \u00e0 Tock Studio. L'utilisateur est invit\u00e9 \u00e0 s'authentifier :</p> <ul> <li> <p>Sur la plateforme Tock de d\u00e9monstration,  l'utilisateur est invit\u00e9 \u00e0 s'authentifier via son compte GitHub. Celui-ci doit alors accepter que Tock acc\u00e8de  \u00e0 son compte - seul l'identifiant du compte GitHub est lu par Tock.</p> </li> <li> <p>Sur une plateforme Tock par d\u00e9faut, les identifiants sont <code>admin@app.com</code> / <code>password</code>.Les identifiants par d\u00e9faut  sont d\u00e9finis dans fichier source <code>bot/admin/web/src/environments/environment.ts</code> et il est recommand\u00e9 de les modifier.</p> </li> </ul> <p>Il est aussi possible, en alternative, d'utiliser un m\u00e9canisme d'authentification en amont de l'application, par exemple via  un service Apache HTTPd ou un service cloud comme AWS Cognito  d'une part et un annuaire type LDAP d'autre part.</p>"},{"location":"fr/user/studio/general/#le-bandeau-applicatif","title":"Le bandeau applicatif","text":"<p>En haut \u00e0 gauche de l'interface se trouvent :</p> <ul> <li> <p>Un bouton permettant d'afficher (ou de masquer) les diff\u00e9rents menus Tock Studio</p> </li> <li> <p>Le nom de l'interface</p> </li> </ul> <p>En haut \u00e0 droite de l'interface se trouvent :</p> <ul> <li> <p>L'application / le bot couramment s\u00e9lectionn\u00e9 (utile lorsque plusieurs bots co-existent sur la plateforme)</p> </li> <li> <p>La langue couramment s\u00e9lectionn\u00e9e (utile pour tester un bot multilingue)</p> </li> <li> <p>Un lien pour se d\u00e9connecter</p> </li> </ul>"},{"location":"fr/user/studio/general/#continuer","title":"Continuer...","text":"<p>Rendez-vous dans Menu Configuration pour la suite du manuel utilisateur. </p> <p>Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement. </p>"},{"location":"fr/user/studio/nlu-qa/","title":"Le menu Model Quality","text":"<p>Le menu Model Quality (ou NLU QA) permet d'\u00e9valuer et de suivre dans le temps la qualit\u00e9/pertinence/performance des mod\u00e8les conversationnels.</p>"},{"location":"fr/user/studio/nlu-qa/#longlet-model-stats","title":"L'onglet Model Stats","text":"<p>Cet \u00e9cran pr\u00e9sente des graphes pour suivre l'\u00e9volution de plusieurs indicateurs de la qualit\u00e9 du mod\u00e8le conversationnel :</p> <ul> <li> <p>Pertinence : les scores des algorithmes de d\u00e9tection sur les intentions (Intent average probability)  et sur les entit\u00e9s (Entity average probability)</p> </li> <li> <p>Trafic / erreurs : le nombre de sollicitations du mod\u00e8le (Calls) et le nombre d'erreurs (Errors)</p> </li> <li> <p>Performance : le temps de r\u00e9ponse du mod\u00e8le (Average call duration)</p> </li> </ul> <p></p>"},{"location":"fr/user/studio/nlu-qa/#longlet-intent-distance","title":"L'onglet Intent Distance","text":"<p>Les m\u00e9triques pr\u00e9sent\u00e9es en tableau dans cet page (Occurrences et Average Diff) permettent d'identifier les intentions  plus ou moins proches dans le mod\u00e8le, notamment afin d'optimiser la mod\u00e9lisation. </p>"},{"location":"fr/user/studio/nlu-qa/#longlet-model-builds","title":"L'onglet Model Builds","text":"<p>Cet \u00e9cran pr\u00e9sente des statistiques sur les derni\u00e8res reconstructions du mod\u00e8le. Il s'agit donc d'indications sur  la performance du mod\u00e8le.</p>"},{"location":"fr/user/studio/nlu-qa/#longlet-tests-trends","title":"L'onglet Tests Trends","text":"<p>Les tests partiels de mod\u00e8le constituent un moyen classique de d\u00e9tecter les erreurs de qualification, ou les probl\u00e8mes de proximit\u00e9 des intentions (ou entit\u00e9s) entre elles.</p> <p>Il s'agit de prendre une partie du mod\u00e8le actuelle au hasard (par exemple 90% des phrases du mod\u00e8le) afin de construire un mod\u00e8le l\u00e9g\u00e8rement moins pertinent, puis de tester les 10% restant avec ce nouveau mod\u00e8le.</p> <p>Le principe pos\u00e9, il ne reste plus qu'\u00e0 r\u00e9p\u00e9ter le processus un certain nombre de fois pour que les erreurs les plus fr\u00e9quentes soient pr\u00e9sent\u00e9es \u00e0 un correcteur manuel.</p> <p>Pr\u00e9cision que ces tests ne pr\u00e9sentent une utilit\u00e9 qu'avec des mod\u00e8les d\u00e9j\u00e0 cons\u00e9quents.</p> <p>Cet onglet donne l'\u00e9volution de la pertinence des tests partiels de mod\u00e8le.</p> <p>Par d\u00e9faut, les tests sont programm\u00e9s pour \u00eatre lanc\u00e9s de minuit \u00e0 5h du matin, toutes les 10 minutes. Il est possible de configurer ce comportement avec la propri\u00e9t\u00e9 <code>tock_test_model_timeframe</code> (par d\u00e9faut : <code>0,5</code>).</p>"},{"location":"fr/user/studio/nlu-qa/#longlet-test-intent-errors","title":"L'onglet Test Intent Errors","text":"<p>Cet \u00e9cran pr\u00e9sente les r\u00e9sultats des tests partiels de d\u00e9tection d'intentions (voir ci-dessus), avec le d\u00e9tails des  phrases/expressions reconnues diff\u00e9remment du mod\u00e8le r\u00e9el.</p> <p></p> <p>Dans cet exemple, aucune \"vraie\" erreur n'a \u00e9t\u00e9 d\u00e9tect\u00e9e. On peut toutefois constater que dans certains cas le mod\u00e8le  se trompe syst\u00e9matiquement, avec une probabilit\u00e9 \u00e9lev\u00e9e.</p> <p>Pour chaque phrase il est possible via la colonne Actions de confirmer que le mod\u00e8le de base est correct (avec  Validate Intent) ou de corriger l'erreur d\u00e9tect\u00e9e (Change The Intent).</p> <p>Il est int\u00e9ressant d'analyser p\u00e9riodiquement ces \u00e9carts, certaines diff\u00e9rences s'expliquant bien, \u00e9tant m\u00eame  parfois \"assum\u00e9es\" (faux n\u00e9gatifs), d'autres pouvant r\u00e9veler un probl\u00e8me dans le mod\u00e8le.</p>"},{"location":"fr/user/studio/nlu-qa/#longlet-test-entity-errors","title":"L'onglet Test Entity Errors","text":"<p>A l'instar de Intent Test Errors pour les entit\u00e9s, cet \u00e9cran pr\u00e9sente les r\u00e9sultats des tests partiels de d\u00e9tection des entit\u00e9s.</p> <p></p> <p>Il est int\u00e9ressant d'analyser p\u00e9riodiquement ces \u00e9carts, certaines diff\u00e9rences s'expliquant bien, \u00e9tant m\u00eame  parfois \"assum\u00e9es\" (faux n\u00e9gatifs), d'autres pouvant r\u00e9veler un probl\u00e8me dans le mod\u00e8le.</p>"},{"location":"fr/user/studio/nlu-qa/#continuer","title":"Continuer...","text":"<p>Rendez-vous dans Menu Settings pour la suite du manuel utilisateur. </p> <p>Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement. </p>"},{"location":"fr/user/studio/nlu/","title":"Le menu Language Understanding","text":"<p>Le menu Language Understanding (ou NLU) permet de cr\u00e9er, modifier, enrichir les mod\u00e8les conversationnels :  d\u00e9clarer des intentions et des entit\u00e9s, qualifier des phrases, etc. (voir Concepts  pour en savoir plus).</p> <p>Dans cette page, le d\u00e9tail de chaque onglet est pr\u00e9sent\u00e9. Voir aussi Construire les mod\u00e8les conversationnels pour une pr\u00e9sentation plus guid\u00e9e par l'usage.</p>"},{"location":"fr/user/studio/nlu/#longlet-new-sentence","title":"L'onglet New Sentence","text":"<p>Cet \u00e9cran permet d'entrer des phrases et et de v\u00e9rifier quelle intention/entit\u00e9s sont d\u00e9tect\u00e9es.</p> <p>Saisissez une phrase et validez pour voir la d\u00e9tection r\u00e9sultant du mod\u00e8le conversationnel (en pratique : comment le bot  interpr\u00e8te la phrase). S'affichent alors :</p> <ul> <li>Intent : l'intention reconnue</li> <li>Language : la langue d\u00e9tect\u00e9e</li> <li>Le(s) score(s) retourn\u00e9(s) par les algorithmes (selon leur niveau de confiance sur l'intention et  sur les \u00e9ventuelles entit\u00e9s)</li> <li>Le cas \u00e9ch\u00e9ant, chaque entit\u00e9 d\u00e9tect\u00e9e avec son r\u00f4le/type et son score</li> </ul> <p></p> <p>Il est possible de modifier tous les \u00e9l\u00e9ments d\u00e9tect\u00e9s depuis cet \u00e9cran :</p> <ul> <li>Pour modifier l'intention (voire en cr\u00e9er une nouvelle \u00e0 la vol\u00e9e) ou la langue d\u00e9tect\u00e9es, utilisez les champs /  listes de s\u00e9lection sous la phrase </li> <li>Pour supprimer une entit\u00e9, utilisez le bouton \u00e0 c\u00f4t\u00e9 du score de l'entit\u00e9</li> <li>Pour ajouter une entit\u00e9, s\u00e9lectionnez avec la souris un bloc de mots dansla phrase puis pr\u00e9cisez son r\u00f4le/type.</li> </ul> <p></p> <p></p> <p>Remarque : si vous avez activ\u00e9 cette option au niveau de l'application/bot, il est possible de d\u00e9clarer des  sous-entit\u00e9s. Vous en apprendrez plus dans Construire les mod\u00e8les conversationnels.</p> <p>Les boutons et commandes suivantes sont disponibles pour la phrase dans sa globalit\u00e9 :</p> <ul> <li>Delete : supprime la phrase</li> <li>Unknown : qualifier la phrase en intention inconnue (r\u00e9ponse par d\u00e9faut)</li> <li>Validate : confirmer l'intention/entit\u00e9s d\u00e9tect\u00e9es et enregistrer la phrase dans le mod\u00e8le  (provoquant in fine une reconstruction du mod\u00e8le, son corpus \u00e9tant enrichi de cette phrase)</li> </ul> <p>D'autres liens sont accessibles pour afficher les conversations contenant cette phrase, copier le contenu de la  phrase, cr\u00e9er un parcours \u00e0 partir de cette phrase.</p>"},{"location":"fr/user/studio/nlu/#longlet-inbox","title":"L'onglet Inbox","text":"<p>Cet onglet montre (avec de la pagination et quelques options d'affichage) l'ensemble des phrases re\u00e7ues par le mod\u00e8le   NLU avec les intentions/entit\u00e9s/langue/scores d\u00e9tect\u00e9s.</p> <p>Ces phrases peuvent provenir de v\u00e9ritables utilisateurs quelques soient les canaux, d'une saisie dans l'onglet Try it  ou encore d'une conversation via la page Test the bot dans Tock Studio.</p> <p>Lorsque vous faites des tests depuis un canal externe, n'h\u00e9sitez pas \u00e0 cliquer sur le bouton Refresh  (en haut \u00e0 gauche de l'\u00e9cran) pour rafra\u00eechir la liste des phrases.</p> <p>Les boutons et commandes sous chaque phrase sont identiques \u00e0 ceux de l'onglet Try it (voir ci-dessus).</p>"},{"location":"fr/user/studio/nlu/#longlet-search","title":"L'onglet Search","text":"<p>Cet \u00e9cran permet de faire des recherches dans l'ensemble des phrases : Inbox mais aussi phrases qualifi\u00e9es  enregistr\u00e9es dans le mod\u00e8le.</p> <p></p>"},{"location":"fr/user/studio/nlu/#longlet-unknown","title":"L'onglet Unknown","text":"<p>Cet \u00e9cran permet de parcourir les phrases dont l'intention n'a pas \u00e9t\u00e9 reconnue (intention unknown).</p>"},{"location":"fr/user/studio/nlu/#longlet-intents","title":"L'onglet Intents","text":"<p>Cet \u00e9cran permet de g\u00e9rer les intentions.</p>"},{"location":"fr/user/studio/nlu/#longlet-entities","title":"L'onglet Entities","text":"<p>Cet \u00e9cran permet de g\u00e9rer les entit\u00e9s, notamment les notions d'entit\u00e9s partag\u00e9es.</p>"},{"location":"fr/user/studio/nlu/#longlet-logs","title":"L'onglet Logs","text":"<p>Cet \u00e9cran pr\u00e9sente le journal complet des phrases re\u00e7ues et permet de remonter aux conversations (ie. l'ensemble des  phrases re\u00e7ues et r\u00e9ponses du bot pour un utilisateur).</p> <p>Remarque : contrairement \u00e0 la vue Inbox, les Logs montrent les phrases re\u00e7ues m\u00eame lorsqu'elles existent d\u00e9j\u00e0 \u00e0  l'identique dans le mod\u00e8le (dans ce cas, le mod\u00e8le et les algorithmes ne sont m\u00eame pas interrog\u00e9s, la r\u00e9ponse \u00e9tant  connue).</p>"},{"location":"fr/user/studio/nlu/#continuer","title":"Continuer...","text":"<p>Rendez-vous dans Menu Stories &amp; Answers pour la suite du manuel utilisateur. </p> <p>Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement. </p>"},{"location":"fr/user/studio/stories-and-answers/","title":"Le menu Stories and Answers","text":"<p>Le menu permet de construire des parcours et des r\u00e9ponses aux phrases de l'utilisateur.</p> <p>Dans cette page, le d\u00e9tail de chaque onglet est pr\u00e9sent\u00e9. Voir aussi  Cr\u00e9er son premier bot avec Tock Studio pour un exemple de cr\u00e9ation  de parcours ou Construire un bot multilingue pour l'utilisation de l'onglet Answers.</p>"},{"location":"fr/user/studio/stories-and-answers/#longlet-new-story","title":"L'onglet New Story","text":""},{"location":"fr/user/studio/stories-and-answers/#creer-une-reponse-simple","title":"Cr\u00e9er une r\u00e9ponse simple","text":"<p>Le guide Cr\u00e9er son premier bot avec Tock Studio pr\u00e9sente   un exemple de cr\u00e9ation de parcours avec une r\u00e9ponse simple via New Story.</p> <p>L'onglet Test &gt; Test the bot permet ensuite de rapidement v\u00e9rifier le comportement du bot sur ce parcours.</p> <p></p>"},{"location":"fr/user/studio/stories-and-answers/#creer-des-reponses-complexes","title":"Cr\u00e9er des r\u00e9ponses complexes","text":"<p>Il est possible d'indiquer plusieurs r\u00e9ponses et \u00e9galement des r\u00e9ponses \"riches\" appel\u00e9es Media Message.</p> <p>Cela permet, quel que soit le canal d'afficher des images, des titres, des sous-titres et des boutons d'action.</p>"},{"location":"fr/user/studio/stories-and-answers/#entites-obligatoires","title":"Entit\u00e9s obligatoires","text":"<p>Il est possible, avant d'afficher la r\u00e9ponse principale, de v\u00e9rifier si certaines entit\u00e9es sont renseign\u00e9es, et si ce n'est pas le cas, d'afficher la question ad\u00e9quate.</p> <p>L'option correspondante est appell\u00e9e Mandatory Entities.</p> <p>Par exemple, supposons que nous ayons besoin de conna\u00eetre la destination de l'utilisateur. Si il ne l'a pas d\u00e9j\u00e0 indiqu\u00e9e, le bot devrait lui demander \"Pour quelle destination ?\". </p>"},{"location":"fr/user/studio/stories-and-answers/#actions","title":"Actions","text":"<p>Les actions sont pr\u00e9sent\u00e9es comme des suggestions, quand le canal le permet.</p> <p>Il est possible de pr\u00e9senter une arborescence d'actions pour construire un arbre de d\u00e9cision.</p>"},{"location":"fr/user/studio/stories-and-answers/#longlet-stories","title":"L'onglet Stories","text":"<p>Cet \u00e9cran permet de parcourir et g\u00e9rer les parcours ou stories cr\u00e9\u00e9es.</p> <p>Il peut s'agir des parcours configur\u00e9s via Tock Studio (ie. avec l'onglet New Story) mais aussi les parcours  d\u00e9clar\u00e9s programmatiquement via Bot API. Pour voir ces derniers, d\u00e9cochez l'option  Only Configured Stories.</p>"},{"location":"fr/user/studio/stories-and-answers/#longlet-rules","title":"L'onglet Rules","text":"<p>Cet onglet contient les sections suivantes :</p> <ul> <li> <p>Tagged Stories</p> <p>Cette section permet de visualiser les different stories qui ont une fonction particuli\u00e8re en fonction des tags avec lesquelles elles sont configur\u00e9es.</p> <p>On peut donc identifier les types suivants :</p> <ul> <li>Les stories de d\u00e9sactivation du bot qui sont tagu\u00e9es avec le tag DISABLE</li> <li>Les stories de r\u00e9activation du bot qui sont tagu\u00e9es avec le tag ENABLE</li> </ul> </li> <li> <p>Story Rules</p> <p>Cette section permet de cr\u00e9er ou modifier des r\u00e8gles de d\u00e9sactivation ou de redirection sur les stories.</p> </li> <li> <p>Application Features</p> <p>Cette section permet de g\u00e9rer des fonctions activables ou d\u00e9sactivables via l'interface (ou Feature Flipping).</p> </li> </ul>"},{"location":"fr/user/studio/stories-and-answers/#longlet-answers","title":"L'onglet Answers","text":"<p>Cet onglet permet de modifier les r\u00e9ponses du bot, dynamiquement selon plusieurs crit\u00e8res possibles :</p> <ul> <li> <p>La langue (c'est ce qu'on appelle internationalisation ou i18n)</p> </li> <li> <p>Le canal (textuel ou vocal), c'est-\u00e0-dire en pratique le connecteur</p> </li> <li> <p>Selon un roulement : il est possible d'enregistrer plusieurs textes de r\u00e9ponse pour un m\u00eame label dans  une m\u00eame langue sur un m\u00eame connecteur - le bot r\u00e9pondra alors al\u00e9atoirement l'un de ces textes, puis effectuera un  roulement afin de ne pas toujours r\u00e9pondre la m\u00eame chose.</p> </li> </ul> <p>Cela permet de rendre le bot plus agr\u00e9able en variant ses r\u00e9ponses.</p> <p></p> <p>Voir aussi Construire un bot multilingue pour l'utilisation de l'onglet Responses mais aussi les aspects d\u00e9veloppement sur ce th\u00e8me. </p>"},{"location":"fr/user/studio/stories-and-answers/#continuer","title":"Continuer...","text":"<p>Rendez-vous dans Menu Test pour la suite du manuel utilisateur. </p> <p>Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement. </p>"},{"location":"fr/user/studio/test/","title":"Le menu Test","text":"<p>Le menu Test permet de tester un bot directement dans l'interface Tock Studio, ainsi que de g\u00e9rer des plans de  tests automatiques.</p>"},{"location":"fr/user/studio/test/#longlet-test-the-bot","title":"L'onglet Test the Bot","text":"<p>Via ce menu, vous pouvez parler directement au bot en simulant diff\u00e9rentes langues et connecteurs. Cela permet de tester rapidement et simplement un bot dans l'interface Tock Studio,  sans avoir \u00e0 utiliser de logiciels et canaux externes.</p> <p>L'interface reste minimale car l'objectif est de tester rapidement le bot, pas d'obtenir  une v\u00e9ritable interface utilisateur ni m\u00eame un rendu identique \u00e0 celui de tel ou tel connecteur.</p> <p>Selon le type de messages renvoy\u00e9s par le bot et selon le connecteur utilis\u00e9, il se peut que le rendu dans  l'\u00e9cran Test the bot ne soit pas satisfaisant. En effet, pour une compatibilit\u00e9 parfaite avec cet \u00e9cran, les connecteurs doivent respecter certaines r\u00e8gles d'impl\u00e9mentation.</p> <p>Si vous constatez qu'un certain type de message pour un connecteur donn\u00e9 n'est pas bien g\u00e9r\u00e9 dans cette interface, n'h\u00e9sitez pas \u00e0 remonter une issue GitHub. </p> <p>Pour parler \u00e0 un bot dans l'interface, une fois dans Test &gt; Test the bot :</p> <ul> <li>V\u00e9rifiez la langue (en haut \u00e0 droite de l'interface)</li> <li>S\u00e9lectionnez une application/un bot</li> <li>S\u00e9lectionnez un connecteur \u00e0 \u00e9muler</li> <li>Commencez \u00e0 saisir des phrases...</li> </ul> <p></p> <p>Voici un autre exemple avec une conversation comprenant des composants riches du connecteur Messenger, avec leur rendu   dans l'interface g\u00e9n\u00e9rique Tock Studio :</p> <p></p> <p>Pour chaque \u00e9change de messages avec le bot, la langue d\u00e9tect\u00e9e est indiqu\u00e9e. En cliquant sur   View Nlp Stats vous pouvez voir le d\u00e9tail de la r\u00e9ponse du mod\u00e8le : intention, entit\u00e9s, scores, etc.</p>"},{"location":"fr/user/studio/test/#longlet-test-plans","title":"L'onglet Test Plans","text":"<p>Cet outil permet de cr\u00e9er et de suivre l'ex\u00e9cution de tests de conversations automatis\u00e9s, afin de v\u00e9rifier  automatiquement et r\u00e9guli\u00e8rement la non-r\u00e9gression du bot. Cette partie est en plein d\u00e9veloppement et une documentation  compl\u00e8te arrivera prochainement.</p>"},{"location":"fr/user/studio/test/#continuer","title":"Continuer...","text":"<p>Rendez-vous dans Menu Analytics pour la suite du manuel utilisateur. </p> <p>Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement. </p>"},{"location":"fr/guide/api/","title":"Programmer des parcours en Kotlin","text":"<p>Les interfaces Tock Studio permettent de cr\u00e9er des bots et des parcours relativement simples, comme  des arbres de d\u00e9cision et des r\u00e9ponses \u00e0 des questions courantes. Cela s'av\u00e8re suffisant pour de nombreux cas  d'usages conversationnels.</p> <p>Toutefois, il est possible de construire des r\u00e9ponses et des parcours plus complexes :</p> <ul> <li> <p>Se brancher \u00e0 un compte utilisateur</p> </li> <li> <p>Aggr\u00e9ger les informations de r\u00e9f\u00e9rentiels m\u00e9tier</p> </li> <li> <p>Appeler les services du SI (Syst\u00e8me d'Information) dans une organisation</p> </li> <li> <p>Int\u00e9grer des API externes pour enrichir ses parcours de services tiers</p> </li> <li> <p>Effectuer des actions et des transactions : cr\u00e9ation de tickets, paiements, etc.</p> </li> <li> <p>Impl\u00e9menter des r\u00e8gles de gestion et comportements sp\u00e9cifiques</p> </li> <li> <p>Optimiser les encha\u00eenements entre les intentions</p> </li> </ul> <p>Pour construire des parcours complexes, Tock propose plusieurs modes d'int\u00e9gration destin\u00e9s \u00e0   diff\u00e9rents langages et frameworks de d\u00e9veloppement.</p> <p>Dans ce guide, vous utiliserez le langage Kotlin et le mode    WebSocket pour ajouter une intention \u00e0 un bot initi\u00e9 dans Tock Studio.</p> <p>Si vous le souhaitez, vous pouvez sauter cette \u00e9tape et d\u00e9ployer un plateforme avec Docker  ou passer directement au manuel utilisateur pour en savoir plus sur les possibilit\u00e9s de Tock Studio.</p>"},{"location":"fr/guide/api/#ce-que-vous-allez-creer","title":"Ce que vous allez cr\u00e9er","text":"<ul> <li> <p>Une intention Tock d\u00e9velopp\u00e9e avec le langage Kotlin</p> </li> <li> <p>Un programme se connectant au bot en WebSocket pour l'enrichir de parcours programm\u00e9s</p> </li> </ul>"},{"location":"fr/guide/api/#pre-requis","title":"Pr\u00e9-requis","text":"<ul> <li> <p>Environ 10 minutes</p> </li> <li> <p>Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock)</p> </li> <li> <p>Un environnement de d\u00e9veloppement (ou IDE) supportant Kotlin, par exemple  IntelliJ avec des versions r\u00e9centes du JDK  et de Maven</p> </li> </ul> <p>Si vous ne souhaitez pas utiliser d'IDE, ou Maven, pas de probl\u00e8me. Il est tout \u00e0 fait possible de r\u00e9aliser le m\u00eame  exercice avec d'autres outils.</p> <p>Il est \u00e9galement possible d'utiliser d'autres mani\u00e8res de d\u00e9velopper que le mode WebSocket et d'autres  langages que Kotlin. Vous en apprendrez plus dans le manuel utilisateur Tock.</p>"},{"location":"fr/guide/api/#creer-un-programme-kotlin-avec-la-dependance-tock","title":"Cr\u00e9er un programme Kotlin avec la d\u00e9pendance Tock","text":"<p>Il existe de nombreuses mani\u00e8res de cr\u00e9er un projet en Kotlin.</p> <p>Ajoutez au classpath la biblioth\u00e8que <code>tock-bot-api-websocket</code> pour le mode WebSocket.</p> <p>Si vous utilisez Apache Maven, voici un exemple de POM (<code>pom.xml</code>) pour Kotlin avec  la d\u00e9pendance <code>tock-bot-api-websocket</code> incluse :</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;test&lt;/groupId&gt;\n    &lt;artifactId&gt;tock-kotlin-websocket&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;plugin.kotlin.version&gt;1.3.41&lt;/plugin.kotlin.version&gt;\n        &lt;plugin.source.version&gt;3.1.0&lt;/plugin.source.version&gt;\n        &lt;lib.tock.version&gt;24.9.4&lt;/lib.tock.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;ai.tock&lt;/groupId&gt;\n            &lt;artifactId&gt;tock-bot-api-websocket&lt;/artifactId&gt;\n            &lt;version&gt;${lib.tock.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;sourceDirectory&gt;${project.basedir}/src/main/kotlin&lt;/sourceDirectory&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;\n                &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;${plugin.kotlin.version}&lt;/version&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;compile&lt;/id&gt;\n                        &lt;phase&gt;compile&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;compile&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;test-compile&lt;/id&gt;\n                        &lt;phase&gt;test-compile&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;test-compile&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;\n                &lt;version&gt;${plugin.source.version}&lt;/version&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;attach-sources&lt;/id&gt;\n                        &lt;phase&gt;verify&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre> <p>Vous pouvez retrouver ce code et d'autres exemples dans le d\u00e9p\u00f4t tock-bot-samples.</p>"},{"location":"fr/guide/api/#creer-une-fonction-qui-se-connecte-a-tock","title":"Cr\u00e9er une fonction qui se connecte \u00e0 Tock","text":"<ul> <li> <p>Cr\u00e9ez un fichier Kotlin (par exemple dans `src/main/kotlin/StartWebSocket.kt)</p> </li> <li> <p>Editez-le avec le code suivant :</p> </li> </ul> <pre><code>import ai.tock.bot.api.client.newBot\nimport ai.tock.bot.api.client.newStory\nimport ai.tock.bot.api.websocket.startWithDemo\n\nfun main() {\n    startWithDemo( // Integrate with the Tock demo platform by default\n        newBot(\n            \"PUT-YOUR-TOCK-APP-API-KEY-HERE\", // Get your app API key from Bot Configurations in Tock Studio\n            newStory(\"qui-es-tu\") { // Answer for the 'qui-es-tu' story\n                send(\"Je suis un assistant conversationnel construit avec Tock\")\n                end(\"Comment puis-je aider ?\")\n            }\n        )\n    )\n}\n</code></pre> <p>Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples.</p> <ul> <li> <p>Remplacez la clef d'API par celle de votre propre application Tock. Pour cela, dans Tock Studio,  allez dans Configuration &gt; Bot Configurations et reportez la valeur API Key dans le code.</p> </li> <li> <p>Ex\u00e9cutez la fonction (main) dans votre environnement de d\u00e9veloppement. Vous devriez voir appara\u00eetre une ligne  de log ressemblant \u00e0 celle-ci :</p> </li> </ul> <pre><code>[main] INFO  ai.tock.bot.api.websocket.BotApiWebSocketClient - start web socket client: {...}\n</code></pre> <p>V\u00e9rifiez \u00e9ventuellement que d'autres logs provenant de <code>BotApiWebSocketClient</code> n'indiquent pas d'erreur. Si c'est le cas, il peut s'agir d'une erreur de configuration de la clef d'API.</p>"},{"location":"fr/guide/api/#terminer-la-configuration-dans-tock-studio","title":"Terminer la configuration dans Tock Studio","text":"<ul> <li> <p>Retournez dans Tock et allez dans Stories &amp; Answers &gt; Stories</p> </li> <li> <p>D\u00e9cochez l'option Only Configured Stories. Vous voyez alors tous parcours, y compris \"qui-es-tu\" que vous venez de  d\u00e9clarer programmatiquement</p> </li> <li> <p>Allez dans Test &gt; Test the Bot et saisissez une ou plusieurs phrases comme \"qui es-tu ?\" par exemple. Vous contastez que le bot ne r\u00e9pond pas encore \u00e0 cette question - il r\u00e9pond peut-\u00eatre m\u00eame \u00e0 une autre  intention. Il reste en effet une configuration \u00e0 effectuer pour que la qualification fonctionne.</p> </li> </ul> <p>A ce stade, le parcours existe bien dans Tock, mais l'intention n'a pas \u00e9t\u00e9 cr\u00e9\u00e9e automatiquement. Vous pouvez le v\u00e9rifier en regardant la liste des intentions disponibles dans Language Understanding &gt; Intents &gt; build  (la cat\u00e9gorie par d\u00e9faut).</p> <p>Ce point sera bient\u00f4t am\u00e9lior\u00e9 (issue #533).</p> <ul> <li> <p>Allez dans Language Understanding &gt; Inbox, pour la derni\u00e8re phrase que vous venez de saisir :</p> <ul> <li> <p>Changez l'intention pour New intent</p> </li> <li> <p>Nommez-la \"qui-es-tu\" comme dans le code (pour que le lien se fasse)</p> </li> <li> <p>Cr\u00e9ez l'intention avec Create</p> </li> <li> <p>Puis terminez la qualification de la phrase avec Validate</p> </li> </ul> </li> <li> <p>Si vous avez saisi d'autres phrases pour cette intention, pour chacune d'elles s\u00e9lectionnez l'intention dans la  liste puis confirmez avec Validate</p> </li> <li> <p>Retournez dans Test &gt; Test the Bot. Si vous reposez la question, le bot vous donne d\u00e9sormais la r\u00e9ponse  construite dans le code Kotlin (ie. \"Je suis un assistant...\").</p> </li> </ul>"},{"location":"fr/guide/api/#felicitations","title":"F\u00e9licitations!","text":"<p>Vous venez de configurer votre premi\u00e8re story programmatique en Kotlin.</p> <p>De cette mani\u00e8re, vous pouvez tirer pleinement parti des possibilit\u00e9s d'un langage de programmation pour  construire toutes sortes de parcours simples et complexes, interroger des API tierces, impl\u00e9menter des   r\u00e8gles de gestion, etc.</p> <p>Si vous programmez ainsi une story d\u00e9j\u00e0 d\u00e9finie dans Tock Studio, c'est la d\u00e9finition pr\u00e9sente dans Tock Studio  qui est utilis\u00e9e pour construire les r\u00e9ponses \u00e0 l'ex\u00e9cution.</p>"},{"location":"fr/guide/api/#continuer","title":"Continuer...","text":"<p>Dans la section suivante vous apprendrez \u00e0 :</p> <ul> <li>D\u00e9ployer une plateforme Tock en quelques minutes avec Docker</li> </ul> <p>Pour en savoir plus sur l'utilisation de Tock Bot API en mode WebSocket, mais aussi les autres  modes de d\u00e9ploiement, les types de messages support\u00e9s par Tock, etc. vous pouvez consulter le  manuel utilisateur.</p>"},{"location":"fr/guide/messenger/","title":"Configurer son bot pour Messenger","text":"<p>Si vous avez suivi le guide Cr\u00e9er son premier bot avec Tock Studio, vous avez d\u00e9clar\u00e9 un connecteur  de type Slack.</p> <p>Dans ce guide, vous allez cr\u00e9er une configuration pour Facebook Messenger  et int\u00e9grer le bot pour dialoguer avec lui sur ce r\u00e9seau social.</p> <p>Si vous le souhaitez, vous pouvez aussi sauter cette \u00e9tape et passer directement \u00e0 la suite.</p>"},{"location":"fr/guide/messenger/#ce-que-vous-allez-creer","title":"Ce que vous allez cr\u00e9er","text":"<ul> <li> <p>Une configuration (dans Facebook et dans Tock) pour recevoir et envoyer des messages via Messenger</p> </li> <li> <p>Un bot qui parle sur une page Facebook ou dans Messenger</p> </li> </ul>"},{"location":"fr/guide/messenger/#pre-requis","title":"Pr\u00e9-requis","text":"<ul> <li> <p>Environ 20 minutes</p> </li> <li> <p>Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock)</p> </li> <li> <p>Un compte Facebook Developer</p> </li> </ul>"},{"location":"fr/guide/messenger/#creer-une-page-facebook","title":"Cr\u00e9er une page Facebook","text":"<ul> <li>Cr\u00e9ez une page Facebook</li> </ul> <ul> <li>Donnez-lui un nom (par exemple My Tock Bot)</li> </ul> <p>Recommandation : ne publiez pas la page pour limiter son acc\u00e8s des utilisateurs Messenger :  Param\u00e8tres &gt; G\u00e9n\u00e9ral &gt; Visibilit\u00e9 de la page &gt; Non publi\u00e9e</p>"},{"location":"fr/guide/messenger/#creer-une-application-facebook","title":"Cr\u00e9er une application Facebook","text":"<ul> <li> <p>Allez sur la page Facebook for developers &gt; Voir toutes les applications</p> </li> <li> <p>Ajouter une app</p> </li> </ul> <p></p> <ul> <li>Cr\u00e9er une app &gt; G\u00e9rer les int\u00e9grations professionnelles</li> </ul> <p></p> <ul> <li>Entrez un nom pour l'application</li> </ul> <p></p> <ul> <li>Ajoutez un produit : Messenger</li> </ul> <p></p> <p></p>"},{"location":"fr/guide/messenger/#creer-un-connecteur-messenger","title":"Cr\u00e9er un connecteur Messenger","text":"<ul> <li>Dans Tock Studio allez dans Settings &gt; Configurations :</li> </ul> <ul> <li>Cr\u00e9ez un connecteur de type Messenger et ouvrez la section Connector Custom Configuration</li> </ul> <ul> <li>Compl\u00e9ter les champs (voir ci-dessous champ par champ) :</li> </ul> <ul> <li>Application Id : il se trouve sur la page de votre application sur https://developers.facebook.com</li> </ul> <ul> <li>Page Id : il se trouve sur la page li\u00e9e \u00e0 votre application sur https://facebook.com</li> </ul> <ul> <li>Call Token : le jeton se trouve sur la page de votre application sur https://developers.facebook.com </li> </ul> <ul> <li> <p>Webhook Token : choisissez un jeton quelconque (m\u00eame <code>jeton</code> si vous voulez) et notez-le pour plus tard -   chaque appel \u00e0 Tock provenant de Facebook sera pass\u00e9 en transmettant ce jeton</p> </li> <li> <p>Secret : \u00e0 copier de la page de votre application sur https://developers.facebook.com</p> </li> </ul> <p></p> <ul> <li> <p>Persona Id : vous pouvez laisser ce champ vide</p> </li> <li> <p>V\u00e9rifiez que la configuration du connecteur est bien enregistr\u00e9e</p> </li> </ul>"},{"location":"fr/guide/messenger/#configurer-lurl-de-rappel","title":"Configurer l'URL de rappel","text":"<ul> <li> <p>Retournez sur la page de configuration de votre application sur https://developers.facebook.com :   Produits &gt; Messenger &gt; Param\u00e8tres &gt; Webhooks</p> </li> <li> <p>Cliquez sur Ajouter l'URL de rappel (ou Modifier l'URL de rappel si vous aviez pr\u00e9c\u00e9demment une autre URL)</p> </li> <li> <p>Entrez l'URL \u00e0 laquelle votre connecteur Tock est actuellement d\u00e9ploy\u00e9, et le jeton de webhook que vous avez choisi   lors de la configuration du connecteur</p> </li> </ul> <p>Pour retrouver l'URL de votre connecteur, allez sur la page de configuration Tock Studio &gt; Settings &gt; Configurations, d\u00e9roulez la configuration de votre connecteur Messenger, et concat\u00e9nez le contenu du champ Application base url et celui du champ Relative REST path.</p> <ul> <li> <p>Cliquez sur V\u00e9rifier et enregistrer</p> </li> <li> <p>Testez votre bot sur Messenger !</p> </li> </ul>"},{"location":"fr/guide/messenger/#felicitations","title":"F\u00e9licitations !","text":"<p>Votre bot dialogue d\u00e9sormais sur Messenger, en plus des autres canaux auquel vous l'avez int\u00e9gr\u00e9.</p> <p>Le mod\u00e8le conversationnel, les fonctionnalit\u00e9s et la personnalit\u00e9 de votre assistant sont construits et  restent ind\u00e9pendants des canaux sur lesquels le bot est pr\u00e9sent. Toutefois, rien ne vous emp\u00eache de cr\u00e9er  des parcours ou des r\u00e9ponses sp\u00e9cifiquement pour tel ou tel canal, comme vous le verrez au travers  de diff\u00e9rents outils Tock : \u00e9cran de gestion des Responses, activation d'intentions sur tel ou tel canal  avec l'\u00e9cran Story Rules, utilisation des DSLs et de la Bot API pour tirer parti de composants graphiques  sp\u00e9cifiques, etc.</p>"},{"location":"fr/guide/messenger/#continuer","title":"Continuer...","text":"<p>Dans les sections suivantes vous apprendrez \u00e0 :</p> <ul> <li> <p>Cr\u00e9er des parcours programm\u00e9s en Kotlin, ouvrant la voie \u00e0 des comportements complexes et  l'int\u00e9gration d'API tierces si besoin</p> </li> <li> <p>D\u00e9ployer une plateforme Tock en quelques minutes avec Docker</p> </li> </ul> <p>Pour en savoir plus sur le connecteur Messenger fourni avec Tock, rendez-vous dans le dossier  connector-messenger sur GitHub,  o\u00f9 vous retrouverez les sources et le README du connecteur.</p> <p>Pour en savoir plus sur Tock Studio, les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi  parcourir le manuel utilisateur, plus complet.</p>"},{"location":"fr/guide/platform/","title":"D\u00e9ployer une plateforme avec Docker","text":"<p>Dans les sections pr\u00e9c\u00e9dentes pour d\u00e9couvrir et tester Tock, vous avez utilis\u00e9 la  plateforme de d\u00e9monstration. Cela vous a permis de d\u00e9couvrir  la construction et la configuration des bots Tock sans avoir \u00e0 installer la plateforme au pr\u00e9alable. </p> <p>Dans ce guide, vous allez apprendre \u00e0 d\u00e9ployer une plateforme compl\u00e8te Tock en quelques minutes, gr\u00e2ce   aux exemples d'impl\u00e9mentations Docker / Docker Compose fournies.</p> <p>Notez qu'il est tout \u00e0 fait possible de d\u00e9ployer Tock sans utiliser Docker. Une section sp\u00e9cifique du  manuel utilisateur vous en apprendra plus sur l'architecture, les possibilit\u00e9s et les  recommandations pour le d\u00e9ploiement et l'utilisation de Tock en production.</p>"},{"location":"fr/guide/platform/#ce-que-vous-allez-creer","title":"Ce que vous allez cr\u00e9er","text":"<ul> <li> <p>Une plateforme Tock compl\u00e8te en local : Tock Studio, Bot API, etc.</p> </li> <li> <p>Un bot et une configuration minimale pour tester la plateforme</p> </li> <li> <p>(Optionnel) Un programme Kotlin se connectant \u00e0 la plateforme locale en  WebSocket</p> </li> </ul>"},{"location":"fr/guide/platform/#pre-requis","title":"Pr\u00e9-requis","text":"<ul> <li> <p>Environ 20 minutes</p> </li> <li> <p>Pour d\u00e9ployer la plateforme en local, un environnement de d\u00e9veloppement avec des versions r\u00e9centes de  Docker et Docker Compose install\u00e9es</p> </li> </ul> <p>Si vous ne souhaitez pas utiliser Docker, pas de probl\u00e8me. Il y a d'autres mani\u00e8res de d\u00e9ployer la base MongoDB  et les services Kotlin sur JVM. Vous pouvez toutefois parcourir les <code>Dockerfile</code> et  <code>docker-compose.yml</code> \u00e0 titre d'exemples pour instancier ces services.</p> <ul> <li>(Optionnel) Pour le programme en WebSocket, un environnement de d\u00e9veloppement (ou IDE) supportant  Kotlin, par exemple IntelliJ avec des versions r\u00e9centes  du JDK et de Maven</li> </ul> <p>Sans IDE ou sans Maven, pas de probl\u00e8me. Il est tout \u00e0 fait possible de compiler et ex\u00e9cuter le programme avec d'autres outils.</p> <p>D'autres modes que Kotlin et WebSocket sont pr\u00e9sent\u00e9s dans le manuel utilisateur Tock.</p>"},{"location":"fr/guide/platform/#deployer-une-plateforme-tock-sans-les-sources","title":"D\u00e9ployer une plateforme Tock - sans les sources","text":"<p>Il est possible de r\u00e9cup\u00e9rer seulement quelques fichiers du d\u00e9p\u00f4t GitHub, sans t\u00e9l\u00e9charger toutes les sources Tock.   En quelques lignes de commande, la plateforme est op\u00e9rationnelle.</p> <p>Il est cependant indispensable d'avoir des versions r\u00e9centes de   Docker et Docker Compose.</p> <p>Pour d\u00e9marrer depuis les sources du d\u00e9p\u00f4t Tock Docker, passez plut\u00f4t au  paragraphe suivant.</p> <pre><code># Get the lastest docker-compose from GitHub (including Bot API)\n$ curl -o docker-compose.yml https://raw.githubusercontent.com/theopenconversationkit/tock-docker/master/docker-compose-bot.yml\n# Get the lastest database-init script from GitHub\n$ mkdir -p scripts &amp;&amp; curl -o scripts/setup.sh https://raw.githubusercontent.com/theopenconversationkit/tock-docker/master/scripts/setup.sh &amp;&amp; chmod +x scripts/setup.sh\n# Get the lastest Tock version/tag from GitHub\n$ curl -o .env https://raw.githubusercontent.com/theopenconversationkit/tock-docker/master/.env\n\n# Run the stack\n$ docker-compose up\n</code></pre>"},{"location":"fr/guide/platform/#deployer-une-plateforme-tock-depuis-les-sources","title":"D\u00e9ployer une plateforme Tock - depuis les sources","text":"<p>Ceci est une mani\u00e8re alternative de d\u00e9marrer Tock, \u00e0 partir du d\u00e9p\u00f4t   Tock Docker. </p> <p>Il vous faut, en plus de Docker et Docker Compose,    soit un client Git pour r\u00e9cup\u00e9rer les sources (commande <code>git clone</code>) soit avoir d\u00e9j\u00e0 copi\u00e9    les sources de GitHub en local.</p> <p>Pour d\u00e9marrer sans Git ni les sources du d\u00e9p\u00f4t en local, suivez le  paragraphe pr\u00e9c\u00e9dent.</p> <pre><code># Get the lastest sources from GitHub\n$ git clone https://github.com/theopenconversationkit/tock-docker.git &amp;&amp; cd tock-docker\n# Make the database-init script executable\n$ chmod +x scripts/setup.sh\n\n# Run the stack (including Bot API)\n$ docker-compose -f docker-compose-bot.yml up\n</code></pre>"},{"location":"fr/guide/platform/#acceder-a-tock-studio","title":"Acc\u00e9der \u00e0 Tock Studio","text":"<p>Une fois la plateforme pr\u00eate, les interfaces Tock Studio sont sur le port <code>80</code> par d\u00e9faut :</p> <ul> <li>Allez sur http://localhost</li> </ul> <p>Apr\u00e8s le d\u00e9ploiement de la plateforme, celle-ci s'initialise, et il peut falloir attendre quelques secondes  avant que les interfaces Tock Studio soient accessibles.</p> <ul> <li>Connectez-vous avec les identifiants <code>admin@app.com</code> / <code>password</code> par d\u00e9faut</li> </ul> <p>Il est \u00e9videmment recommand\u00e9 de changer ces valeurs \u00e0 l'installation d'une plateforme destin\u00e9e \u00e0 une utilisation p\u00e9renne (production, plateforme partag\u00e9e entre \u00e9quipes, etc.). </p>"},{"location":"fr/guide/platform/#creer-une-application-un-connecteur-et-une-intention","title":"Cr\u00e9er une application, un connecteur et une intention","text":"<p>Comme dans le guide premier bot utilisant la plateforme de d\u00e9monstration, vous allez cr\u00e9er une  application Tock et un connecteur pour commencer \u00e0 utiliser la plateforme locale. N'h\u00e9sitez pas \u00e0 retourner voir les  pr\u00e9c\u00e9dents guides pour plus de commentaires.</p> <p>Au premier acc\u00e8s \u00e0 la plateforme locale :</p> <ul> <li> <p>Saisissez un nom pour l'application</p> </li> <li> <p>S\u00e9lectionnez une langue - vous pourrez en ajouter d'autres par la suite</p> </li> <li> <p>Validez pour cr\u00e9er l'application</p> </li> <li> <p>Allez dans Settings &gt; Configurations</p> </li> <li> <p>Create a new Configuration</p> </li> <li> <p>S\u00e9lectionnez le type de connecteur Slack</p> </li> <li> <p>Create</p> </li> </ul> <p>Notez l'API Key automatiquement g\u00e9n\u00e9r\u00e9e pour votre application. Elle vous servira si vous essayez le mode WebSocket dans la suite de ce guide (optionnel).</p> <ul> <li> <p>Allez dans Stories &amp; Answers &gt; New Story</p> </li> <li> <p>Saisissez une phrase utilisateur par exemple \"bonjour\"</p> </li> <li> <p>Dans le champs Add new Answer, saisissez une r\u00e9ponse par exemple \"quelle belle journ\u00e9e!\"</p> </li> <li> <p>Terminez avec Create Story</p> </li> <li> <p>Allez dans Test &gt; Test the Bot</p> </li> <li> <p>Dites \"bonjour\" \ud83d\ude4b, le bot vous r\u00e9pond \ud83e\udd16</p> </li> </ul>"},{"location":"fr/guide/platform/#connecter-un-parcours-en-kotlin-optionnel","title":"Connecter un parcours en Kotlin (optionnel)","text":"<p>Comme dans le guide programmer des parcours utilisant la plateforme de d\u00e9monstration, vous allez cr\u00e9er une  application Kotlin se connectant en WebSocket \u00e0 la plateforme Tock locale. N'h\u00e9sitez pas \u00e0 retourner voir les  pr\u00e9c\u00e9dents guides pour plus de d\u00e9tails.</p> <ul> <li>Cr\u00e9ez un projet Kotlin par exemple avec Maven comme indiqu\u00e9 dans le guide programmer des parcours</li> </ul> <p>Le classpath doit inclure <code>tock-bot-api-websocket</code> pour utiliser le mode WebSocket.</p> <ul> <li> <p>Cr\u00e9ez un fichier Kotlin (par exemple dans `src/main/kotlin/StartWebSocket.kt)</p> </li> <li> <p>Editez-le avec le code suivant :</p> </li> </ul> <pre><code>import ai.tock.bot.api.client.newBot\nimport ai.tock.bot.api.client.newStory\nimport ai.tock.bot.api.websocket.start\n\nfun main() {\n    start( // Do not use #startWithDemo when integrating with a local platform \n        newBot(\n            \"PUT-YOUR-TOCK-APP-API-KEY-HERE\", // Get your app API key from Bot Configurations in Tock Studio\n            newStory(\"qui-es-tu\") { // Answer for the 'qui-es-tu' story\n                send(\"Je suis un assistant conversationnel construit avec Tock\")\n                end(\"Comment puis-je aider ?\")\n            }\n        ),\n        \"http://localhost:8080\" // Local platform URL (default host/port)\n    ) \n}\n</code></pre> <p>Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples.</p> <ul> <li> <p>Remplacez la clef d'API par celle de votre propre application Tock. Pour cela, dans Tock Studio,  allez dans Settings &gt; Configurations et reportez la valeur API Key dans le code.</p> </li> <li> <p>Ex\u00e9cutez la fonction (main) dans votre environnement de d\u00e9veloppement.</p> </li> <li> <p>Retournez dans Tock dans Test &gt; Test the Bot et dites \"qui es-tu ?\" : le bot ne r\u00e9pond pas encore.</p> </li> <li> <p>Allez dans Language Understanding &gt; Inbox, pour la phrase que vous venez de saisir :</p> <ul> <li> <p>Changez l'intention pour New intent</p> </li> <li> <p>Nommez-la \"qui-es-tu\" comme dans le code (pour que le lien se fasse)</p> </li> <li> <p>Cr\u00e9ez l'intention avec Create</p> </li> <li> <p>Terminez la qualification de la phrase avec Validate</p> </li> </ul> </li> <li> <p>Retournez dans Test &gt; Test the Bot. Dites \"qui es-tu ?\" : le bot r\u00e9pond !</p> </li> </ul>"},{"location":"fr/guide/platform/#felicitations","title":"F\u00e9licitations!","text":"<p>Vous venez de d\u00e9ployer votre propre plateforme conversationnelle Tock en local.</p> <p>Cela peut servir \u00e0 mieux appr\u00e9hender l'architecture et v\u00e9rifier la portabilit\u00e9 de la solution, mais aussi lors de  d\u00e9veloppements, pour les contributeurs Tock ou encore si vous devez travailler sans acc\u00e8s \u00e0 Internet  (en mobilit\u00e9, sur un r\u00e9seau restreint, etc.).</p> <p>Attention, l'impl\u00e9mentation Docker fournie ne suffit pas \u00e0 garantir r\u00e9silience et mont\u00e9e en charge de la plateforme  quelles que soient les conditions en production. Pour cela, quelques recommandations sont propos\u00e9es dans la section  haute disponibilit\u00e9 du manuel Tock.</p>"},{"location":"fr/guide/platform/#continuer","title":"Continuer...","text":"<p>Vous venez de terminer les guides de d\u00e9marrage rapide Tock.</p> <p>A partir de l\u00e0, vous pouvez vous lancer directement sur une plateforme Tock, ou parcourir le  manuel utilisateur pour en savoir plus sur Tock Studio, Bot API et Bot Flow par exemple.</p> <p>D'autres pages pr\u00e9sentent aussi des \u00e9tudes de cas clients, des exemples de code, comment contacter la communaut\u00e9 Tock, etc.</p>"},{"location":"fr/guide/slack/","title":"Configurer son bot pour Slack","text":"<p>Si vous avez suivi le guide Cr\u00e9er son premier bot avec Tock Studio, vous avez d\u00e9clar\u00e9 un connecteur  de type Slack mais celui-ci n'est pas encore configur\u00e9 pour que le bot parle r\u00e9ellement sur Slack.</p> <p>Avec un peu de configuration c\u00f4t\u00e9 Slack et c\u00f4t\u00e9 Tock, un bot peut recevoir des messages et r\u00e9pondre sur ce canal.</p> <p>Si vous le souhaitez, vous pouvez aussi sauter cette \u00e9tape et configurer un canal Messenger  ou passer directement \u00e0 la suite.</p>"},{"location":"fr/guide/slack/#ce-que-vous-allez-creer","title":"Ce que vous allez cr\u00e9er","text":"<ul> <li> <p>Une configuration (dans Slack et dans Tock) pour recevoir et envoyer des messages Slack</p> </li> <li> <p>Un bot qui parle sur une cha\u00eene Slack</p> </li> </ul>"},{"location":"fr/guide/slack/#pre-requis","title":"Pr\u00e9-requis","text":"<ul> <li> <p>Environ 15 minutes</p> </li> <li> <p>Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock)</p> </li> <li> <p>Un compte Slack et un espace de travail / une cha\u00eene o\u00f9 int\u00e9grer le bot</p> </li> </ul> <p>Si vous n'avez jamais utilis\u00e9 Slack, rendez-vous sur sur https://slack.com/</p>"},{"location":"fr/guide/slack/#creer-une-application-dans-slack","title":"Cr\u00e9er une application dans Slack","text":"<ul> <li> <p>Allez sur la page Create a Slack app</p> </li> <li> <p>Entrez un nom pour l'application</p> </li> <li> <p>S\u00e9lectionnez un espace de travail</p> </li> <li> <p>Terminez avec Create App</p> </li> </ul>"},{"location":"fr/guide/slack/#activer-lenvoi-de-messages-a-slack","title":"Activer l'envoi de messages \u00e0 Slack","text":"<ul> <li> <p>Ouvrez Incoming Webhooks et cochez Activate Incoming Webhooks</p> </li> <li> <p>Cliquez sur Add New Webhook to Workspace </p> </li> <li> <p>S\u00e9lectionnez une cha\u00eene ou une personne pour la conversation avec le bot</p> </li> <li> <p>Terminez par Installer</p> </li> <li> <p>Copiez la Webhook URL qui vient d'\u00eatre cr\u00e9\u00e9e</p> </li> </ul> <p>La Webhook URL ressemble dans son format \u00e0 quelque chose comme :  https://hooks.slack.com/services/{workspaceToken}/{webhookToken}/{authToken}</p> <ul> <li> <p>Dans Tock Studio allez dans Configuration &gt; Bot Configurations</p> </li> <li> <p>Trouvez votre connecteur de type Slack (ou cr\u00e9ez-en un nouveau si besoin) et ouvrez la section Connector Custom Configuration</p> </li> <li> <p>Saisissez dans les trois champs tokens les jetons issus de l'adresse pr\u00e9c\u00e9demment copi\u00e9e :</p> <ul> <li> <p>Token 1 : le premier token de la WebhookURL, ou workspaceToken</p> </li> <li> <p>Token 2 : le deuxi\u00e8me token de la WebhookURL, ou webhookToken</p> </li> <li> <p>Token 3 : le dernier token de la WebhookURL, ou authToken</p> </li> </ul> </li> <li> <p>Terminez avec Update</p> </li> </ul> <p>Attention : en cas de r\u00e9installation de l'application Slack dans le workspace, URL et jetons sont chang\u00e9s et doivent \u00eatre report\u00e9s dans la configuration c\u00f4t\u00e9 Tock.</p>"},{"location":"fr/guide/slack/#activer-la-reception-de-messages-depuis-slack","title":"Activer la reception de messages depuis Slack","text":"<ul> <li> <p>Dans la page de votre application Slack, allez dans Event Subscriptions et activez Enable Events</p> </li> <li> <p>Entrez dans le champ Request URL l'adresse compl\u00e8te de votre connecteur Slack dans Tock.</p> </li> </ul> <p>Sur la plateforme de d\u00e9monstration Tock, cette adresse sera du type  https://demo.tock.ai/{chemin_relatif_du_connecteur_slack}</p> <p>Le chemin relatif du connecteur est indiqu\u00e9 dans la page Bot Configurations. Sur la ligne correspondant \u00e0 votre connecteur Slack, il s'agit du champ Relative REST path</p> <ul> <li>Ouvrez Add Workspace Event et s\u00e9lectionnez l'\u00e9venement message.channels pour  utiliser le bot sur une cha\u00eene Slack.</li> </ul> <p>D'autres \u00e9v\u00e9nements \"message\" sont \u00e9galement disponibles : message.im pour les messages priv\u00e9s,   message.groups, etc. Cf la documentation Slack.</p> <ul> <li> <p>Validez avec Save Changes</p> </li> <li> <p>Allez dans Interactive Components et activez Interactivity</p> </li> <li> <p>Entrez la m\u00eame Request URL que pr\u00e9c\u00e9demment</p> </li> <li> <p>Validez avec Save Changes</p> </li> </ul>"},{"location":"fr/guide/slack/#creer-un-bot-slack-et-lui-parler","title":"Cr\u00e9er un bot Slack (et lui parler)","text":"<ul> <li> <p>Dans la page de votre application Slack, allez dans Bot Users et faites Add a Bot User</p> </li> <li> <p>Choisissez un nom / identifiant pour le bot dans Slack</p> </li> <li> <p>Validez avec Add Bot User</p> </li> <li> <p>Allez dans Install App et Reinstall App</p> </li> <li> <p>S\u00e9lectionnez la cha\u00eene Slack puis Installer</p> </li> <li> <p>Dans Slack, allez sur la cha\u00eene et ajoutez le bot \u00e0 la cha\u00eene</p> </li> <li> <p>Parlez au bot (par exemple \"bonjour\"). Il vous r\u00e9pond maintenant dans Slack !</p> </li> </ul>"},{"location":"fr/guide/slack/#regarder-la-conversation-dans-tock-studio-optionnel","title":"Regarder la conversation dans Tock Studio (optionnel)","text":"<p>Quelque soient les canaux utilis\u00e9s pour converser avec le bot, vous pouvez suivre les conversations directement dans  tous les \u00e9crans Tock Studio, par exemple : Language Understanding &gt; Inbox et Logs,  ou encore toutes vues du menu Analytics :</p> <ul> <li>Dans Tock, ouvrez Analytics &gt; Users et cliquez sur l'ic\u00f4ne Display dialog pour voir toute la  conversation provenant de Slack</li> </ul>"},{"location":"fr/guide/slack/#felicitations","title":"F\u00e9licitations!","text":"<p>Vous venez de configurer votre bot pour qu'il parle \u00e9galement sur Slack.</p> <p>Comme vous le constatez, connecter un bot Tock \u00e0 un (ou plusieurs) canaux externes n'est qu'une affaire de configuration.  Vous pouvez construire le mod\u00e8le conversationnel, les fonctionnalit\u00e9s et la personnalit\u00e9 de votre assistant   ind\u00e9pendamment des canaux sur lesquels vous souhaitez lui parler, aujourd'hui ou \u00e0 l'avenir.</p>"},{"location":"fr/guide/slack/#continuer","title":"Continuer...","text":"<p>Dans les sections suivantes vous apprendrez \u00e0 :</p> <ul> <li> <p>Configurer le bot pour le canal Messenger (requiert un compte Facebook)</p> </li> <li> <p>Cr\u00e9er des parcours programm\u00e9s en Kotlin, ouvrant la voie \u00e0 des comportements complexes et  l'int\u00e9gration d'API tierces si besoin</p> </li> <li> <p>D\u00e9ployer une plateforme Tock en quelques minutes avec Docker</p> </li> </ul> <p>Pour en savoir plus sur le connecteur Slack fourni avec Tock, rendez-vous dans le dossier  connector-slack sur GitHub,  o\u00f9 vous retrouverez les sources et le README du connecteur.</p> <p>Pour en savoir plus sur Tock Studio, les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi  parcourir le manuel utilisateur, plus complet.</p>"},{"location":"fr/guides/studio/","title":"Cr\u00e9er son premier bot avec Tock Studio","text":"<p>Un bon moyen de tester Tock est certainement de cr\u00e9er son premier bot conversationnel dans Tock Studio (l'interface  graphiques fournie avec la plateforme).</p> <p>En se connectant \u00e0 la plateforme de d\u00e9monstration Tock, il  est possible de cr\u00e9er et tester un assistant en quelques minutes sans \u00e9crire de code.</p>"},{"location":"fr/guides/studio/#ce-que-vous-allez-creer","title":"Ce que vous allez cr\u00e9er","text":"<ul> <li> <p>Une application et un connecteur sur la plateforme de d\u00e9monstration Tock</p> </li> <li> <p>Une story : phrase utilisateur / r\u00e9ponse du bot, testable dans l'interface Tock Studio</p> </li> <li> <p>Un assistant qui r\u00e9pond quand vous lui dites \"bonjour\" ! \ud83d\ude42</p> </li> </ul>"},{"location":"fr/guides/studio/#pre-requis","title":"Pr\u00e9-requis","text":"<ul> <li> <p>Entre 5 et 15 minutes environ (en lisant les commentaires)</p> </li> <li> <p>Un compte GitHub pour se connecter \u00e0 la plateforme de d\u00e9monstration</p> </li> </ul>"},{"location":"fr/guides/studio/#connexion-a-la-plateforme-demo","title":"Connexion \u00e0 la plateforme d\u00e9mo","text":"<p>Rendez-vous sur https://demo.tock.ai/ pour acc\u00e9der \u00e0 la plateforme de d\u00e9monstration Tock.</p> <p>Remarque importante : Cette plateforme n'a pas vocation \u00e0 accueillir de v\u00e9ritables bots en production.  C'est un moyen de tester et prendre en main la solution Tock sans avoir \u00e0 l'installer.</p> <p>Une invite appara\u00eet pour vous identifier avec votre compte GitHub. Apr\u00e8s cela, vous devez accepter que Tock acc\u00e8de  \u00e0 votre compte - seul l'identifiant de votre compte GitHub sera lu.</p>"},{"location":"fr/guides/studio/#creer-une-application-tock","title":"Cr\u00e9er une application Tock","text":"<p>Au premier acc\u00e8s \u00e0 la plateforme de d\u00e9monstration, un assistant invite \u00e0 cr\u00e9er une application :</p> <ul> <li> <p>Saisissez un nom pour l'application</p> </li> <li> <p>S\u00e9lectionnez une langue - vous pourrez en ajouter d'autres par la suite</p> </li> <li> <p>Validez pour cr\u00e9er l'application</p> </li> </ul> <p>Vous pouvez retrouver l'application cr\u00e9\u00e9e dans le menu : Settings &gt; Applications.</p> <p>Si vous aviez d\u00e9j\u00e0 cr\u00e9\u00e9 une ou plusieurs applications, vous pouvez en cr\u00e9er de nouvelles en revenant \u00e0 cet \u00e9cran puis Create New Application.</p>"},{"location":"fr/guides/studio/#ajouter-un-connecteur","title":"Ajouter un connecteur","text":"<p>Pour int\u00e9ragir avec le bot, il faut utiliser un connecteur afin de l'exposer \u00e0 un canal de communication.  De nombreux connecteurs existent pour Tock : Messenger, WhatsApp, Google Assistant et Google Home, Twitter, Alexa, Business Chat,  Teams, Slack,  Rocket.Chat...  Il est m\u00eame possible de d\u00e9velopper ses propres connecteurs pour ouvrir le bot \u00e0 de nouveaux canaux.</p> <p>Pour ce tutoriel, vous allez configurer un connecteur pour Slack.  Dans un premier temps, vous testerez le bot en restant dans l'interface Tock Studio, et n'aurez pas besoin d'utiliser Slack.</p> <p>Dans la section suivante Configurer Slack, vous pourrez compl\u00e9ter la configuration c\u00f4t\u00e9 Slack et c\u00f4t\u00e9 Tock afin que le bot soit fonctionnel sur cette plateforme collaborative.</p> <p>De m\u00eame, la section Configurer Messenger vous montrera comment activer le m\u00eame bot sur la messagerie du r\u00e9seau social Facebook.</p> <p>Cr\u00e9ez un premier connecteur pour votre application :</p> <ul> <li> <p>Allez dans Settings &gt; Configurations</p> </li> <li> <p>Create a new Configuration</p> </li> <li> <p>S\u00e9lectionnez le type de connecteur Slack</p> </li> <li> <p>Entrez <code>token</code> dans les champs Token (pour le moment)</p> </li> <li> <p>Create</p> </li> </ul> <p>Notez qu'une API Key a \u00e9t\u00e9 automatiquement g\u00e9n\u00e9r\u00e9e pour votre application \u00e0 la cr\u00e9ation du premier connecteur.  Celle-ci vous servira \u00e0 vous connecter \u00e0 l'API du bot si vous essayez le mode WebHook ou WebSocket dans le guide  Programmer des parcours.</p> <p>Si vous cliquez sur Display test configurations, vous pouvez voir qu'une seconde configuration est cr\u00e9\u00e9e.  Ce connecteur sp\u00e9cial sera utilis\u00e9 pour tester le bot directement depuis l'interface Tock Studio.  Gr\u00e2ce \u00e0 lui, vous pourrez parler au bot sans passer par Slack.</p>"},{"location":"fr/guides/studio/#creer-un-parcours","title":"Cr\u00e9er un parcours","text":"<p>Un bot conversationnel analyse les phrases des utilisateurs en langage naturel, pour en d\u00e9terminer l'intention et  \u00e9ventuellement des entit\u00e9s.</p> <p>Exemple : dans la phrase \"Quel temps fera-t-il demain ?\", le moteur NLU (Natural Language Understanding) de Tock va reconna\u00eetre une intention \"m\u00e9t\u00e9o\" et une entit\u00e9 \"demain\" venant pr\u00e9ciser/param\u00e9trer cette intention.</p> <p>Encore faut-il avoir d\u00e9clar\u00e9 les intentions et entit\u00e9s possibles, puis qualifi\u00e9 des phrases pour apprendre au bot \u00e0  les d\u00e9tecter. Le menu Language Understanding de Tock permet de g\u00e9rer intentions et entit\u00e9s, qualifier les phrases  et ainsi superviser l'apprentissage du bot : plus on qualifie de phrases, plus le bot devient pertinent dans sa compr\u00e9hension du langage.</p> <p>Mais laissons intentions et entit\u00e9s de c\u00f4t\u00e9 pour le moment...</p> <p>Le mode Stories de Tock permet en quelques clics de cr\u00e9er automatiquement des intentions ainsi que les r\u00e9ponses \u00e0 fournir.  Ainsi, sans quitter l'interface Tock Studio, vous allez cr\u00e9er un premier parcours de question(s)-r\u00e9ponse(s).</p> <ul> <li> <p>Allez dans Stories &amp; Answers &gt; New Story</p> </li> <li> <p>Saisissez une phrase utilisateur par exemple \"bonjour\"</p> </li> </ul> <p>Un formulaire s'ouvre vous permettant de configurer la cr\u00e9ation de la story, l'intention qui sera \u00e9galement cr\u00e9\u00e9e, le  type de r\u00e9ponse, etc.</p> <ul> <li> <p>Dans le champs Add new Answer, saisissez une r\u00e9ponse par exemple \"quelle belle journ\u00e9e!\"</p> </li> <li> <p>Terminez avec Create Story</p> </li> </ul> <p>Il est possible de r\u00e9pondre par plusieurs messages, ou des messages plus \u00e9volu\u00e9s comme des images, des liens, des  boutons d'Action de mani\u00e8re \u00e0 continuer le dialogue, etc. La section Tock Studio du manuel utilisateur Tock vous en apprendra plus.</p>"},{"location":"fr/guides/studio/#tester-le-bot","title":"Tester le bot","text":"<p>Il est maintenant temps de tester le bot et votre premier parcours!</p> <ul> <li> <p>Allez dans Test &gt; Test the Bot</p> </li> <li> <p>Dites \"bonjour\" \ud83d\ude4b, le bot vous r\u00e9pond \ud83e\udd16</p> </li> </ul> <p>Si le bot r\u00e9pond qu'il n'a pas compris, c'est certainement un probl\u00e8me de qualification. Vous pouvez v\u00e9rifier que la  story et/ou l'intention ont bien \u00e9t\u00e9 cr\u00e9\u00e9s en allant dans Build &gt; Search Stories.</p> <p>V\u00e9rifiez aussi que vous \u00eates sur la bonne application et la bonne langue (au cas o\u00f9 vous en auriez cr\u00e9\u00e9 plusieurs)  pour faire le test : ils sont visibles en haut \u00e0 droite de l'interface.</p> <p>Si malgr\u00e9 tout le bot r\u00e9pond qu'il ne comprend pas, peut-\u00eatre n'avez-vous pas saisi exactement la phrase utilis\u00e9e \u00e0  la cr\u00e9ation de la story, et le bot ne fait pas encore le lien avec cette seconde phrase. Dans le paragraphe suivant,  vous verrez comment am\u00e9liorer la compr\u00e9hension du bot en qualifiant plus de phrases utilisateur.</p> <p>Si vous obtenez un message d'erreur technique, il s'agit probablement d'une erreur de configuration du connecteur.</p>"},{"location":"fr/guides/studio/#ameliorer-la-comprehension","title":"Am\u00e9liorer la compr\u00e9hension","text":"<p>En saisissant des phrases un peu diff\u00e9rentes dans l'\u00e9cran Test the Bot, vous pouvez constater qu'il ne comprend pas encore tr\u00e8s bien votre langage - m\u00eame lorsque les phrases sont proches de celle saisie \u00e0 la cr\u00e9ation de la story.</p> <p>C'est normal.</p> <p>Le mod\u00e8le conversationnel et la partie Language Understanding de Tock s'enrichissent progressivement de phrases qualifi\u00e9es pour alimenter les algorithmes et donner des r\u00e9sultats de plus en plus pertinents.</p> <p>Les premiers essais peuvent \u00eatre d\u00e9cevants, mais souvent apr\u00e8s quelques qualifications, voire une ou deux dizaines  de phrases qualifi\u00e9es si besoin, votre bot vous comprend d\u00e9j\u00e0 bien mieux.</p> <ul> <li>Allez dans Language Understanding &gt; Inbox</li> </ul> <p>Vous voyez les phrases que vous avez saisies, et comment le bot les a interpr\u00eat\u00e9es. Pour chacune s'affichent l'intention reconnue, la langue ainsi que le score (que se donnent les algorithmes selon leur niveau de confiance sur cette phrase).</p> <ul> <li> <p>Choisissez quelques phrases, pour chacune s\u00e9lectionnez la bonne intention puis Validate</p> </li> <li> <p>Retournez dans Test &gt; Test the Bot</p> </li> <li> <p>V\u00e9rifiez que le bot comprend mieux ces phrases, et m\u00eames d'autres un peu diff\u00e9rentes alors que vous ne les avez pas  qualifi\u00e9es explicitement!</p> </li> </ul>"},{"location":"fr/guides/studio/#creer-dautres-parcours-optionnel","title":"Cr\u00e9er d'autres parcours (optionnel)","text":"<p>Pour aller un peu plus loin avec les stories Tock, vous pouvez cr\u00e9er d'autres parcours et les tester directement  dans Tock Studio.</p> <p>Le bot vous r\u00e9pond alors selon l'intention d\u00e9clench\u00e9e, sans autre forme de navigation que le fil que  vous donnez \u00e0 la conversation. C'est la magie du conversationnel : le langage naturel est la seule navigation, et  l'utilisateur est soustrait aux liens et menus traditionnellement impos\u00e9s par les interfaces Web ou mobiles.</p> <p>Remarque : si vous preniez le temps de cr\u00e9er de tr\u00e8s nombreuses stories, vous contasteriez peut-\u00eatre  quelques effets ind\u00e9sirables propres au mode de fonctionnement des mod\u00e8les et algorithmes NLU.</p> <p>Par exemple, un tr\u00e8s grand nombre d'intentions et d'entit\u00e9s peut rendre plus difficile leur d\u00e9tection.  On recommande souvent de commencer par cr\u00e9er des bots d\u00e9di\u00e9s \u00e0 un domaine fonctionnel  limit\u00e9, facilitant son apprentissage en focalisant le mod\u00e8le sur ce domaine.  Qualifier beaucoup de phrases permet en g\u00e9n\u00e9ral d'am\u00e9liorer la compr\u00e9hension, mais  \u00e0 l'inverse qualifier trop de phrases (ou trop proches) peut sur-entra\u00eener le mod\u00e8le pour une intention, avec  pour effet de r\u00e9duire la reconnaissance des phrases un peu diff\u00e9rentes.</p> <p>Retenez que la conception et la maintenance des mod\u00e8les conversationnels est un sujet complexe qui n\u00e9cessite de  l'apprentissage (du bot mais aussi de ceux qui le construisent), de r\u00e9-\u00e9valuer et r\u00e9-adapter r\u00e9guli\u00e8rement ces mod\u00e8les  aux besoins et aux nouvelles demandes des utilisateurs.</p>"},{"location":"fr/guides/studio/#felicitations","title":"F\u00e9licitations!","text":"<p>Vous venez de cr\u00e9er votre premier bot conversationnel avec Tock.</p> <p>Comme vous avez pu vous en apercevoir, quelques minutes suffisent, sans connaissances techniques approfondies, pour cr\u00e9er des parcours conversationnels simples sans \u00e9crire ni d\u00e9ployer de code.</p>"},{"location":"fr/guides/studio/#continuer","title":"Continuer...","text":"<p>Dans les sections suivantes vous apprendrez \u00e0 :</p> <ul> <li> <p>Configurer le bot pour le canal Slack (requiert un compte Slack)</p> </li> <li> <p>Configurer le bot pour le canal Messenger (requiert un compte Facebook)</p> </li> <li> <p>Cr\u00e9er des parcours programm\u00e9s en Kotlin, ouvrant la voie \u00e0 des comportements complexes et  l'int\u00e9gration d'API tierces si besoin</p> </li> <li> <p>D\u00e9ployer une plateforme Tock en quelques minutes avec Docker</p> </li> </ul> <p>Pour en savoir plus sur Tock Studio, les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi  parcourir le manuel utilisateur, plus complet.</p>"}]}